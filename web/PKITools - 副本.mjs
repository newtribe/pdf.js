class PKI  {

  asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

  _asyncToGenerator(fn) { return function  () { var self = this, args = arguments; return new Promise(  (resolve, reject) { var gen = fn.apply(self, args);   _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); }   _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

  _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  /**
   * Get value for input parameters, or set a default value
   * @param {Object} parameters
   * @param {string} name
   * @param defaultValue
   */

    getParametersValue(parameters, name, defaultValue) {
    // noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS
    if (parameters instanceof Object === false) return defaultValue; // noinspection NonBlockStatementBodyJS

    if (name in parameters) return parameters[name];
    return defaultValue;
  } //**************************************************************************************

  /**
   * Converts "ArrayBuffer" into a hexdecimal string
   * @param {ArrayBuffer} inputBuffer
   * @param {number} [inputOffset=0]
   * @param {number} [inputLength=inputBuffer.byteLength]
   * @param {boolean} [insertSpace=false]
   * @returns {string}
   */


    bufferToHexCodes(inputBuffer) {
    var inputOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var inputLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : inputBuffer.byteLength - inputOffset;
    var insertSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var result = "";
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = new Uint8Array(inputBuffer, inputOffset, inputLength)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;
        // noinspection Chained CallJS
        var str = item.toString(16).toUpperCase(); // noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS

        if (str.length === 1) result += "0";
        result += str; // noinspection NonBlockStatementBodyJS

        if (insertSpace) result += " ";
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return result.trim();
  } //**************************************************************************************
  // noinspection JSValidateJSDoc,  WithMultipleReturnPointsJS

  /**
   * Check input "ArrayBuffer" for common  s
   * @param {LocalBaseBlock} baseBlock
   * @param {ArrayBuffer} inputBuffer
   * @param {number} inputOffset
   * @param {number} inputLength
   * @returns {boolean}
   */


    checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    // noinspection ConstantOnRightSideOfComparisonJS
    if (inputBuffer instanceof ArrayBuffer === false) {
      // noinspection JSUndefinedPropertyAssignment
      baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
      return false;
    } // noinspection ConstantOnRightSideOfComparisonJS


    if (inputBuffer.byteLength === 0) {
      // noinspection JSUndefinedPropertyAssignment
      baseBlock.error = "Wrong parameter: inputBuffer has zero length";
      return false;
    } // noinspection ConstantOnRightSideOfComparisonJS


    if (inputOffset < 0) {
      // noinspection JSUndefinedPropertyAssignment
      baseBlock.error = "Wrong parameter: inputOffset less than zero";
      return false;
    } // noinspection ConstantOnRightSideOfComparisonJS


    if (inputLength < 0) {
      // noinspection JSUndefinedPropertyAssignment
      baseBlock.error = "Wrong parameter: inputLength less than zero";
      return false;
    } // noinspection ConstantOnRightSideOfComparisonJS


    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
      // noinspection JSUndefinedPropertyAssignment
      baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return false;
    }

    return true;
  } //**************************************************************************************
  // noinspection  WithMultipleReturnPointsJS

  /**
   * Convert number from 2^base to 2^10
   * @param {Uint8Array} inputBuffer
   * @param {number} inputBase
   * @returns {number}
   */


    utilFromBase(inputBuffer, inputBase) {
    var result = 0; // noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS

    if (inputBuffer.length === 1) return inputBuffer[0]; // noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS

    for (var i = inputBuffer.length - 1; i >= 0; i--) {
      result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
    }

    return result;
  } //**************************************************************************************
  // noinspection  WithMultipleLoopsJS,  WithMultipleReturnPointsJS

  /**
   * Convert number from 2^10 to 2^base
   * @param {!number} value The number to convert
   * @param {!number} base The base for 2^base
   * @param {number} [reserved=0] Pre-defined number of bytes in output array (-1 = limited by   itself)
   * @returns {ArrayBuffer}
   */


    utilToBase(value, base) {
    var reserved = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    var internalReserved = reserved;
    var internalValue = value;
    var result = 0;
    var biggest = Math.pow(2, base); // noinspection ConstantOnRightSideOfComparisonJS

    for (var i = 1; i < 8; i++) {
      if (value < biggest) {
        var retBuf = void 0; // noinspection ConstantOnRightSideOfComparisonJS

        if (internalReserved < 0) {
          retBuf = new ArrayBuffer(i);
          result = i;
        } else {
          // noinspection NonBlockStatementBodyJS
          if (internalReserved < i) return new ArrayBuffer(0);
          retBuf = new ArrayBuffer(internalReserved);
          result = internalReserved;
        }

        var retView = new Uint8Array(retBuf); // noinspection ConstantOnRightSideOfComparisonJS

        for (var j = i - 1; j >= 0; j--) {
          var basis = Math.pow(2, j * base);
          retView[result - j - 1] = Math.floor(internalValue / basis);
          internalValue -= retView[result - j - 1] * basis;
        }

        return retBuf;
      }

      biggest *= Math.pow(2, base);
    }

    return new ArrayBuffer(0);
  } //**************************************************************************************
  // noinspection  WithMultipleLoopsJS

  /**
   * Concatenate two ArrayBuffers
   * @param {...ArrayBuffer} buffers Set of ArrayBuffer
   */


    utilConcatBuf() {
    //region Initial variables
    var outputLength = 0;
    var prevLength = 0; //endregion
    //region Calculate output length
    // noinspection NonBlockStatementBodyJS

    for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
      buffers[_key] = arguments[_key];
    }

    for (var _i = 0, _buffers = buffers; _i < _buffers.length; _i++) {
      var buffer = _buffers[_i];
      outputLength += buffer.byteLength;
    } //endregion


    var retBuf = new ArrayBuffer(outputLength);
    var retView = new Uint8Array(retBuf);

    for (var _i2 = 0, _buffers2 = buffers; _i2 < _buffers2.length; _i2++) {
      var _buffer = _buffers2[_i2];
      // noinspection Nested CallJS
      retView.set(new Uint8Array(_buffer), prevLength);
      prevLength += _buffer.byteLength;
    }

    return retBuf;
  } //**************************************************************************************
  // noinspection  WithMultipleLoopsJS

  /**
   * Concatenate two Uint8Array
   * @param {...Uint8Array} views Set of Uint8Array
   */


    utilConcatView() {
    //region Initial variables
    var outputLength = 0;
    var prevLength = 0; //endregion
    //region Calculate output length
    // noinspection NonBlockStatementBodyJS

    for (var _len2 = arguments.length, views = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      views[_key2] = arguments[_key2];
    }

    for (var _i3 = 0, _views = views; _i3 < _views.length; _i3++) {
      var view = _views[_i3];
      outputLength += view.length;
    } //endregion


    var retBuf = new ArrayBuffer(outputLength);
    var retView = new Uint8Array(retBuf);

    for (var _i4 = 0, _views2 = views; _i4 < _views2.length; _i4++) {
      var _view2 = _views2[_i4];
      retView.set(_view2, prevLength);
      prevLength += _view2.length;
    }

    return retView;
  } //**************************************************************************************
  // noinspection  WithMultipleLoopsJS

  /**
   * Decoding of "two complement" values
   * The   must be called in scope of instance of "hexBlock" class ("valueHex" and "warnings" properties must be present)
   * @returns {number}
   */


    utilDecodeTC() {
    var buf = new Uint8Array(this.valueHex); // noinspection ConstantOnRightSideOfComparisonJS

    if (this.valueHex.byteLength >= 2) {
      //noinspection JSBitwiseOperatorUsage, ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS
      var condition1 = buf[0] === 0xFF && buf[1] & 0x80; // noinspection ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS

      var condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00; // noinspection NonBlockStatementBodyJS

      if (condition1 || condition2) this.warnings.push("Needlessly long format");
    } //region Create big part of the integer


    var bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    var bigIntView = new Uint8Array(bigIntBuffer); // noinspection NonBlockStatementBodyJS

    for (var i = 0; i < this.valueHex.byteLength; i++) {
      bigIntView[i] = 0;
    } // noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS


    bigIntView[0] = buf[0] & 0x80; // mask only the biggest bit

    var bigInt = utilFromBase(bigIntView, 8); //endregion
    //region Create small part of the integer

    var smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    var smallIntView = new Uint8Array(smallIntBuffer); // noinspection NonBlockStatementBodyJS

    for (var j = 0; j < this.valueHex.byteLength; j++) {
      smallIntView[j] = buf[j];
    } // noinspection MagicNumberJS


    smallIntView[0] &= 0x7F; // mask biggest bit

    var smallInt = utilFromBase(smallIntView, 8); //endregion

    return smallInt - bigInt;
  } //**************************************************************************************
  // noinspection  WithMultipleLoopsJS,  WithMultipleReturnPointsJS

  /**
   * Encode integer value to "two complement" format
   * @param {number} value Value to encode
   * @returns {ArrayBuffer}
   */


    utilEncodeTC(value) {
    // noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS
    var modValue = value < 0 ? value * -1 : value;
    var bigInt = 128; // noinspection ConstantOnRightSideOfComparisonJS

    for (var i = 1; i < 8; i++) {
      if (modValue <= bigInt) {
        // noinspection ConstantOnRightSideOfComparisonJS
        if (value < 0) {
          var smallInt = bigInt - modValue;

          var _retBuf = utilToBase(smallInt, 8, i);

          var _retView = new Uint8Array(_retBuf); // noinspection MagicNumberJS


          _retView[0] |= 0x80;
          return _retBuf;
        }

        var retBuf = utilToBase(modValue, 8, i);
        var retView = new Uint8Array(retBuf); //noinspection JSBitwiseOperatorUsage, MagicNumberJS, NonShortCircuitBooleanExpressionJS

        if (retView[0] & 0x80) {
          //noinspection JSCheck Signatures
          var tempBuf = retBuf.slice(0);
          var tempView = new Uint8Array(tempBuf);
          retBuf = new ArrayBuffer(retBuf.byteLength + 1); // noinspection ReuseOfLocalVariableJS

          retView = new Uint8Array(retBuf); // noinspection NonBlockStatementBodyJS

          for (var k = 0; k < tempBuf.byteLength; k++) {
            retView[k + 1] = tempView[k];
          } // noinspection MagicNumberJS


          retView[0] = 0x00;
        }

        return retBuf;
      }

      bigInt *= Math.pow(2, 8);
    }

    return new ArrayBuffer(0);
  } //**************************************************************************************
  // noinspection  WithMultipleReturnPointsJS, ParameterNamingConventionJS

  /**
   * Compare two array buffers
   * @param {!ArrayBuffer} inputBuffer1
   * @param {!ArrayBuffer} inputBuffer2
   * @returns {boolean}
   */


    isEqualBuffer(inputBuffer1, inputBuffer2) {
    // noinspection NonBlockStatementBodyJS
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) return false; // noinspection LocalVariableNamingConventionJS

    var view1 = new Uint8Array(inputBuffer1); // noinspection LocalVariableNamingConventionJS

    var view2 = new Uint8Array(inputBuffer2);

    for (var i = 0; i < view1.length; i++) {
      // noinspection NonBlockStatementBodyJS
      if (view1[i] !== view2[i]) return false;
    }

    return true;
  } //**************************************************************************************
  // noinspection  WithMultipleReturnPointsJS

  /**
   * Pad input number with leade "0" if needed
   * @returns {string}
   * @param {number} inputNumber
   * @param {number} fullLength
   */


    padNumber(inputNumber, fullLength) {
    var str = inputNumber.toString(10); // noinspection NonBlockStatementBodyJS

    if (fullLength < str.length) return "";
    var dif = fullLength - str.length;
    var padding = new Array(dif); // noinspection NonBlockStatementBodyJS

    for (var i = 0; i < dif; i++) {
      padding[i] = "0";
    }

    var paddingString = padding.join("");
    return paddingString.concat(str);
  } //**************************************************************************************


  var base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="; //**************************************************************************************
  // noinspection  WithMultipleLoopsJS, OverlyComplex JS,  TooLongJS,  NamingConventionJS

  /**
   * Encode string into BASE64 (or "base64url")
   * @param {string} input
   * @param {boolean} useUrlTemplate If "true" then output would be encoded using "base64url"
   * @param {boolean} skipPadding Skip BASE-64 padding or not
   * @param {boolean} skipLeadingZeros Skip leading zeros in input data or not
   * @returns {string}
   */

    toBase64(input) {
    var useUrlTemplate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var skipPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var skipLeadingZeros = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var i = 0; // noinspection LocalVariableNamingConventionJS

    var flag1 = 0; // noinspection LocalVariableNamingConventionJS

    var flag2 = 0;
    var output = ""; // noinspection ConditionalExpressionJS

    var template = useUrlTemplate ? base64UrlTemplate : base64Template;

    if (skipLeadingZeros) {
      var nonZeroPosition = 0;

      for (var _i5 = 0; _i5 < input.length; _i5++) {
        // noinspection ConstantOnRightSideOfComparisonJS
        if (input.charCodeAt(_i5) !== 0) {
          nonZeroPosition = _i5; // noinspection BreakStatementJS

          break;
        }
      } // noinspection AssignmentTo ParameterJS


      input = input.slice(nonZeroPosition);
    }

    while (i < input.length) {
      // noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
      var chr1 = input.charCodeAt(i++); // noinspection NonBlockStatementBodyJS

      if (i >= input.length) flag1 = 1; // noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS

      var chr2 = input.charCodeAt(i++); // noinspection NonBlockStatementBodyJS

      if (i >= input.length) flag2 = 1; // noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS

      var chr3 = input.charCodeAt(i++); // noinspection LocalVariableNamingConventionJS

      var enc1 = chr1 >> 2; // noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS

      var enc2 = (chr1 & 0x03) << 4 | chr2 >> 4; // noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS

      var enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6; // noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS

      var enc4 = chr3 & 0x3F; // noinspection ConstantOnRightSideOfComparisonJS

      if (flag1 === 1) {
        // noinspection NestedAssignmentJS, AssignmentResultUsedJS, MagicNumberJS
        enc3 = enc4 = 64;
      } else {
        // noinspection ConstantOnRightSideOfComparisonJS
        if (flag2 === 1) {
          // noinspection MagicNumberJS
          enc4 = 64;
        }
      } // noinspection NonBlockStatementBodyJS


      if (skipPadding) {
        // noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
        if (enc3 === 64) output += "".concat(template.charAt(enc1)).concat(template.charAt(enc2));else {
          // noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS
          if (enc4 === 64) output += "".concat(template.charAt(enc1)).concat(template.charAt(enc2)).concat(template.charAt(enc3));else output += "".concat(template.charAt(enc1)).concat(template.charAt(enc2)).concat(template.charAt(enc3)).concat(template.charAt(enc4));
        }
      } else output += "".concat(template.charAt(enc1)).concat(template.charAt(enc2)).concat(template.charAt(enc3)).concat(template.charAt(enc4));
    }

    return output;
  } //**************************************************************************************
  // noinspection  WithMoreThanThreeNegationsJS,  WithMultipleLoopsJS, OverlyComplex JS,  NamingConventionJS

  /**
   * Decode string from BASE64 (or "base64url")
   * @param {string} input
   * @param {boolean} [useUrlTemplate=false] If "true" then output would be encoded using "base64url"
   * @param {boolean} [cutTailZeros=false] If "true" then cut tailing zeroz from   result
   * @returns {string}
   */


    fromBase64(input) {
    var useUrlTemplate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var cutTailZeros = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    // noinspection ConditionalExpressionJS
    var template = useUrlTemplate ? base64UrlTemplate : base64Template; //region Aux  s
    // noinspection  WithMultipleReturnPointsJS, Nested JS

      indexof(toSearch) {
      // noinspection ConstantOnRightSideOfComparisonJS, MagicNumberJS
      for (var _i6 = 0; _i6 < 64; _i6++) {
        // noinspection NonBlockStatementBodyJS
        if (template.charAt(_i6) === toSearch) return _i6;
      } // noinspection MagicNumberJS


      return 64;
    } // noinspection Nested JS


      test(incoming) {
      // noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS, MagicNumberJS
      return incoming === 64 ? 0x00 : incoming;
    } //endregion


    var i = 0;
    var output = "";

    while (i < input.length) {
      // noinspection Nested CallJS, LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS
      var enc1 = indexof(input.charAt(i++)); // noinspection Nested CallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS

      var enc2 = i >= input.length ? 0x00 : indexof(input.charAt(i++)); // noinspection Nested CallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS

      var enc3 = i >= input.length ? 0x00 : indexof(input.charAt(i++)); // noinspection Nested CallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS

      var enc4 = i >= input.length ? 0x00 : indexof(input.charAt(i++)); // noinspection LocalVariableNamingConventionJS, NonShortCircuitBooleanExpressionJS

      var chr1 = test(enc1) << 2 | test(enc2) >> 4; // noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS

      var chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2; // noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS

      var chr3 = (test(enc3) & 0x03) << 6 | test(enc4);
      output += String.fromCharCode(chr1); // noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS

      if (enc3 !== 64) output += String.fromCharCode(chr2); // noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS

      if (enc4 !== 64) output += String.fromCharCode(chr3);
    }

    if (cutTailZeros) {
      var outputLength = output.length;
      var nonZeroStart = -1; // noinspection ConstantOnRightSideOfComparisonJS

      for (var _i7 = outputLength - 1; _i7 >= 0; _i7--) {
        // noinspection ConstantOnRightSideOfComparisonJS
        if (output.charCodeAt(_i7) !== 0) {
          nonZeroStart = _i7; // noinspection BreakStatementJS

          break;
        }
      } // noinspection NonBlockStatementBodyJS, NegatedIfStatementJS


      if (nonZeroStart !== -1) output = output.slice(0, nonZeroStart + 1);else output = "";
    }

    return output;
  } //**************************************************************************************


    arrayBufferToString(buffer) {
    var resultString = "";
    var view = new Uint8Array(buffer); // noinspection NonBlockStatementBodyJS

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = view[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var element = _step2.value;
        resultString += String.fromCharCode(element);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return resultString;
  } //**************************************************************************************


    stringToArrayBuffer(str) {
    var stringLength = str.length;
    var resultBuffer = new ArrayBuffer(stringLength);
    var resultView = new Uint8Array(resultBuffer); // noinspection NonBlockStatementBodyJS

    for (var i = 0; i < stringLength; i++) {
      resultView[i] = str.charCodeAt(i);
    }

    return resultBuffer;
  } //**************************************************************************************


  var log2 = Math.log(2); //**************************************************************************************
  // noinspection  NamingConventionJS

  /**
   * Get nearest to input length power of 2
   * @param {number} length Current length of existing array
   * @returns {number}
   */

    nearestPowerOf2(length) {
    var base = Math.log(length) / log2;
    var floor = Math.floor(base);
    var round = Math.round(base); // noinspection ConditionalExpressionJS

    return floor === round ? floor : round;
  } //**************************************************************************************

  /**
   * Delete properties by name from specified object
   * @param {Object} object Object to delete properties from
   * @param {Array.<string>} propsArray Array of properties names
   */


    clearProps(object, propsArray) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = propsArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var prop = _step3.value;
        delete object[prop];
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  } //**************************************************************************************

  /* eslint-disable indent */
  //**************************************************************************************
  //region Declaration of global variables
  //**************************************************************************************


  var powers2 = [new Uint8Array([1])];
  var digitsString = "0123456789"; //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration for "LocalBaseBlock" class
  //**************************************************************************************

  /**
   * Class used as a base block for all remaining ASN.1 classes
   * @typedef LocalBaseBlock
   * @interface
   * @property {number} blockLength
   * @property {string} error
   * @property {Array.<string>} warnings
   * @property {ArrayBuffer} valueBeforeDecode
   */

  class LocalBaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalBaseBlock" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueBeforeDecode]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {number} blockLength
       */
      this.blockLength = getParametersValue(parameters, "blockLength", 0);
      /**
       * @type {string} error
       */

      this.error = getParametersValue(parameters, "error", "");
      /**
       * @type {Array.<string>} warnings
       */

      this.warnings = getParametersValue(parameters, "warnings", []); //noinspection JSCheck Signatures

      /**
       * @type {ArrayBuffer} valueBeforeDecode
       */

      if ("valueBeforeDecode" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "baseBlock";
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
     */


    toJSON() {
      return {
        blockName: this.constructor.blockName(),
        blockLength: this.blockLength,
        error: this.error,
        warnings: this.warnings,
        valueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Description for "LocalHexBlock" class
  //**************************************************************************************

  /**
   * Class used as a base block for all remaining ASN.1 classes
   * @extends LocalBaseBlock
   * @typedef LocalHexBlock
   * @property {number} blockLength
   * @property {string} error
   * @property {Array.<string>} warnings
   * @property {ArrayBuffer} valueBeforeDecode
   * @property {boolean} isHexOnly
   * @property {ArrayBuffer} valueHex
   */
  //noinspection JSUnusedLocalSymbols


  var LocalHexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass {
    //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Constructor for "LocalHexBlock" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueHex]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      /**
       * @type {boolean}
       */

      this.isHexOnly = getParametersValue(parameters, "isHexOnly", false);
      /**
       * @type {ArrayBuffer}
       */

      if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "hexBlock";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Basic check for parameters
      //noinspection JSCheck Signatures
      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion
      //region Getting Uint8Array from ArrayBuffer

      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion
      //region Initial checks

      if (intBuffer.length === 0) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      } //endregion
      //region Copy input buffer to internal buffer


      this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength); //endregion

      this.blockLength = inputLength;
      return inputOffset + inputLength;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.isHexOnly !== true) {
        this.error = "Flag \"isHexOnly\" is not set, abort";
        return new ArrayBuffer(0);
      }

      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength); //noinspection JSCheck Signatures

      return this.valueHex.slice(0);
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.blockName = this.constructor.blockName();
      object.isHexOnly = this.isHexOnly;
      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
      return object;
    } //**********************************************************************************


  }; //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of identification block class
  //**************************************************************************************


  class LocalIdentificationBlock extends LocalHexBlock(LocalBaseBlock) {
    //**********************************************************************************

    /**
     * Constructor for "LocalBaseBlock" class
     * @param {Object} [parameters={}]
     * @property {Object} [idBlock]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super();

      if ("idBlock" in parameters) {
        //region Properties from hexBlock class
        this.isHexOnly = getParametersValue(parameters.idBlock, "isHexOnly", false);
        this.valueHex = getParametersValue(parameters.idBlock, "valueHex", new ArrayBuffer(0)); //endregion

        this.tagClass = getParametersValue(parameters.idBlock, "tagClass", -1);
        this.tagNumber = getParametersValue(parameters.idBlock, "tagNumber", -1);
        this.isConstructed = getParametersValue(parameters.idBlock, "isConstructed", false);
      } else {
        this.tagClass = -1;
        this.tagNumber = -1;
        this.isConstructed = false;
      }
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "identificationBlock";
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //region Initial variables
      var firstOctet = 0;
      var retBuf;
      var retView; //endregion

      switch (this.tagClass) {
        case 1:
          firstOctet |= 0x00; // UNIVERSAL

          break;

        case 2:
          firstOctet |= 0x40; // APPLICATION

          break;

        case 3:
          firstOctet |= 0x80; // CONTEXT-SPECIFIC

          break;

        case 4:
          firstOctet |= 0xC0; // PRIVATE

          break;

        default:
          this.error = "Unknown tag class";
          return new ArrayBuffer(0);
      }

      if (this.isConstructed) firstOctet |= 0x20;

      if (this.tagNumber < 31 && !this.isHexOnly) {
        retBuf = new ArrayBuffer(1);
        retView = new Uint8Array(retBuf);

        if (!sizeOnly) {
          var number = this.tagNumber;
          number &= 0x1F;
          firstOctet |= number;
          retView[0] = firstOctet;
        }

        return retBuf;
      }

      if (this.isHexOnly === false) {
        var encodedBuf = utilToBase(this.tagNumber, 7);
        var encodedView = new Uint8Array(encodedBuf);
        var size = encodedBuf.byteLength;
        retBuf = new ArrayBuffer(size + 1);
        retView = new Uint8Array(retBuf);
        retView[0] = firstOctet | 0x1F;

        if (!sizeOnly) {
          for (var i = 0; i < size - 1; i++) {
            retView[i + 1] = encodedView[i] | 0x80;
          }

          retView[size] = encodedView[size - 1];
        }

        return retBuf;
      }

      retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
      retView = new Uint8Array(retBuf);
      retView[0] = firstOctet | 0x1F;

      if (sizeOnly === false) {
        var curView = new Uint8Array(this.valueHex);

        for (var _i8 = 0; _i8 < curView.length - 1; _i8++) {
          retView[_i8 + 1] = curView[_i8] | 0x80;
        }

        retView[this.valueHex.byteLength] = curView[curView.length - 1];
      }

      return retBuf;
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number}
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Basic check for parameters
      //noinspection JSCheck Signatures
      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion
      //region Getting Uint8Array from ArrayBuffer

      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion
      //region Initial checks

      if (intBuffer.length === 0) {
        this.error = "Zero buffer length";
        return -1;
      } //endregion
      //region Find tag class


      var tagClassMask = intBuffer[0] & 0xC0;

      switch (tagClassMask) {
        case 0x00:
          this.tagClass = 1; // UNIVERSAL

          break;

        case 0x40:
          this.tagClass = 2; // APPLICATION

          break;

        case 0x80:
          this.tagClass = 3; // CONTEXT-SPECIFIC

          break;

        case 0xC0:
          this.tagClass = 4; // PRIVATE

          break;

        default:
          this.error = "Unknown tag class";
          return -1;
      } //endregion
      //region Find it's constructed or not


      this.isConstructed = (intBuffer[0] & 0x20) === 0x20; //endregion
      //region Find tag number

      this.isHexOnly = false;
      var tagNumberMask = intBuffer[0] & 0x1F; //region Simple case (tag number < 31)

      if (tagNumberMask !== 0x1F) {
        this.tagNumber = tagNumberMask;
        this.blockLength = 1;
      } //endregion
      //region Tag number bigger or equal to 31
      else {
          var count = 1;
          this.valueHex = new ArrayBuffer(255);
          var tagNumberBufferMaxLength = 255;
          var intTagNumberBuffer = new Uint8Array(this.valueHex); //noinspection JSBitwiseOperatorUsage

          while (intBuffer[count] & 0x80) {
            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
            count++;

            if (count >= intBuffer.length) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
            } //region In case if tag number length is greater than 255 bytes (rare but possible case)


            if (count === tagNumberBufferMaxLength) {
              tagNumberBufferMaxLength += 255;

              var _tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);

              var _tempBufferView = new Uint8Array(_tempBuffer);

              for (var i = 0; i < intTagNumberBuffer.length; i++) {
                _tempBufferView[i] = intTagNumberBuffer[i];
              }

              this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);
              intTagNumberBuffer = new Uint8Array(this.valueHex);
            } //endregion

          }

          this.blockLength = count + 1;
          intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer
          //region Cut buffer

          var tempBuffer = new ArrayBuffer(count);
          var tempBufferView = new Uint8Array(tempBuffer);

          for (var _i9 = 0; _i9 < count; _i9++) {
            tempBufferView[_i9] = intTagNumberBuffer[_i9];
          }

          this.valueHex = new ArrayBuffer(count);
          intTagNumberBuffer = new Uint8Array(this.valueHex);
          intTagNumberBuffer.set(tempBufferView); //endregion
          //region Try to convert long tag number to short form

          if (this.blockLength <= 9) this.tagNumber = utilFromBase(intTagNumberBuffer, 7);else {
            this.isHexOnly = true;
            this.warnings.push("Tag too long, represented as hex-coded");
          } //endregion
        } //endregion
      //endregion
      //region Check if constructed encoding was using for primitive type


      if (this.tagClass === 1 && this.isConstructed) {
        switch (this.tagNumber) {
          case 1: // Boolean

          case 2: // REAL

          case 5: // Null

          case 6: // OBJECT IDENTIFIER

          case 9: // REAL

          case 14: // Time

          case 23:
          case 24:
          case 31:
          case 32:
          case 33:
          case 34:
            this.error = "Constructed encoding used for primitive type";
            return -1;

          default:
        }
      } //endregion


      return inputOffset + this.blockLength; // Return current offset in input buffer
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {{blockName: string,
     *  tagClass: number,
     *  tagNumber: number,
     *  isConstructed: boolean,
     *  isHexOnly: boolean,
     *  valueHex: ArrayBuffer,
     *  blockLength: number,
     *  error: string, warnings: Array.<string>,
     *  valueBeforeDecode: string}}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.blockName = this.constructor.blockName();
      object.tagClass = this.tagClass;
      object.tagNumber = this.tagNumber;
      object.isConstructed = this.isConstructed;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of length block class
  //**************************************************************************************


  class LocalLengthBlock extends LocalBaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalLengthBlock" class
     * @param {Object} [parameters={}]
     * @property {Object} [lenBlock]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super();

      if ("lenBlock" in parameters) {
        this.isIndefiniteForm = getParametersValue(parameters.lenBlock, "isIndefiniteForm", false);
        this.longFormUsed = getParametersValue(parameters.lenBlock, "longFormUsed", false);
        this.length = getParametersValue(parameters.lenBlock, "length", 0);
      } else {
        this.isIndefiniteForm = false;
        this.longFormUsed = false;
        this.length = 0;
      }
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "lengthBlock";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number}
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Basic check for parameters
      //noinspection JSCheck Signatures
      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion
      //region Getting Uint8Array from ArrayBuffer

      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion
      //region Initial checks

      if (intBuffer.length === 0) {
        this.error = "Zero buffer length";
        return -1;
      }

      if (intBuffer[0] === 0xFF) {
        this.error = "Length block 0xFF is reserved by standard";
        return -1;
      } //endregion
      //region Check for length form type


      this.isIndefiniteForm = intBuffer[0] === 0x80; //endregion
      //region Stop working in case of indefinite length form

      if (this.isIndefiniteForm === true) {
        this.blockLength = 1;
        return inputOffset + this.blockLength;
      } //endregion
      //region Check is long form of length encoding using


      this.longFormUsed = !!(intBuffer[0] & 0x80); //endregion
      //region Stop working in case of short form of length value

      if (this.longFormUsed === false) {
        this.length = intBuffer[0];
        this.blockLength = 1;
        return inputOffset + this.blockLength;
      } //endregion
      //region Calculate length value in case of long form


      var count = intBuffer[0] & 0x7F;

      if (count > 8) // Too big length value
        {
          this.error = "Too big integer";
          return -1;
        }

      if (count + 1 > intBuffer.length) {
        this.error = "End of input reached before message was fully decoded";
        return -1;
      }

      var lengthBufferView = new Uint8Array(count);

      for (var i = 0; i < count; i++) {
        lengthBufferView[i] = intBuffer[i + 1];
      }

      if (lengthBufferView[count - 1] === 0x00) this.warnings.push("Needlessly long encoded length");
      this.length = utilFromBase(lengthBufferView, 8);
      if (this.longFormUsed && this.length <= 127) this.warnings.push("Unneccesary usage of long length form");
      this.blockLength = count + 1; //endregion

      return inputOffset + this.blockLength; // Return current offset in input buffer
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //region Initial variables
      var retBuf;
      var retView; //endregion

      if (this.length > 127) this.longFormUsed = true;

      if (this.isIndefiniteForm) {
        retBuf = new ArrayBuffer(1);

        if (sizeOnly === false) {
          retView = new Uint8Array(retBuf);
          retView[0] = 0x80;
        }

        return retBuf;
      }

      if (this.longFormUsed === true) {
        var encodedBuf = utilToBase(this.length, 8);

        if (encodedBuf.byteLength > 127) {
          this.error = "Too big length";
          return new ArrayBuffer(0);
        }

        retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
        if (sizeOnly === true) return retBuf;
        var encodedView = new Uint8Array(encodedBuf);
        retView = new Uint8Array(retBuf);
        retView[0] = encodedBuf.byteLength | 0x80;

        for (var i = 0; i < encodedBuf.byteLength; i++) {
          retView[i + 1] = encodedView[i];
        }

        return retBuf;
      }

      retBuf = new ArrayBuffer(1);

      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = this.length;
      }

      return retBuf;
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.blockName = this.constructor.blockName();
      object.isIndefiniteForm = this.isIndefiniteForm;
      object.longFormUsed = this.longFormUsed;
      object.length = this.length;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of value block class
  //**************************************************************************************


  class LocalValueBlock extends LocalBaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalValueBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "valueBlock";
    } //**********************************************************************************
    //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number}
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Throw an exception for a   which needs to be specified in extended classes
      throw TypeError("User need to make a specific   in a class which extends \"LocalValueBlock\""); //endregion
    } //**********************************************************************************
    //noinspection JSUnusedLocalSymbols

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //region Throw an exception for a   which needs to be specified in extended classes
      throw TypeError("User need to make a specific   in a class which extends \"LocalValueBlock\""); //endregion
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of basic ASN.1 block class
  //**************************************************************************************


  class BaseBlock extends LocalBaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "BaseBlock" class
     * @param {Object} [parameters={}]
     * @property {Object} [primitiveSchema]
     * @property {string} [name]
     * @property {boolean} [optional]
     * @param valueBlockType Type of value block
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var valueBlockType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LocalValueBlock;
      super(parameters);
      if ("name" in parameters) this.name = parameters.name;
      if ("optional" in parameters) this.optional = parameters.optional;
      if ("primitiveSchema" in parameters) this.primitiveSchema = parameters.primitiveSchema;
      this.idBlock = new LocalIdentificationBlock(parameters);
      this.lenBlock = new LocalLengthBlock(parameters);
      this.valueBlock = new valueBlockType(parameters);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "BaseBlock";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number}
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);

      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }

      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var retBuf;
      var idBlockBuf = this.idBlock.toBER(sizeOnly);
      var valueBlockSizeBuf = this.valueBlock.toBER(true);
      this.lenBlock.length = valueBlockSizeBuf.byteLength;
      var lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      retBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);
      var valueBlockBuf;
      if (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);
      retBuf = utilConcatBuf(retBuf, valueBlockBuf);

      if (this.lenBlock.isIndefiniteForm === true) {
        var indefBuf = new ArrayBuffer(2);

        if (sizeOnly === false) {
          var indefView = new Uint8Array(indefBuf);
          indefView[0] = 0x00;
          indefView[1] = 0x00;
        }

        retBuf = utilConcatBuf(retBuf, indefBuf);
      }

      return retBuf;
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.idBlock = this.idBlock.toJSON();
      object.lenBlock = this.lenBlock.toJSON();
      object.valueBlock = this.valueBlock.toJSON();
      if ("name" in this) object.name = this.name;
      if ("optional" in this) object.optional = this.optional;
      if ("primitiveSchema" in this) object.primitiveSchema = this.primitiveSchema.toJSON();
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of basic block for all PRIMITIVE types
  //**************************************************************************************


  class LocalPrimitiveValueBlock extends LocalValueBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalPrimitiveValueBlock" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueBeforeDecode]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters); //region Variables from "hexBlock" class

      if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);
      this.isHexOnly = getParametersValue(parameters, "isHexOnly", true); //endregion
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number}
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Basic check for parameters
      //noinspection JSCheck Signatures
      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion
      //region Getting Uint8Array from ArrayBuffer

      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion
      //region Initial checks

      if (intBuffer.length === 0) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      } //endregion
      //region Copy input buffer into internal buffer


      this.valueHex = new ArrayBuffer(intBuffer.length);
      var valueHexView = new Uint8Array(this.valueHex);

      for (var i = 0; i < intBuffer.length; i++) {
        valueHexView[i] = intBuffer[i];
      } //endregion


      this.blockLength = inputLength;
      return inputOffset + inputLength;
    } //**********************************************************************************
    //noinspection JSUnusedLocalSymbols

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.valueHex.slice(0);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "PrimitiveValueBlock";
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
      object.isHexOnly = this.isHexOnly;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************


  class Primitive extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "Primitive" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueHex]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalPrimitiveValueBlock);
      this.idBlock.isConstructed = false;
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "PRIMITIVE";
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of basic block for all CONSTRUCTED types
  //**************************************************************************************


  class LocalConstructedValueBlock extends LocalValueBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalConstructedValueBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.value = getParametersValue(parameters, "value", []);
      this.isIndefiniteForm = getParametersValue(parameters, "isIndefiniteForm", false);
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number}
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Store initial offset and length
      var initialOffset = inputOffset;
      var initialLength = inputLength; //endregion
      //region Basic check for parameters
      //noinspection JSCheck Signatures

      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion
      //region Getting Uint8Array from ArrayBuffer

      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion
      //region Initial checks

      if (intBuffer.length === 0) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      } //endregion
      //region Aux  


        checkLen(indefiniteLength, length) {
        if (indefiniteLength === true) return 1;
        return length;
      } //endregion


      var currentOffset = inputOffset;

      while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
        var returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);

        if (returnObject.offset === -1) {
          this.error = returnObject.result.error;
          this.warnings.concat(returnObject.result.warnings);
          return -1;
        }

        currentOffset = returnObject.offset;
        this.blockLength += returnObject.result.blockLength;
        inputLength -= returnObject.result.blockLength;
        this.value.push(returnObject.result);
        if (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;
      }

      if (this.isIndefiniteForm === true) {
        if (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push("No EndOfContent block encoded");
      } //region Copy "inputBuffer" to "valueBeforeDecode"


      this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength); //endregion

      return currentOffset;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var retBuf = new ArrayBuffer(0);

      for (var i = 0; i < this.value.length; i++) {
        var valueBuf = this.value[i].toBER(sizeOnly);
        retBuf = utilConcatBuf(retBuf, valueBuf);
      }

      return retBuf;
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "ConstructedValueBlock";
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.isIndefiniteForm = this.isIndefiniteForm;
      object.value = [];

      for (var i = 0; i < this.value.length; i++) {
        object.value.push(this.value[i].toJSON());
      }

      return object;
    } //**********************************************************************************


  } //**************************************************************************************


  class Constructed extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "Constructed" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalConstructedValueBlock);
      this.idBlock.isConstructed = true;
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "CONSTRUCTED";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number}
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);

      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }

      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 EndOfContent type class
  //**************************************************************************************


  class LocalEndOfContentValueBlock extends LocalValueBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalEndOfContentValueBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
    } //**********************************************************************************
    //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number}
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region There is no "value block" for EndOfContent type and we need to return the same offset
      return inputOffset; //endregion
    } //**********************************************************************************
    //noinspection JSUnusedLocalSymbols

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return new ArrayBuffer(0);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "EndOfContentValueBlock";
    } //**********************************************************************************


  } //**************************************************************************************


  class EndOfContent extends BaseBlock {
    //**********************************************************************************
    constructor() {
      var paramaters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(paramaters, LocalEndOfContentValueBlock);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 0; // EndOfContent
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "EndOfContent";
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 Boolean type class
  //**************************************************************************************


  class LocalBooleanValueBlock extends LocalValueBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalBooleanValueBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.value = getParametersValue(parameters, "value", false);
      this.isHexOnly = getParametersValue(parameters, "isHexOnly", false);
      if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);else {
        this.valueHex = new ArrayBuffer(1);

        if (this.value === true) {
          var view = new Uint8Array(this.valueHex);
          view[0] = 0xFF;
        }
      }
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Basic check for parameters
      //noinspection JSCheck Signatures
      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion
      //region Getting Uint8Array from ArrayBuffer

      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion

      if (inputLength > 1) this.warnings.push("Boolean value encoded in more then 1 octet");
      this.isHexOnly = true; //region Copy input buffer to internal array

      this.valueHex = new ArrayBuffer(intBuffer.length);
      var view = new Uint8Array(this.valueHex);

      for (var i = 0; i < intBuffer.length; i++) {
        view[i] = intBuffer[i];
      } //endregion


      if (utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;
      this.blockLength = inputLength;
      return inputOffset + inputLength;
    } //**********************************************************************************
    //noinspection JSUnusedLocalSymbols

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.valueHex;
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "BooleanValueBlock";
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.value = this.value;
      object.isHexOnly = this.isHexOnly;
      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
      return object;
    } //**********************************************************************************


  } //**************************************************************************************


  class Boolean extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "Boolean" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalBooleanValueBlock);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 1; // Boolean
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Boolean";
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 Sequence and Set type classes
  //**************************************************************************************


  class Sequence extends Constructed {
    //**********************************************************************************

    /**
     * Constructor for "Sequence" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 16; // Sequence
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Sequence";
    } //**********************************************************************************


  } //**************************************************************************************


  class Set extends Constructed {
    //**********************************************************************************

    /**
     * Constructor for "Set" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 17; // Set
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Set";
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 Null type class
  //**************************************************************************************


  class Null extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "Null" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalBaseBlock); // We will not have a call to "Null value block" because of specified "fromBER" and "toBER"  s

      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 5; // Null
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Null";
    } //**********************************************************************************
    //noinspection JSUnusedLocalSymbols

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      if (this.lenBlock.length > 0) this.warnings.push("Non-zero length of value block for Null type");
      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      this.blockLength += inputLength;

      if (inputOffset + inputLength > inputBuffer.byteLength) {
        this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return -1;
      }

      return inputOffset + inputLength;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var retBuf = new ArrayBuffer(2);
      if (sizeOnly === true) return retBuf;
      var retView = new Uint8Array(retBuf);
      retView[0] = 0x05;
      retView[1] = 0x00;
      return retBuf;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 OctetString type class
  //**************************************************************************************


  class LocalOctetStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock) {
    //**********************************************************************************

    /**
     * Constructor for "LocalOctetStringValueBlock" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueHex]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.isConstructed = getParametersValue(parameters, "isConstructed", false);
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = 0;

      if (this.isConstructed === true) {
        this.isHexOnly = false;
        resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) return resultOffset;

        for (var i = 0; i < this.value.length; i++) {
          var currentBlockName = this.value[i].constructor.blockName();

          if (currentBlockName === EndOfContent.blockName()) {
            if (this.isIndefiniteForm === true) break;else {
              this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
              return -1;
            }
          }

          if (currentBlockName !== OctetString.blockName()) {
            this.error = "OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
      } else {
        this.isHexOnly = true;
        resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        this.blockLength = inputLength;
      }

      return resultOffset;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);
      var retBuf = new ArrayBuffer(this.valueHex.byteLength);
      if (sizeOnly === true) return retBuf;
      if (this.valueHex.byteLength === 0) return retBuf;
      retBuf = this.valueHex.slice(0);
      return retBuf;
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "OctetStringValueBlock";
    } //**********************************************************************************


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.isConstructed = this.isConstructed;
      object.isHexOnly = this.isHexOnly;
      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
      return object;
    } //**********************************************************************************


  } //**************************************************************************************


  class OctetString extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "OctetString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalOctetStringValueBlock);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 4; // OctetString
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      this.valueBlock.isConstructed = this.idBlock.isConstructed;
      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm; //region Ability to encode empty OCTET STRING

      if (inputLength === 0) {
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        return inputOffset;
      } //endregion


      return super.fromBER(inputBuffer, inputOffset, inputLength);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "OctetString";
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Checking that two OCTETSTRINGs are equal
     * @param {OctetString} octetString
     */


    isEqual(octetString) {
      //region Check input type
      if (octetString instanceof OctetString === false) return false; //endregion
      //region Compare two JSON strings

      if (JSON.stringify(this) !== JSON.stringify(octetString)) return false; //endregion

      return true;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 BitString type class
  //**************************************************************************************


  class LocalBitStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock) {
    //**********************************************************************************

    /**
     * Constructor for "LocalBitStringValueBlock" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueHex]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.unusedBits = getParametersValue(parameters, "unusedBits", 0);
      this.isConstructed = getParametersValue(parameters, "isConstructed", false);
      this.blockLength = this.valueHex.byteLength;
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Ability to decode zero-length BitString value
      if (inputLength === 0) return inputOffset; //endregion

      var resultOffset = -1; //region If the BISTRING supposed to be a constructed value

      if (this.isConstructed === true) {
        resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) return resultOffset;

        for (var i = 0; i < this.value.length; i++) {
          var currentBlockName = this.value[i].constructor.blockName();

          if (currentBlockName === EndOfContent.blockName()) {
            if (this.isIndefiniteForm === true) break;else {
              this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
              return -1;
            }
          }

          if (currentBlockName !== BitString.blockName()) {
            this.error = "BIT STRING may consists of BIT STRINGs only";
            return -1;
          }

          if (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {
            this.error = "Usign of \"unused bits\" inside constructive BIT STRING allowed for least one only";
            return -1;
          }

          this.unusedBits = this.value[i].valueBlock.unusedBits;

          if (this.unusedBits > 7) {
            this.error = "Unused bits for BitString must be in range 0-7";
            return -1;
          }
        }

        return resultOffset;
      } //endregion
      //region If the BitString supposed to be a primitive value
      //region Basic check for parameters
      //noinspection JSCheck Signatures


      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion

      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
      this.unusedBits = intBuffer[0];

      if (this.unusedBits > 7) {
        this.error = "Unused bits for BitString must be in range 0-7";
        return -1;
      } //region Copy input buffer to internal buffer


      this.valueHex = new ArrayBuffer(intBuffer.length - 1);
      var view = new Uint8Array(this.valueHex);

      for (var _i10 = 0; _i10 < inputLength - 1; _i10++) {
        view[_i10] = intBuffer[_i10 + 1];
      } //endregion


      this.blockLength = intBuffer.length;
      return inputOffset + inputLength; //endregion
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);
      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);
      if (this.valueHex.byteLength === 0) return new ArrayBuffer(0);
      var curView = new Uint8Array(this.valueHex);
      var retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
      var retView = new Uint8Array(retBuf);
      retView[0] = this.unusedBits;

      for (var i = 0; i < this.valueHex.byteLength; i++) {
        retView[i + 1] = curView[i];
      }

      return retBuf;
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "BitStringValueBlock";
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.unusedBits = this.unusedBits;
      object.isConstructed = this.isConstructed;
      object.isHexOnly = this.isHexOnly;
      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
      return object;
    } //**********************************************************************************


  } //**************************************************************************************


  class BitString extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "BitString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalBitStringValueBlock);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 3; // BitString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "BitString";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      //region Ability to encode empty BitString
      if (inputLength === 0) return inputOffset; //endregion

      this.valueBlock.isConstructed = this.idBlock.isConstructed;
      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
      return super.fromBER(inputBuffer, inputOffset, inputLength);
    } //**********************************************************************************

    /**
     * Checking that two BITSTRINGs are equal
     * @param {BitString} bitString
     */


    isEqual(bitString) {
      //region Check input type
      if (bitString instanceof BitString === false) return false; //endregion
      //region Compare two JSON strings

      if (JSON.stringify(this) !== JSON.stringify(bitString)) return false; //endregion

      return true;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 Integer type class
  //**************************************************************************************

  /**
   * @extends LocalValueBlock
   */


  class LocalIntegerValueBlock extends LocalHexBlock(LocalValueBlock) {
    //**********************************************************************************

    /**
     * Constructor for "LocalIntegerValueBlock" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueHex]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      if ("value" in parameters) this.valueDec = parameters.value;
    } //**********************************************************************************

    /**
     * Setter for "valueHex"
     * @param {ArrayBuffer} _value
     */


    set valueHex(_value) {
      this._valueHex = _value.slice(0);

      if (_value.byteLength >= 4) {
        this.warnings.push("Too big Integer for decoding, hex only");
        this.isHexOnly = true;
        this._valueDec = 0;
      } else {
        this.isHexOnly = false;
        if (_value.byteLength > 0) this._valueDec = utilDecodeTC.call(this);
      }
    } //**********************************************************************************

    /**
     * Getter for "valueHex"
     * @returns {ArrayBuffer}
     */


    get valueHex() {
      return this._valueHex;
    } //**********************************************************************************

    /**
     * Getter for "valueDec"
     * @param {number} _value
     */


    set valueDec(_value) {
      this._valueDec = _value;
      this.isHexOnly = false;
      this._valueHex = utilEncodeTC(_value);
    } //**********************************************************************************

    /**
     * Getter for "valueDec"
     * @returns {number}
     */


    get valueDec() {
      return this._valueDec;
    } //**********************************************************************************

    /**
     * Base   for converting block from DER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array
     * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @param {number} [expectedLength=0] Expected length of converted "valueHex" buffer
     * @returns {number} Offset after least decoded byte
     */


    fromDER(inputBuffer, inputOffset, inputLength) {
      var expectedLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var offset = this.fromBER(inputBuffer, inputOffset, inputLength);
      if (offset === -1) return offset;
      var view = new Uint8Array(this._valueHex);

      if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {
        var updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
        var updatedView = new Uint8Array(updatedValueHex);
        updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));
        this._valueHex = updatedValueHex.slice(0);
      } else {
        if (expectedLength !== 0) {
          if (this._valueHex.byteLength < expectedLength) {
            if (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;

            var _updatedValueHex = new ArrayBuffer(expectedLength);

            var _updatedView = new Uint8Array(_updatedValueHex);

            _updatedView.set(view, expectedLength - this._valueHex.byteLength);

            this._valueHex = _updatedValueHex.slice(0);
          }
        }
      }

      return offset;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toDER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var view = new Uint8Array(this._valueHex);

      switch (true) {
        case (view[0] & 0x80) !== 0:
          {
            var updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);
            var updatedView = new Uint8Array(updatedValueHex);
            updatedView[0] = 0x00;
            updatedView.set(view, 1);
            this._valueHex = updatedValueHex.slice(0);
          }
          break;

        case view[0] === 0x00 && (view[1] & 0x80) === 0:
          {
            var _updatedValueHex2 = new ArrayBuffer(this._valueHex.byteLength - 1);

            var _updatedView2 = new Uint8Array(_updatedValueHex2);

            _updatedView2.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

            this._valueHex = _updatedValueHex2.slice(0);
          }
          break;

        default:
      }

      return this.toBER(sizeOnly);
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1) return resultOffset;
      this.blockLength = inputLength;
      return inputOffset + inputLength;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //noinspection JSCheck Signatures
      return this.valueHex.slice(0);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "IntegerValueBlock";
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.valueDec = this.valueDec;
      return object;
    } //**********************************************************************************

    /**
     * Convert current value to decimal string representation
     */


    toString() {
      //region Aux  s
        viewAdd(first, second) {
        //region Initial variables
        var c = new Uint8Array([0]);
        var firstView = new Uint8Array(first);
        var secondView = new Uint8Array(second);
        var firstViewCopy = firstView.slice(0);
        var firstViewCopyLength = firstViewCopy.length - 1;
        var secondViewCopy = secondView.slice(0);
        var secondViewCopyLength = secondViewCopy.length - 1;
        var value = 0;
        var max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
        var counter = 0; //endregion

        for (var i = max; i >= 0; i--, counter++) {
          switch (true) {
            case counter < secondViewCopy.length:
              value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
              break;

            default:
              value = firstViewCopy[firstViewCopyLength - counter] + c[0];
          }

          c[0] = value / 10;

          switch (true) {
            case counter >= firstViewCopy.length:
              firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
              break;

            default:
              firstViewCopy[firstViewCopyLength - counter] = value % 10;
          }
        }

        if (c[0] > 0) firstViewCopy = utilConcatView(c, firstViewCopy);
        return firstViewCopy.slice(0);
      }

        power2(n) {
        if (n >= powers2.length) {
          for (var p = powers2.length; p <= n; p++) {
            var c = new Uint8Array([0]);

            var _digits = powers2[p - 1].slice(0);

            for (var i = _digits.length - 1; i >= 0; i--) {
              var newValue = new Uint8Array([(_digits[i] << 1) + c[0]]);
              c[0] = newValue[0] / 10;
              _digits[i] = newValue[0] % 10;
            }

            if (c[0] > 0) _digits = utilConcatView(c, _digits);
            powers2.push(_digits);
          }
        }

        return powers2[n];
      }

        viewSub(first, second) {
        //region Initial variables
        var b = 0;
        var firstView = new Uint8Array(first);
        var secondView = new Uint8Array(second);
        var firstViewCopy = firstView.slice(0);
        var firstViewCopyLength = firstViewCopy.length - 1;
        var secondViewCopy = secondView.slice(0);
        var secondViewCopyLength = secondViewCopy.length - 1;
        var value;
        var counter = 0; //endregion

        for (var i = secondViewCopyLength; i >= 0; i--, counter++) {
          value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;

          switch (true) {
            case value < 0:
              b = 1;
              firstViewCopy[firstViewCopyLength - counter] = value + 10;
              break;

            default:
              b = 0;
              firstViewCopy[firstViewCopyLength - counter] = value;
          }
        }

        if (b > 0) {
          for (var _i11 = firstViewCopyLength - secondViewCopyLength + 1; _i11 >= 0; _i11--, counter++) {
            value = firstViewCopy[firstViewCopyLength - counter] - b;

            if (value < 0) {
              b = 1;
              firstViewCopy[firstViewCopyLength - counter] = value + 10;
            } else {
              b = 0;
              firstViewCopy[firstViewCopyLength - counter] = value;
              break;
            }
          }
        }

        return firstViewCopy.slice();
      } //endregion
      //region Initial variables


      var firstBit = this._valueHex.byteLength * 8 - 1;
      var digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);
      var bitNumber = 0;
      var currentByte;
      var asn1View = new Uint8Array(this._valueHex);
      var result = "";
      var flag = false; //endregion
      //region Calculate number

      for (var byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {
        currentByte = asn1View[byteNumber];

        for (var i = 0; i < 8; i++) {
          if ((currentByte & 1) === 1) {
            switch (bitNumber) {
              case firstBit:
                digits = viewSub(power2(bitNumber), digits);
                result = "-";
                break;

              default:
                digits = viewAdd(digits, power2(bitNumber));
            }
          }

          bitNumber++;
          currentByte >>= 1;
        }
      } //endregion
      //region Print number


      for (var _i12 = 0; _i12 < digits.length; _i12++) {
        if (digits[_i12]) flag = true;
        if (flag) result += digitsString.charAt(digits[_i12]);
      }

      if (flag === false) result += digitsString.charAt(0); //endregion

      return result;
    } //**********************************************************************************


  } //**************************************************************************************


  class Integer extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "Integer" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalIntegerValueBlock);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 2; // Integer
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Integer";
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Compare two Integer object, or Integer and ArrayBuffer objects
     * @param {!Integer|ArrayBuffer} otherValue
     * @returns {boolean}
     */


    isEqual(otherValue) {
      if (otherValue instanceof Integer) {
        if (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers
          return isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);
        if (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;
        return false;
      }

      if (otherValue instanceof ArrayBuffer) return isEqualBuffer(this.valueBlock.valueHex, otherValue);
      return false;
    } //**********************************************************************************

    /**
     * Convert current Integer value from BER into DER format
     * @returns {Integer}
     */


    convertToDER() {
      var integer = new Integer({
        valueHex: this.valueBlock.valueHex
      });
      integer.valueBlock.toDER();
      return integer;
    } //**********************************************************************************

    /**
     * Convert current Integer value from DER to BER format
     * @returns {Integer}
     */


    convertFromDER() {
      var expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;
      var integer = new Integer({
        valueHex: this.valueBlock.valueHex
      });
      integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);
      return integer;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 Enumerated type class
  //**************************************************************************************


  class Enumerated extends Integer {
    //**********************************************************************************

    /**
     * Constructor for "Enumerated" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 10; // Enumerated
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Enumerated";
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of ASN.1 ObjectIdentifier type class
  //**************************************************************************************


  class LocalSidValueBlock extends LocalHexBlock(LocalBaseBlock) {
    //**********************************************************************************

    /**
     * Constructor for "LocalSidValueBlock" class
     * @param {Object} [parameters={}]
     * @property {number} [valueDec]
     * @property {boolean} [isFirstSid]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.valueDec = getParametersValue(parameters, "valueDec", -1);
      this.isFirstSid = getParametersValue(parameters, "isFirstSid", false);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "sidBlock";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      if (inputLength === 0) return inputOffset; //region Basic check for parameters
      //noinspection JSCheck Signatures

      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion

      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
      this.valueHex = new ArrayBuffer(inputLength);
      var view = new Uint8Array(this.valueHex);

      for (var i = 0; i < inputLength; i++) {
        view[i] = intBuffer[i] & 0x7F;
        this.blockLength++;
        if ((intBuffer[i] & 0x80) === 0x00) break;
      } //region Ajust size of valueHex buffer


      var tempValueHex = new ArrayBuffer(this.blockLength);
      var tempView = new Uint8Array(tempValueHex);

      for (var _i13 = 0; _i13 < this.blockLength; _i13++) {
        tempView[_i13] = view[_i13];
      } //noinspection JSCheck Signatures


      this.valueHex = tempValueHex.slice(0);
      view = new Uint8Array(this.valueHex); //endregion

      if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
        this.error = "End of input reached before message was fully decoded";
        return -1;
      }

      if (view[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
      if (this.blockLength <= 8) this.valueDec = utilFromBase(view, 7);else {
        this.isHexOnly = true;
        this.warnings.push("Too big SID for decoding, hex only");
      }
      return inputOffset + this.blockLength;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //region Initial variables
      var retBuf;
      var retView; //endregion

      if (this.isHexOnly) {
        if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);
        var curView = new Uint8Array(this.valueHex);
        retBuf = new ArrayBuffer(this.blockLength);
        retView = new Uint8Array(retBuf);

        for (var i = 0; i < this.blockLength - 1; i++) {
          retView[i] = curView[i] | 0x80;
        }

        retView[this.blockLength - 1] = curView[this.blockLength - 1];
        return retBuf;
      }

      var encodedBuf = utilToBase(this.valueDec, 7);

      if (encodedBuf.byteLength === 0) {
        this.error = "Error during encoding SID value";
        return new ArrayBuffer(0);
      }

      retBuf = new ArrayBuffer(encodedBuf.byteLength);

      if (sizeOnly === false) {
        var encodedView = new Uint8Array(encodedBuf);
        retView = new Uint8Array(retBuf);

        for (var _i14 = 0; _i14 < encodedBuf.byteLength - 1; _i14++) {
          retView[_i14] = encodedView[_i14] | 0x80;
        }

        retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
      }

      return retBuf;
    } //**********************************************************************************

    /**
     * Create string representation of current SID block
     * @returns {string}
     */


    toString() {
      var result = "";
      if (this.isHexOnly === true) result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);else {
        if (this.isFirstSid) {
          var sidValue = this.valueDec;
          if (this.valueDec <= 39) result = "0.";else {
            if (this.valueDec <= 79) {
              result = "1.";
              sidValue -= 40;
            } else {
              result = "2.";
              sidValue -= 80;
            }
          }
          result += sidValue.toString();
        } else result = this.valueDec.toString();
      }
      return result;
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.valueDec = this.valueDec;
      object.isFirstSid = this.isFirstSid;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************


  class LocalObjectIdentifierValueBlock extends LocalValueBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalObjectIdentifierValueBlock" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueHex]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.fromString(getParametersValue(parameters, "value", ""));
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = inputOffset;

      while (inputLength > 0) {
        var sidBlock = new LocalSidValueBlock();
        resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);

        if (resultOffset === -1) {
          this.blockLength = 0;
          this.error = sidBlock.error;
          return resultOffset;
        }

        if (this.value.length === 0) sidBlock.isFirstSid = true;
        this.blockLength += sidBlock.blockLength;
        inputLength -= sidBlock.blockLength;
        this.value.push(sidBlock);
      }

      return resultOffset;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var retBuf = new ArrayBuffer(0);

      for (var i = 0; i < this.value.length; i++) {
        var valueBuf = this.value[i].toBER(sizeOnly);

        if (valueBuf.byteLength === 0) {
          this.error = this.value[i].error;
          return new ArrayBuffer(0);
        }

        retBuf = utilConcatBuf(retBuf, valueBuf);
      }

      return retBuf;
    } //**********************************************************************************

    /**
     * Create "LocalObjectIdentifierValueBlock" class from string
     * @param {string} string Input string to convert from
     * @returns {boolean}
     */


    fromString(string) {
      this.value = []; // Clear existing SID values

      var pos1 = 0;
      var pos2 = 0;
      var sid = "";
      var flag = false;

      do {
        pos2 = string.indexOf(".", pos1);
        if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);
        pos1 = pos2 + 1;

        if (flag) {
          var sidBlock = this.value[0];
          var plus = 0;

          switch (sidBlock.valueDec) {
            case 0:
              break;

            case 1:
              plus = 40;
              break;

            case 2:
              plus = 80;
              break;

            default:
              this.value = []; // clear SID array

              return false;
            // ???
          }

          var parsedSID = parseInt(sid, 10);
          if (isNaN(parsedSID)) return true;
          sidBlock.valueDec = parsedSID + plus;
          flag = false;
        } else {
          var _sidBlock = new LocalSidValueBlock();

          _sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(_sidBlock.valueDec)) return true;

          if (this.value.length === 0) {
            _sidBlock.isFirstSid = true;
            flag = true;
          }

          this.value.push(_sidBlock);
        }
      } while (pos2 !== -1);

      return true;
    } //**********************************************************************************

    /**
     * Converts "LocalObjectIdentifierValueBlock" class to string
     * @returns {string}
     */


    toString() {
      var result = "";
      var isHexOnly = false;

      for (var i = 0; i < this.value.length; i++) {
        isHexOnly = this.value[i].isHexOnly;
        var sidStr = this.value[i].toString();
        if (i !== 0) result = "".concat(result, ".");

        if (isHexOnly) {
          sidStr = "{".concat(sidStr, "}");
          if (this.value[i].isFirstSid) result = "2.{".concat(sidStr, " - 80}");else result += sidStr;
        } else result += sidStr;
      }

      return result;
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "ObjectIdentifierValueBlock";
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.value = this.toString();
      object.sidArray = [];

      for (var i = 0; i < this.value.length; i++) {
        object.sidArray.push(this.value[i].toJSON());
      }

      return object;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends BaseBlock
   */


  class ObjectIdentifier extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "ObjectIdentifier" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueHex]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalObjectIdentifierValueBlock);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "ObjectIdentifier";
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of all string's classes
  //**************************************************************************************


  class LocalUtf8StringValueBlock extends LocalHexBlock(LocalBaseBlock) {
    //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Constructor for "LocalUtf8StringValueBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.isHexOnly = true;
      this.value = ""; // String representation of decoded ArrayBuffer
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Utf8StringValueBlock";
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.value = this.value;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends BaseBlock
   */


  class Utf8String extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "Utf8String" class
     * @param {Object} [parameters={}]
     * @property {ArrayBuffer} [valueHex]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalUtf8StringValueBlock);
      if ("value" in parameters) this.fromString(parameters.value);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 12; // Utf8String
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Utf8String";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);

      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }

      this.fromBuffer(this.valueBlock.valueHex);
      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    } //**********************************************************************************

    /**
     *   converting ArrayBuffer into ASN.1 internal string
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     */


    fromBuffer(inputBuffer) {
      this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));

      try {
        //noinspection JSDeprecatedSymbols
        this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));
      } catch (ex) {
        this.warnings.push("Error during \"decodeURIComponent\": ".concat(ex, ", using raw string"));
      }
    } //**********************************************************************************

    /**
     *   converting JavaScript string into ASN.1 internal class
     * @param {!string} inputString ASN.1 BER encoded array
     */


    fromString(inputString) {
      //noinspection JSDeprecatedSymbols
      var str = unescape(encodeURIComponent(inputString));
      var strLen = str.length;
      this.valueBlock.valueHex = new ArrayBuffer(strLen);
      var view = new Uint8Array(this.valueBlock.valueHex);

      for (var i = 0; i < strLen; i++) {
        view[i] = str.charCodeAt(i);
      }

      this.valueBlock.value = inputString;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalBaseBlock
   * @extends LocalHexBlock
   */


  class LocalBmpStringValueBlock extends LocalHexBlock(LocalBaseBlock) {
    //**********************************************************************************

    /**
     * Constructor for "LocalBmpStringValueBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.isHexOnly = true;
      this.value = "";
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "BmpStringValueBlock";
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.value = this.value;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends BaseBlock
   */


  class BmpString extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "BmpString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalBmpStringValueBlock);
      if ("value" in parameters) this.fromString(parameters.value);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 30; // BmpString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "BmpString";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);

      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }

      this.fromBuffer(this.valueBlock.valueHex);
      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    } //**********************************************************************************

    /**
     *   converting ArrayBuffer into ASN.1 internal string
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     */


    fromBuffer(inputBuffer) {
      //noinspection JSCheck Signatures
      var copyBuffer = inputBuffer.slice(0);
      var valueView = new Uint8Array(copyBuffer);

      for (var i = 0; i < valueView.length; i += 2) {
        var temp = valueView[i];
        valueView[i] = valueView[i + 1];
        valueView[i + 1] = temp;
      }

      this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));
    } //**********************************************************************************

    /**
     *   converting JavaScript string into ASN.1 internal class
     * @param {!string} inputString ASN.1 BER encoded array
     */


    fromString(inputString) {
      var strLength = inputString.length;
      this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);
      var valueHexView = new Uint8Array(this.valueBlock.valueHex);

      for (var i = 0; i < strLength; i++) {
        var codeBuf = utilToBase(inputString.charCodeAt(i), 8);
        var codeView = new Uint8Array(codeBuf);
        if (codeView.length > 2) continue;
        var dif = 2 - codeView.length;

        for (var j = codeView.length - 1; j >= 0; j--) {
          valueHexView[i * 2 + j + dif] = codeView[j];
        }
      }

      this.valueBlock.value = inputString;
    } //**********************************************************************************


  } //**************************************************************************************


  class LocalUniversalStringValueBlock extends LocalHexBlock(LocalBaseBlock) {
    //**********************************************************************************

    /**
     * Constructor for "LocalUniversalStringValueBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.isHexOnly = true;
      this.value = "";
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "UniversalStringValueBlock";
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.value = this.value;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends BaseBlock
   */


  class UniversalString extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "UniversalString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalUniversalStringValueBlock);
      if ("value" in parameters) this.fromString(parameters.value);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 28; // UniversalString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "UniversalString";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);

      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }

      this.fromBuffer(this.valueBlock.valueHex);
      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    } //**********************************************************************************

    /**
     *   converting ArrayBuffer into ASN.1 internal string
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     */


    fromBuffer(inputBuffer) {
      //noinspection JSCheck Signatures
      var copyBuffer = inputBuffer.slice(0);
      var valueView = new Uint8Array(copyBuffer);

      for (var i = 0; i < valueView.length; i += 4) {
        valueView[i] = valueView[i + 3];
        valueView[i + 1] = valueView[i + 2];
        valueView[i + 2] = 0x00;
        valueView[i + 3] = 0x00;
      }

      this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
    } //**********************************************************************************

    /**
     *   converting JavaScript string into ASN.1 internal class
     * @param {!string} inputString ASN.1 BER encoded array
     */


    fromString(inputString) {
      var strLength = inputString.length;
      this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);
      var valueHexView = new Uint8Array(this.valueBlock.valueHex);

      for (var i = 0; i < strLength; i++) {
        var codeBuf = utilToBase(inputString.charCodeAt(i), 8);
        var codeView = new Uint8Array(codeBuf);
        if (codeView.length > 4) continue;
        var dif = 4 - codeView.length;

        for (var j = codeView.length - 1; j >= 0; j--) {
          valueHexView[i * 4 + j + dif] = codeView[j];
        }
      }

      this.valueBlock.value = inputString;
    } //**********************************************************************************


  } //**************************************************************************************


  class LocalSimpleStringValueBlock extends LocalHexBlock(LocalBaseBlock) {
    //**********************************************************************************

    /**
     * Constructor for "LocalSimpleStringValueBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.value = "";
      this.isHexOnly = true;
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "SimpleStringValueBlock";
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.value = this.value;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends BaseBlock
   */


  class LocalSimpleStringBlock extends BaseBlock {
    //**********************************************************************************

    /**
     * Constructor for "LocalSimpleStringBlock" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters, LocalSimpleStringValueBlock);
      if ("value" in parameters) this.fromString(parameters.value);
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "SIMPLESTRING";
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);

      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }

      this.fromBuffer(this.valueBlock.valueHex);
      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    } //**********************************************************************************

    /**
     *   converting ArrayBuffer into ASN.1 internal string
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     */


    fromBuffer(inputBuffer) {
      this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));
    } //**********************************************************************************

    /**
     *   converting JavaScript string into ASN.1 internal class
     * @param {!string} inputString ASN.1 BER encoded array
     */


    fromString(inputString) {
      var strLen = inputString.length;
      this.valueBlock.valueHex = new ArrayBuffer(strLen);
      var view = new Uint8Array(this.valueBlock.valueHex);

      for (var i = 0; i < strLen; i++) {
        view[i] = inputString.charCodeAt(i);
      }

      this.valueBlock.value = inputString;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class NumericString extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "NumericString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 18; // NumericString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "NumericString";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class PrintableString extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "PrintableString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 19; // PrintableString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "PrintableString";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class TeletexString extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "TeletexString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 20; // TeletexString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "TeletexString";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class VideotexString extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "VideotexString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 21; // VideotexString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "VideotexString";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class IA5String extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "IA5String" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 22; // IA5String
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "IA5String";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class GraphicString extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "GraphicString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 25; // GraphicString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "GraphicString";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class VisibleString extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "VisibleString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 26; // VisibleString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "VisibleString";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class GeneralString extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "GeneralString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 27; // GeneralString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "GeneralString";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends LocalSimpleStringBlock
   */


  class CharacterString extends LocalSimpleStringBlock {
    //**********************************************************************************

    /**
     * Constructor for "CharacterString" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 29; // CharacterString
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "CharacterString";
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of all date and time classes
  //**************************************************************************************

  /**
   * @extends VisibleString
   */


  class UTCTime extends VisibleString {
    //**********************************************************************************

    /**
     * Constructor for "UTCTime" class
     * @param {Object} [parameters={}]
     * @property {string} [value] String representatio of the date
     * @property {Date} [valueDate] JavaScript "Date" object
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.year = 0;
      this.month = 0;
      this.day = 0;
      this.hour = 0;
      this.minute = 0;
      this.second = 0; //region Create UTCTime from ASN.1 UTC string value

      if ("value" in parameters) {
        this.fromString(parameters.value);
        this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
        var view = new Uint8Array(this.valueBlock.valueHex);

        for (var i = 0; i < parameters.value.length; i++) {
          view[i] = parameters.value.charCodeAt(i);
        }
      } //endregion
      //region Create GeneralizedTime from JavaScript Date type


      if ("valueDate" in parameters) {
        this.fromDate(parameters.valueDate);
        this.valueBlock.valueHex = this.toBuffer();
      } //endregion


      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 23; // UTCTime
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);

      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }

      this.fromBuffer(this.valueBlock.valueHex);
      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    } //**********************************************************************************

    /**
     *   converting ArrayBuffer into ASN.1 internal string
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     */


    fromBuffer(inputBuffer) {
      this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
    } //**********************************************************************************

    /**
     *   converting ASN.1 internal string into ArrayBuffer
     * @returns {ArrayBuffer}
     */


    toBuffer() {
      var str = this.toString();
      var buffer = new ArrayBuffer(str.length);
      var view = new Uint8Array(buffer);

      for (var i = 0; i < str.length; i++) {
        view[i] = str.charCodeAt(i);
      }

      return buffer;
    } //**********************************************************************************

    /**
     *   converting "Date" object into ASN.1 internal string
     * @param {!Date} inputDate JavaScript "Date" object
     */


    fromDate(inputDate) {
      this.year = inputDate.getUTCFullYear();
      this.month = inputDate.getUTCMonth() + 1;
      this.day = inputDate.getUTCDate();
      this.hour = inputDate.getUTCHours();
      this.minute = inputDate.getUTCMinutes();
      this.second = inputDate.getUTCSeconds();
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     *   converting ASN.1 internal string into "Date" object
     * @returns {Date}
     */


    toDate() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
    } //**********************************************************************************

    /**
     *   converting JavaScript string into ASN.1 internal class
     * @param {!string} inputString ASN.1 BER encoded array
     */


    fromString(inputString) {
      //region Parse input string
      var parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
      var parserArray = parser.exec(inputString);

      if (parserArray === null) {
        this.error = "Wrong input string for convertion";
        return;
      } //endregion
      //region Store parsed values


      var year = parseInt(parserArray[1], 10);
      if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;
      this.month = parseInt(parserArray[2], 10);
      this.day = parseInt(parserArray[3], 10);
      this.hour = parseInt(parserArray[4], 10);
      this.minute = parseInt(parserArray[5], 10);
      this.second = parseInt(parserArray[6], 10); //endregion
    } //**********************************************************************************

    /**
     *   converting ASN.1 internal class into JavaScript string
     * @returns {string}
     */


    toString() {
      var outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "UTCTime";
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.year = this.year;
      object.month = this.month;
      object.day = this.day;
      object.hour = this.hour;
      object.minute = this.minute;
      object.second = this.second;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends VisibleString
   */


  class GeneralizedTime extends VisibleString {
    //**********************************************************************************

    /**
     * Constructor for "GeneralizedTime" class
     * @param {Object} [parameters={}]
     * @property {string} [value] String representatio of the date
     * @property {Date} [valueDate] JavaScript "Date" object
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.year = 0;
      this.month = 0;
      this.day = 0;
      this.hour = 0;
      this.minute = 0;
      this.second = 0;
      this.millisecond = 0; //region Create UTCTime from ASN.1 UTC string value

      if ("value" in parameters) {
        this.fromString(parameters.value);
        this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
        var view = new Uint8Array(this.valueBlock.valueHex);

        for (var i = 0; i < parameters.value.length; i++) {
          view[i] = parameters.value.charCodeAt(i);
        }
      } //endregion
      //region Create GeneralizedTime from JavaScript Date type


      if ("valueDate" in parameters) {
        this.fromDate(parameters.valueDate);
        this.valueBlock.valueHex = this.toBuffer();
      } //endregion


      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 24; // GeneralizedTime
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);

      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }

      this.fromBuffer(this.valueBlock.valueHex);
      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    } //**********************************************************************************

    /**
     *   converting ArrayBuffer into ASN.1 internal string
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     */


    fromBuffer(inputBuffer) {
      this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
    } //**********************************************************************************

    /**
     *   converting ASN.1 internal string into ArrayBuffer
     * @returns {ArrayBuffer}
     */


    toBuffer() {
      var str = this.toString();
      var buffer = new ArrayBuffer(str.length);
      var view = new Uint8Array(buffer);

      for (var i = 0; i < str.length; i++) {
        view[i] = str.charCodeAt(i);
      }

      return buffer;
    } //**********************************************************************************

    /**
     *   converting "Date" object into ASN.1 internal string
     * @param {!Date} inputDate JavaScript "Date" object
     */


    fromDate(inputDate) {
      this.year = inputDate.getUTCFullYear();
      this.month = inputDate.getUTCMonth() + 1;
      this.day = inputDate.getUTCDate();
      this.hour = inputDate.getUTCHours();
      this.minute = inputDate.getUTCMinutes();
      this.second = inputDate.getUTCSeconds();
      this.millisecond = inputDate.getUTCMilliseconds();
    } //**********************************************************************************
    //noinspection JSUnusedGlobalSymbols

    /**
     *   converting ASN.1 internal string into "Date" object
     * @returns {Date}
     */


    toDate() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
    } //**********************************************************************************

    /**
     *   converting JavaScript string into ASN.1 internal class
     * @param {!string} inputString ASN.1 BER encoded array
     */


    fromString(inputString) {
      //region Initial variables
      var isUTC = false;
      var timeString = "";
      var dateTimeString = "";
      var fractionPart = 0;
      var parser;
      var hourDifference = 0;
      var minuteDifference = 0; //endregion
      //region Convert as UTC time

      if (inputString[inputString.length - 1] === "Z") {
        timeString = inputString.substr(0, inputString.length - 1);
        isUTC = true;
      } //endregion
      //region Convert as local time
      else {
          //noinspection JSPrimitiveTypeWrapperUsage
          var number = new Number(inputString[inputString.length - 1]);
          if (isNaN(number.valueOf())) throw new Error("Wrong input string for convertion");
          timeString = inputString;
        } //endregion
      //region Check that we do not have a "+" and "-" symbols inside UTC time


      if (isUTC) {
        if (timeString.indexOf("+") !== -1) throw new Error("Wrong input string for convertion");
        if (timeString.indexOf("-") !== -1) throw new Error("Wrong input string for convertion");
      } //endregion
      //region Get "UTC time difference" in case of local time
      else {
          var multiplier = 1;
          var differencePosition = timeString.indexOf("+");
          var differenceString = "";

          if (differencePosition === -1) {
            differencePosition = timeString.indexOf("-");
            multiplier = -1;
          }

          if (differencePosition !== -1) {
            differenceString = timeString.substr(differencePosition + 1);
            timeString = timeString.substr(0, differencePosition);
            if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error("Wrong input string for convertion"); //noinspection JSPrimitiveTypeWrapperUsage

            var _number = new Number(differenceString.substr(0, 2));

            if (isNaN(_number.valueOf())) throw new Error("Wrong input string for convertion");
            hourDifference = multiplier * _number;

            if (differenceString.length === 4) {
              //noinspection JSPrimitiveTypeWrapperUsage
              _number = new Number(differenceString.substr(2, 2));
              if (isNaN(_number.valueOf())) throw new Error("Wrong input string for convertion");
              minuteDifference = multiplier * _number;
            }
          }
        } //endregion
      //region Get position of fraction point


      var fractionPointPosition = timeString.indexOf("."); // Check for "full stop" symbol

      if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(","); // Check for "comma" symbol
      //endregion
      //region Get fraction part

      if (fractionPointPosition !== -1) {
        //noinspection JSPrimitiveTypeWrapperUsage
        var fractionPartCheck = new Number("0".concat(timeString.substr(fractionPointPosition)));
        if (isNaN(fractionPartCheck.valueOf())) throw new Error("Wrong input string for convertion");
        fractionPart = fractionPartCheck.valueOf();
        dateTimeString = timeString.substr(0, fractionPointPosition);
      } else dateTimeString = timeString; //endregion
      //region Parse internal date


      switch (true) {
        case dateTimeString.length === 8:
          // "YYYYMMDD"
          parser = /(\d{4})(\d{2})(\d{2})/ig;
          if (fractionPointPosition !== -1) throw new Error("Wrong input string for convertion"); // Here we should not have a "fraction point"

          break;

        case dateTimeString.length === 10:
          // "YYYYMMDDHH"
          parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;

          if (fractionPointPosition !== -1) {
            var fractionResult = 60 * fractionPart;
            this.minute = Math.floor(fractionResult);
            fractionResult = 60 * (fractionResult - this.minute);
            this.second = Math.floor(fractionResult);
            fractionResult = 1000 * (fractionResult - this.second);
            this.millisecond = Math.floor(fractionResult);
          }

          break;

        case dateTimeString.length === 12:
          // "YYYYMMDDHHMM"
          parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

          if (fractionPointPosition !== -1) {
            var _fractionResult = 60 * fractionPart;

            this.second = Math.floor(_fractionResult);
            _fractionResult = 1000 * (_fractionResult - this.second);
            this.millisecond = Math.floor(_fractionResult);
          }

          break;

        case dateTimeString.length === 14:
          // "YYYYMMDDHHMMSS"
          parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

          if (fractionPointPosition !== -1) {
            var _fractionResult2 = 1000 * fractionPart;

            this.millisecond = Math.floor(_fractionResult2);
          }

          break;

        default:
          throw new Error("Wrong input string for convertion");
      } //endregion
      //region Put parsed values at right places


      var parserArray = parser.exec(dateTimeString);
      if (parserArray === null) throw new Error("Wrong input string for convertion");

      for (var j = 1; j < parserArray.length; j++) {
        switch (j) {
          case 1:
            this.year = parseInt(parserArray[j], 10);
            break;

          case 2:
            this.month = parseInt(parserArray[j], 10);
            break;

          case 3:
            this.day = parseInt(parserArray[j], 10);
            break;

          case 4:
            this.hour = parseInt(parserArray[j], 10) + hourDifference;
            break;

          case 5:
            this.minute = parseInt(parserArray[j], 10) + minuteDifference;
            break;

          case 6:
            this.second = parseInt(parserArray[j], 10);
            break;

          default:
            throw new Error("Wrong input string for convertion");
        }
      } //endregion
      //region Get final date


      if (isUTC === false) {
        var tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
        this.year = tempDate.getUTCFullYear();
        this.month = tempDate.getUTCMonth();
        this.day = tempDate.getUTCDay();
        this.hour = tempDate.getUTCHours();
        this.minute = tempDate.getUTCMinutes();
        this.second = tempDate.getUTCSeconds();
        this.millisecond = tempDate.getUTCMilliseconds();
      } //endregion

    } //**********************************************************************************

    /**
     *   converting ASN.1 internal class into JavaScript string
     * @returns {string}
     */


    toString() {
      var outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));

      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }

      outputArray.push("Z");
      return outputArray.join("");
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "GeneralizedTime";
    } //**********************************************************************************

    /**
     * Convertion for the block to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object

      try {
        object = super.toJSON();
      } catch (ex) {} //endregion


      object.year = this.year;
      object.month = this.month;
      object.day = this.day;
      object.hour = this.hour;
      object.minute = this.minute;
      object.second = this.second;
      object.millisecond = this.millisecond;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends Utf8String
   */


  class DATE extends Utf8String {
    //**********************************************************************************

    /**
     * Constructor for "DATE" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 31; // DATE
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "DATE";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends Utf8String
   */


  class TimeOfDay extends Utf8String {
    //**********************************************************************************

    /**
     * Constructor for "TimeOfDay" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 32; // TimeOfDay
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "TimeOfDay";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends Utf8String
   */


  class DateTime extends Utf8String {
    //**********************************************************************************

    /**
     * Constructor for "DateTime" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 33; // DateTime
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "DateTime";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends Utf8String
   */


  class Duration extends Utf8String {
    //**********************************************************************************

    /**
     * Constructor for "Duration" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 34; // Duration
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "Duration";
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * @extends Utf8String
   */


  class TIME extends Utf8String {
    //**********************************************************************************

    /**
     * Constructor for "Time" class
     * @param {Object} [parameters={}]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super(parameters);
      this.idBlock.tagClass = 1; // UNIVERSAL

      this.idBlock.tagNumber = 14; // Time
    } //**********************************************************************************

    /**
     * Aux  , need to get a block name. Need to have it here for inhiritence
     * @returns {string}
     */


    static blockName() {
      return "TIME";
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of special ASN.1 schema type Choice
  //**************************************************************************************


  class Choice {
    //**********************************************************************************

    /**
     * Constructor for "Choice" class
     * @param {Object} [parameters={}]
     * @property {Array} [value] Array of ASN.1 types for make a choice from
     * @property {boolean} [optional]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.value = getParametersValue(parameters, "value", []);
      this.optional = getParametersValue(parameters, "optional", false);
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of special ASN.1 schema type Any
  //**************************************************************************************


  class Any {
    //**********************************************************************************

    /**
     * Constructor for "Any" class
     * @param {Object} [parameters={}]
     * @property {string} [name]
     * @property {boolean} [optional]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.name = getParametersValue(parameters, "name", "");
      this.optional = getParametersValue(parameters, "optional", false);
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of special ASN.1 schema type Repeated
  //**************************************************************************************


  class Repeated {
    //**********************************************************************************

    /**
     * Constructor for "Repeated" class
     * @param {Object} [parameters={}]
     * @property {string} [name]
     * @property {boolean} [optional]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.name = getParametersValue(parameters, "name", "");
      this.optional = getParametersValue(parameters, "optional", false);
      this.value = getParametersValue(parameters, "value", new Any());
      this.local = getParametersValue(parameters, "local", false); // Could local or global array to store elements
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of special ASN.1 schema type RawData
  //**************************************************************************************

  /**
   * @description Special class providing ability to have "toBER/fromBER" for raw ArrayBuffer
   */


  class RawData {
    //**********************************************************************************

    /**
     * Constructor for "Repeated" class
     * @param {Object} [parameters={}]
     * @property {string} [name]
     * @property {boolean} [optional]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.data = getParametersValue(parameters, "data", new ArrayBuffer(0));
    } //**********************************************************************************

    /**
     * Base   for converting block from BER encoded array of bytes
     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
     * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
     * @returns {number} Offset after least decoded byte
     */


    fromBER(inputBuffer, inputOffset, inputLength) {
      this.data = inputBuffer.slice(inputOffset, inputLength);
      return inputOffset + inputLength;
    } //**********************************************************************************

    /**
     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
     * @returns {ArrayBuffer}
     */


    toBER() {
      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.data;
    } //**********************************************************************************


  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Major ASN.1 BER decoding  
  //**************************************************************************************

  /**
   * Internal library   for decoding ASN.1 BER
   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
   * @param {!number} inputLength Maximum length of array of bytes which can be using in this  
   * @returns {{offset: number, result: Object}}
   */


    LocalFromBER(inputBuffer, inputOffset, inputLength) {
    var incomingOffset = inputOffset; // Need to store initial offset since "inputOffset" is changing in the  
    //region Local   changing a type for ASN.1 classes

      localChangeType(inputObject, newType) {
      if (inputObject instanceof newType) return inputObject;
      var newObject = new newType();
      newObject.idBlock = inputObject.idBlock;
      newObject.lenBlock = inputObject.lenBlock;
      newObject.warnings = inputObject.warnings; //noinspection JSCheck Signatures

      newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);
      return newObject;
    } //endregion
    //region Create a basic ASN.1 type since we need to return errors and warnings from the  


    var returnObject = new BaseBlock({}, Object); //endregion
    //region Basic check for parameters

    if (checkBufferParams(new LocalBaseBlock(), inputBuffer, inputOffset, inputLength) === false) {
      returnObject.error = "Wrong input parameters";
      return {
        offset: -1,
        result: returnObject
      };
    } //endregion
    //region Getting Uint8Array from ArrayBuffer


    var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion
    //region Initial checks

    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return {
        offset: -1,
        result: returnObject
      };
    } //endregion
    //region Decode indentifcation block of ASN.1 BER structure


    var resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
    returnObject.warnings.concat(returnObject.idBlock.warnings);

    if (resultOffset === -1) {
      returnObject.error = returnObject.idBlock.error;
      return {
        offset: -1,
        result: returnObject
      };
    }

    inputOffset = resultOffset;
    inputLength -= returnObject.idBlock.blockLength; //endregion
    //region Decode length block of ASN.1 BER structure

    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
    returnObject.warnings.concat(returnObject.lenBlock.warnings);

    if (resultOffset === -1) {
      returnObject.error = returnObject.lenBlock.error;
      return {
        offset: -1,
        result: returnObject
      };
    }

    inputOffset = resultOffset;
    inputLength -= returnObject.lenBlock.blockLength; //endregion
    //region Check for usign indefinite length form in encoding for primitive types

    if (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {
      returnObject.error = "Indefinite length form used for primitive encoding form";
      return {
        offset: -1,
        result: returnObject
      };
    } //endregion
    //region Switch ASN.1 block type


    var newASN1Type = BaseBlock;

    switch (returnObject.idBlock.tagClass) {
      //region UNIVERSAL
      case 1:
        //region Check for reserved tag numbers
        if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
          returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        } //endregion


        switch (returnObject.idBlock.tagNumber) {
          //region EndOfContent type
          case 0:
            //region Check for EndOfContent type
            if (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {
              returnObject.error = "Type [UNIVERSAL 0] is reserved";
              return {
                offset: -1,
                result: returnObject
              };
            } //endregion


            newASN1Type = EndOfContent;
            break;
          //endregion
          //region Boolean type

          case 1:
            newASN1Type = Boolean;
            break;
          //endregion
          //region Integer type

          case 2:
            newASN1Type = Integer;
            break;
          //endregion
          //region BitString type

          case 3:
            newASN1Type = BitString;
            break;
          //endregion
          //region OctetString type

          case 4:
            newASN1Type = OctetString;
            break;
          //endregion
          //region Null type

          case 5:
            newASN1Type = Null;
            break;
          //endregion
          //region OBJECT IDENTIFIER type

          case 6:
            newASN1Type = ObjectIdentifier;
            break;
          //endregion
          //region Enumerated type

          case 10:
            newASN1Type = Enumerated;
            break;
          //endregion
          //region Utf8String type

          case 12:
            newASN1Type = Utf8String;
            break;
          //endregion
          //region Time type

          case 14:
            newASN1Type = TIME;
            break;
          //endregion
          //region ASN.1 reserved type

          case 15:
            returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
            return {
              offset: -1,
              result: returnObject
            };
          //endregion
          //region Sequence type

          case 16:
            newASN1Type = Sequence;
            break;
          //endregion
          //region Set type

          case 17:
            newASN1Type = Set;
            break;
          //endregion
          //region NumericString type

          case 18:
            newASN1Type = NumericString;
            break;
          //endregion
          //region PrintableString type

          case 19:
            newASN1Type = PrintableString;
            break;
          //endregion
          //region TeletexString type

          case 20:
            newASN1Type = TeletexString;
            break;
          //endregion
          //region VideotexString type

          case 21:
            newASN1Type = VideotexString;
            break;
          //endregion
          //region IA5String type

          case 22:
            newASN1Type = IA5String;
            break;
          //endregion
          //region UTCTime type

          case 23:
            newASN1Type = UTCTime;
            break;
          //endregion
          //region GeneralizedTime type

          case 24:
            newASN1Type = GeneralizedTime;
            break;
          //endregion
          //region GraphicString type

          case 25:
            newASN1Type = GraphicString;
            break;
          //endregion
          //region VisibleString type

          case 26:
            newASN1Type = VisibleString;
            break;
          //endregion
          //region GeneralString type

          case 27:
            newASN1Type = GeneralString;
            break;
          //endregion
          //region UniversalString type

          case 28:
            newASN1Type = UniversalString;
            break;
          //endregion
          //region CharacterString type

          case 29:
            newASN1Type = CharacterString;
            break;
          //endregion
          //region BmpString type

          case 30:
            newASN1Type = BmpString;
            break;
          //endregion
          //region DATE type

          case 31:
            newASN1Type = DATE;
            break;
          //endregion
          //region TimeOfDay type

          case 32:
            newASN1Type = TimeOfDay;
            break;
          //endregion
          //region Date-Time type

          case 33:
            newASN1Type = DateTime;
            break;
          //endregion
          //region Duration type

          case 34:
            newASN1Type = Duration;
            break;
          //endregion
          //region default

          default:
            {
              var newObject;
              if (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();
              newObject.idBlock = returnObject.idBlock;
              newObject.lenBlock = returnObject.lenBlock;
              newObject.warnings = returnObject.warnings;
              returnObject = newObject;
              resultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);
            }
          //endregion
        }

        break;
      //endregion
      //region All other tag classes

      case 2: // APPLICATION

      case 3: // CONTEXT-SPECIFIC

      case 4: // PRIVATE

      default:
        {
          if (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;
        }
      //endregion
    } //endregion
    //region Change type and perform BER decoding


    returnObject = localChangeType(returnObject, newASN1Type);
    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length); //endregion
    //region Coping incoming buffer for entire ASN.1 block

    returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength); //endregion

    return {
      offset: resultOffset,
      result: returnObject
    };
  } //**************************************************************************************

  /**
   * Major   for decoding ASN.1 BER array into internal library structuries
   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes
   */


    fromBER(inputBuffer) {
    if (inputBuffer.byteLength === 0) {
      var result = new BaseBlock({}, Object);
      result.error = "Input buffer has zero length";
      return {
        offset: -1,
        result
      };
    }

    return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);
  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Major scheme verification  
  //**************************************************************************************

  /**
   * Compare of two ASN.1 object trees
   * @param {!Object} root Root of input ASN.1 object tree
   * @param {!Object} inputData Input ASN.1 object tree
   * @param {!Object} inputSchema Input ASN.1 schema to compare with
   * @return {{verified: boolean}|{verified:boolean, result: Object}}
   */


    compareSchema(root, inputData, inputSchema) {
    //region Special case for Choice schema element type
    if (inputSchema instanceof Choice) {
      for (var j = 0; j < inputSchema.value.length; j++) {
        var result = compareSchema(root, inputData, inputSchema.value[j]);

        if (result.verified === true) {
          return {
            verified: true,
            result: root
          };
        }
      }

      {
        var _result = {
          verified: false,
          result: {
            error: "Wrong values for Choice type"
          }
        };
        if (inputSchema.hasOwnProperty("name")) _result.name = inputSchema.name;
        return _result;
      }
    } //endregion
    //region Special case for Any schema element type


    if (inputSchema instanceof Any) {
      //region Add named component of ASN.1 schema
      if (inputSchema.hasOwnProperty("name")) root[inputSchema.name] = inputData; //endregion

      return {
        verified: true,
        result: root
      };
    } //endregion
    //region Initial check


    if (root instanceof Object === false) {
      return {
        verified: false,
        result: {
          error: "Wrong root object"
        }
      };
    }

    if (inputData instanceof Object === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 data"
        }
      };
    }

    if (inputSchema instanceof Object === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }

    if ("idBlock" in inputSchema === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    } //endregion
    //region Comparing idBlock properties in ASN.1 data and ASN.1 schema
    //region Encode and decode ASN.1 schema idBlock
    /// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>


    if ("fromBER" in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }

    if ("toBER" in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }

    var encodedId = inputSchema.idBlock.toBER(false);

    if (encodedId.byteLength === 0) {
      return {
        verified: false,
        result: {
          error: "Error encoding idBlock for ASN.1 schema"
        }
      };
    }

    var decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);

    if (decodedOffset === -1) {
      return {
        verified: false,
        result: {
          error: "Error decoding idBlock for ASN.1 schema"
        }
      };
    } //endregion
    //region tagClass


    if (inputSchema.idBlock.hasOwnProperty("tagClass") === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }

    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
      return {
        verified: false,
        result: root
      };
    } //endregion
    //region tagNumber


    if (inputSchema.idBlock.hasOwnProperty("tagNumber") === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }

    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
      return {
        verified: false,
        result: root
      };
    } //endregion
    //region isConstructed


    if (inputSchema.idBlock.hasOwnProperty("isConstructed") === false) {
      return {
        verified: false,
        result: {
          error: "Wrong ASN.1 schema"
        }
      };
    }

    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
      return {
        verified: false,
        result: root
      };
    } //endregion
    //region isHexOnly


    if ("isHexOnly" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property
      {
        return {
          verified: false,
          result: {
            error: "Wrong ASN.1 schema"
          }
        };
      }

    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
      return {
        verified: false,
        result: root
      };
    } //endregion
    //region valueHex


    if (inputSchema.idBlock.isHexOnly === true) {
      if ("valueHex" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property
        {
          return {
            verified: false,
            result: {
              error: "Wrong ASN.1 schema"
            }
          };
        }

      var schemaView = new Uint8Array(inputSchema.idBlock.valueHex);
      var asn1View = new Uint8Array(inputData.idBlock.valueHex);

      if (schemaView.length !== asn1View.length) {
        return {
          verified: false,
          result: root
        };
      }

      for (var i = 0; i < schemaView.length; i++) {
        if (schemaView[i] !== asn1View[1]) {
          return {
            verified: false,
            result: root
          };
        }
      }
    } //endregion
    //endregion
    //region Add named component of ASN.1 schema


    if (inputSchema.hasOwnProperty("name")) {
      inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
      if (inputSchema.name !== "") root[inputSchema.name] = inputData;
    } //endregion
    //region Getting next ASN.1 block for comparition


    if (inputSchema.idBlock.isConstructed === true) {
      var admission = 0;
      var _result2 = {
        verified: false
      };
      var maxLength = inputSchema.valueBlock.value.length;

      if (maxLength > 0) {
        if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;
      } //region Special case when constructive value has no elements


      if (maxLength === 0) {
        return {
          verified: true,
          result: root
        };
      } //endregion
      //region Special case when "inputData" has no values and "inputSchema" has all optional values


      if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
        var _optional = true;

        for (var _i15 = 0; _i15 < inputSchema.valueBlock.value.length; _i15++) {
          _optional = _optional && (inputSchema.valueBlock.value[_i15].optional || false);
        }

        if (_optional === true) {
          return {
            verified: true,
            result: root
          };
        } //region Delete early added name of block


        if (inputSchema.hasOwnProperty("name")) {
          inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
          if (inputSchema.name !== "") delete root[inputSchema.name];
        } //endregion


        root.error = "Inconsistent object length";
        return {
          verified: false,
          result: root
        };
      } //endregion


      for (var _i16 = 0; _i16 < maxLength; _i16++) {
        //region Special case when there is an "optional" element of ASN.1 schema at the end
        if (_i16 - admission >= inputData.valueBlock.value.length) {
          if (inputSchema.valueBlock.value[_i16].optional === false) {
            var _result3 = {
              verified: false,
              result: root
            };
            root.error = "Inconsistent length between ASN.1 data and schema"; //region Delete early added name of block

            if (inputSchema.hasOwnProperty("name")) {
              inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");

              if (inputSchema.name !== "") {
                delete root[inputSchema.name];
                _result3.name = inputSchema.name;
              }
            } //endregion


            return _result3;
          }
        } //endregion
        else {
            //region Special case for Repeated type of ASN.1 schema element
            if (inputSchema.valueBlock.value[0] instanceof Repeated) {
              _result2 = compareSchema(root, inputData.valueBlock.value[_i16], inputSchema.valueBlock.value[0].value);

              if (_result2.verified === false) {
                if (inputSchema.valueBlock.value[0].optional === true) admission++;else {
                  //region Delete early added name of block
                  if (inputSchema.hasOwnProperty("name")) {
                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
                    if (inputSchema.name !== "") delete root[inputSchema.name];
                  } //endregion


                  return _result2;
                }
              }

              if ("name" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
                var arrayRoot = {};
                if ("local" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;
                if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined") arrayRoot[inputSchema.valueBlock.value[0].name] = [];
                arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[_i16]);
              }
            } //endregion
            else {
                _result2 = compareSchema(root, inputData.valueBlock.value[_i16 - admission], inputSchema.valueBlock.value[_i16]);

                if (_result2.verified === false) {
                  if (inputSchema.valueBlock.value[_i16].optional === true) admission++;else {
                    //region Delete early added name of block
                    if (inputSchema.hasOwnProperty("name")) {
                      inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
                      if (inputSchema.name !== "") delete root[inputSchema.name];
                    } //endregion


                    return _result2;
                  }
                }
              }
          }
      }

      if (_result2.verified === false) // The situation may take place if last element is "optional" and verification failed
        {
          var _result4 = {
            verified: false,
            result: root
          }; //region Delete early added name of block

          if (inputSchema.hasOwnProperty("name")) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");

            if (inputSchema.name !== "") {
              delete root[inputSchema.name];
              _result4.name = inputSchema.name;
            }
          } //endregion


          return _result4;
        }

      return {
        verified: true,
        result: root
      };
    } //endregion
    //region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)


    if ("primitiveSchema" in inputSchema && "valueHex" in inputData.valueBlock) {
      //region Decoding of raw ASN.1 data
      var asn1 = fromBER(inputData.valueBlock.valueHex);

      if (asn1.offset === -1) {
        var _result5 = {
          verified: false,
          result: asn1.result
        }; //region Delete early added name of block

        if (inputSchema.hasOwnProperty("name")) {
          inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");

          if (inputSchema.name !== "") {
            delete root[inputSchema.name];
            _result5.name = inputSchema.name;
          }
        } //endregion


        return _result5;
      } //endregion


      return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
    }

    return {
      verified: true,
      result: root
    }; //endregion
  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class AlgorithmIdentifier {
    //**********************************************************************************

    /**
     * Constructor for AlgorithmIdentifier class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc ObjectIdentifier for algorithm (string representation)
       */
      this.algorithmId = getParametersValue(parameters, "algorithmId", AlgorithmIdentifier.defaultValues("algorithmId"));
      if ("algorithmParams" in parameters)
        /**
         * @type {Object}
         * @desc Any algorithm parameters
         */
        this.algorithmParams = getParametersValue(parameters, "algorithmParams", AlgorithmIdentifier.defaultValues("algorithmParams")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "algorithmId":
          return "";

        case "algorithmParams":
          return new Any();

        default:
          throw new Error("Invalid member name for AlgorithmIdentifier class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "algorithmId":
          return memberValue === "";

        case "algorithmParams":
          return memberValue instanceof Any;

        default:
          throw new Error("Invalid member name for AlgorithmIdentifier class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AlgorithmIdentifier  ::=  Sequence  {
     *    algorithm               OBJECT IDENTIFIER,
     *    parameters              ANY DEFINED BY algorithm OPTIONAL  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm
       * @property {string} algorithmParams Any algorithm parameters
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        optional: names.optional || false,
        value: [new ObjectIdentifier({
          name: names.algorithmIdentifier || ""
        }), new Any({
          name: names.algorithmParams || "",
          optional: true
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["algorithm", "params"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AlgorithmIdentifier.schema({
        names: {
          algorithmIdentifier: "algorithm",
          algorithmParams: "params"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier"); //endregion
      //region Get internal properties from parsed schema

      this.algorithmId = asn1.result.algorithm.valueBlock.toString();
      if ("params" in asn1.result) this.algorithmParams = asn1.result.params; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(new ObjectIdentifier({
        value: this.algorithmId
      }));
      if ("algorithmParams" in this && this.algorithmParams instanceof Any === false) outputArray.push(this.algorithmParams); //endregion
      //region Construct and return new ASN.1 schema for this object

      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        algorithmId: this.algorithmId
      };
      if ("algorithmParams" in this && this.algorithmParams instanceof Any === false) object.algorithmParams = this.algorithmParams.toJSON();
      return object;
    } //**********************************************************************************

    /**
     * Check that two "AlgorithmIdentifiers" are equal
     * @param {AlgorithmIdentifier} algorithmIdentifier
     * @returns {boolean}
     */


    isEqual(algorithmIdentifier) {
      //region Check input type
      if (algorithmIdentifier instanceof AlgorithmIdentifier === false) return false; //endregion
      //region Check "algorithm_id"

      if (this.algorithmId !== algorithmIdentifier.algorithmId) return false; //endregion
      //region Check "algorithm_params"

      if ("algorithmParams" in this) {
        if ("algorithmParams" in algorithmIdentifier) return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);
        return false;
      }

      if ("algorithmParams" in algorithmIdentifier) return false; //endregion

      return true;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5480
   */


  class ECPublicKey {
    //**********************************************************************************

    /**
     * Constructor for ECCPublicKey class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {ArrayBuffer}
       * @desc type
       */
      this.x = getParametersValue(parameters, "x", ECPublicKey.defaultValues("x"));
      /**
       * @type {ArrayBuffer}
       * @desc values
       */

      this.y = getParametersValue(parameters, "y", ECPublicKey.defaultValues("y"));
      /**
       * @type {string}
       * @desc namedCurve
       */

      this.namedCurve = getParametersValue(parameters, "namedCurve", ECPublicKey.defaultValues("namedCurve")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
      //region If input argument array contains "json" for this object

      if ("json" in parameters) this.fromJSON(parameters.json); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "x":
        case "y":
          return new ArrayBuffer(0);

        case "namedCurve":
          return "";

        default:
          throw new Error("Invalid member name for ECCPublicKey class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "x":
        case "y":
          return isEqualBuffer(memberValue, ECPublicKey.defaultValues(memberName));

        case "namedCurve":
          return memberValue === "";

        default:
          throw new Error("Invalid member name for ECCPublicKey class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new RawData();
    } //**********************************************************************************

    /**
     * Convert ArrayBuffer into current class
     * @param {!ArrayBuffer} schema Special case: schema is an ArrayBuffer
     */


    fromSchema(schema) {
      //region Check the schema is valid
      if (schema instanceof ArrayBuffer === false) throw new Error("Object's schema was not verified against input data for ECPublicKey");
      var view = new Uint8Array(schema);
      if (view[0] !== 0x04) throw new Error("Object's schema was not verified against input data for ECPublicKey"); //endregion
      //region Get internal properties from parsed schema

      var coordinateLength;

      switch (this.namedCurve) {
        case "1.2.840.10045.3.1.7":
          // P-256
          coordinateLength = 32;
          break;

        case "1.3.132.0.34":
          // P-384
          coordinateLength = 48;
          break;

        case "1.3.132.0.35":
          // P-521
          coordinateLength = 66;
          break;

        default:
          throw new Error("Incorrect curve OID: ".concat(this.namedCurve));
      }

      if (schema.byteLength !== coordinateLength * 2 + 1) throw new Error("Object's schema was not verified against input data for ECPublicKey");
      this.x = schema.slice(1, coordinateLength + 1);
      this.y = schema.slice(1 + coordinateLength, coordinateLength * 2 + 1); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      return new RawData({
        data: utilConcatBuf(new Uint8Array([0x04]).buffer, this.x, this.y)
      });
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var crvName = "";

      switch (this.namedCurve) {
        case "1.2.840.10045.3.1.7":
          // P-256
          crvName = "P-256";
          break;

        case "1.3.132.0.34":
          // P-384
          crvName = "P-384";
          break;

        case "1.3.132.0.35":
          // P-521
          crvName = "P-521";
          break;

        default:
      }

      return {
        crv: crvName,
        x: toBase64(arrayBufferToString(this.x), true, true, false),
        y: toBase64(arrayBufferToString(this.y), true, true, false)
      };
    } //**********************************************************************************

    /**
     * Convert JSON value into current object
     * @param {Object} json
     */


    fromJSON(json) {
      var coodinateLength = 0;

      if ("crv" in json) {
        switch (json.crv.toUpperCase()) {
          case "P-256":
            this.namedCurve = "1.2.840.10045.3.1.7";
            coodinateLength = 32;
            break;

          case "P-384":
            this.namedCurve = "1.3.132.0.34";
            coodinateLength = 48;
            break;

          case "P-521":
            this.namedCurve = "1.3.132.0.35";
            coodinateLength = 66;
            break;

          default:
        }
      } else throw new Error("Absent mandatory parameter \"crv\"");

      if ("x" in json) {
        var convertBuffer = stringToArrayBuffer(fromBase64(json.x, true));

        if (convertBuffer.byteLength < coodinateLength) {
          this.x = new ArrayBuffer(coodinateLength);
          var view = new Uint8Array(this.x);
          var convertBufferView = new Uint8Array(convertBuffer);
          view.set(convertBufferView, 1);
        } else this.x = convertBuffer.slice(0, coodinateLength);
      } else throw new Error("Absent mandatory parameter \"x\"");

      if ("y" in json) {
        var _convertBuffer = stringToArrayBuffer(fromBase64(json.y, true));

        if (_convertBuffer.byteLength < coodinateLength) {
          this.y = new ArrayBuffer(coodinateLength);

          var _view3 = new Uint8Array(this.y);

          var _convertBufferView = new Uint8Array(_convertBuffer);

          _view3.set(_convertBufferView, 1);
        } else this.y = _convertBuffer.slice(0, coodinateLength);
      } else throw new Error("Absent mandatory parameter \"y\"");
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC3447
   */


  class RSAPublicKey {
    //**********************************************************************************

    /**
     * Constructor for RSAPublicKey class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     * @property {Integer} [modulus]
     * @property {Integer} [publicExponent]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Integer}
       * @desc Modulus part of RSA public key
       */
      this.modulus = getParametersValue(parameters, "modulus", RSAPublicKey.defaultValues("modulus"));
      /**
       * @type {Integer}
       * @desc Public exponent of RSA public key
       */

      this.publicExponent = getParametersValue(parameters, "publicExponent", RSAPublicKey.defaultValues("publicExponent")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
      //region If input argument array contains "json" for this object

      if ("json" in parameters) this.fromJSON(parameters.json); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "modulus":
          return new Integer();

        case "publicExponent":
          return new Integer();

        default:
          throw new Error("Invalid member name for RSAPublicKey class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * RSAPublicKey ::= Sequence {
     *    modulus           Integer,  -- n
     *    publicExponent    Integer   -- e
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} utcTimeName Name for "utcTimeName" choice
       * @property {string} generalTimeName Name for "generalTimeName" choice
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Integer({
          name: names.modulus || ""
        }), new Integer({
          name: names.publicExponent || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["modulus", "publicExponent"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, RSAPublicKey.schema({
        names: {
          modulus: "modulus",
          publicExponent: "publicExponent"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RSAPublicKey"); //endregion
      //region Get internal properties from parsed schema

      this.modulus = asn1.result.modulus.convertFromDER(256);
      this.publicExponent = asn1.result.publicExponent; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [this.modulus.convertToDER(), this.publicExponent]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        n: toBase64(arrayBufferToString(this.modulus.valueBlock.valueHex), true, true, true),
        e: toBase64(arrayBufferToString(this.publicExponent.valueBlock.valueHex), true, true, true)
      };
    } //**********************************************************************************

    /**
     * Convert JSON value into current object
     * @param {Object} json
     */


    fromJSON(json) {
      if ("n" in json) {
        var array = stringToArrayBuffer(fromBase64(json.n, true));
        this.modulus = new Integer({
          valueHex: array.slice(0, Math.pow(2, nearestPowerOf2(array.byteLength)))
        });
      } else throw new Error("Absent mandatory parameter \"n\"");

      if ("e" in json) this.publicExponent = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.e, true)).slice(0, 3)
      });else throw new Error("Absent mandatory parameter \"e\"");
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class PublicKeyInfo {
    //**********************************************************************************

    /**
     * Constructor for PublicKeyInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {AlgorithmIdentifier}
       * @desc Algorithm identifier
       */
      this.algorithm = getParametersValue(parameters, "algorithm", PublicKeyInfo.defaultValues("algorithm"));
      /**
       * @type {BitString}
       * @desc Subject public key value
       */

      this.subjectPublicKey = getParametersValue(parameters, "subjectPublicKey", PublicKeyInfo.defaultValues("subjectPublicKey"));
      if ("parsedKey" in parameters)
        /**
         * @type {ECPublicKey|RSAPublicKey}
         * @desc Parsed public key value
         */
        this.parsedKey = getParametersValue(parameters, "parsedKey", PublicKeyInfo.defaultValues("parsedKey")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
      //region If input argument array contains "json" for this object

      if ("json" in parameters) this.fromJSON(parameters.json); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "algorithm":
          return new AlgorithmIdentifier();

        case "subjectPublicKey":
          return new BitString();

        default:
          throw new Error("Invalid member name for PublicKeyInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * SubjectPublicKeyInfo  ::=  Sequence  {
     *    algorithm            AlgorithmIdentifier,
     *    subjectPublicKey     BIT STRING  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [algorithm]
       * @property {string} [subjectPublicKey]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [AlgorithmIdentifier.schema(names.algorithm || {}), new BitString({
          name: names.subjectPublicKey || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["algorithm", "subjectPublicKey"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PublicKeyInfo.schema({
        names: {
          algorithm: {
            names: {
              blockName: "algorithm"
            }
          },
          subjectPublicKey: "subjectPublicKey"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PublicKeyInfo"); //endregion
      //region Get internal properties from parsed schema

      this.algorithm = new AlgorithmIdentifier({
        schema: asn1.result.algorithm
      });
      this.subjectPublicKey = asn1.result.subjectPublicKey;

      switch (this.algorithm.algorithmId) {
        case "1.2.840.10045.2.1":
          // ECDSA
          if ("algorithmParams" in this.algorithm) {
            if (this.algorithm.algorithmParams.constructor.blockName() === ObjectIdentifier.blockName()) {
              try {
                this.parsedKey = new ECPublicKey({
                  namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),
                  schema: this.subjectPublicKey.valueBlock.valueHex
                });
              } catch (ex) {} // Could be a problems during recognision of internal public key data here. Let's ignore them.

            }
          }

          break;

        case "1.2.840.113549.1.1.1":
          // RSA
          {
            var publicKeyASN1 = fromBER(this.subjectPublicKey.valueBlock.valueHex);

            if (publicKeyASN1.offset !== -1) {
              try {
                this.parsedKey = new RSAPublicKey({
                  schema: publicKeyASN1.result
                });
              } catch (ex) {} // Could be a problems during recognision of internal public key data here. Let's ignore them.

            }
          }
          break;

        default:
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [this.algorithm.toSchema(), this.subjectPublicKey]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      //region Return common value in case we do not have enough info fo making JWK
      if ("parsedKey" in this === false) {
        return {
          algorithm: this.algorithm.toJSON(),
          subjectPublicKey: this.subjectPublicKey.toJSON()
        };
      } //endregion
      //region Making JWK


      var jwk = {};

      switch (this.algorithm.algorithmId) {
        case "1.2.840.10045.2.1":
          // ECDSA
          jwk.kty = "EC";
          break;

        case "1.2.840.113549.1.1.1":
          // RSA
          jwk.kty = "RSA";
          break;

        default:
      }

      var publicKeyJWK = this.parsedKey.toJSON();

      for (var _i17 = 0, _Object$keys = Object.keys(publicKeyJWK); _i17 < _Object$keys.length; _i17++) {
        var key = _Object$keys[_i17];
        jwk[key] = publicKeyJWK[key];
      }

      return jwk; //endregion
    } //**********************************************************************************

    /**
     * Convert JSON value into current object
     * @param {Object} json
     */


    fromJSON(json) {
      if ("kty" in json) {
        switch (json.kty.toUpperCase()) {
          case "EC":
            this.parsedKey = new ECPublicKey({
              json
            });
            this.algorithm = new AlgorithmIdentifier({
              algorithmId: "1.2.840.10045.2.1",
              algorithmParams: new ObjectIdentifier({
                value: this.parsedKey.namedCurve
              })
            });
            break;

          case "RSA":
            this.parsedKey = new RSAPublicKey({
              json
            });
            this.algorithm = new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.1",
              algorithmParams: new Null()
            });
            break;

          default:
            throw new Error("Invalid value for \"kty\" parameter: ".concat(json.kty));
        }

        this.subjectPublicKey = new BitString({
          valueHex: this.parsedKey.toSchema().toBER(false)
        });
      }
    } //**********************************************************************************


    importKey(publicKey) {
      //region Initial variables
      var sequence = Promise.resolve();

      var _this = this; //endregion
      //region Initial check


      if (typeof publicKey === "undefined") return Promise.reject("Need to provide publicKey input parameter"); //endregion
      //region Get a "crypto" extension

      var crypto = getCrypto();
      if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object"); //endregion
      //region Export public key

      sequence = sequence.then(() => crypto.exportKey("spki", publicKey)); //endregion
      //region Initialize internal variables by parsing exported value

      sequence = sequence.then(
      /**
       * @param {ArrayBuffer} exportedKey
       */
      exportedKey => {
        var asn1 = fromBER(exportedKey);

        try {
          _this.fromSchema(asn1.result);
        } catch (exception) {
          return Promise.reject("Error during initializing object from schema");
        }

        return undefined;
      }, error => Promise.reject("Error during exporting public key: ".concat(error))); //endregion

      return sequence;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC2986
   */


  class Attribute {
    //**********************************************************************************

    /**
     * Constructor for Attribute class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc ObjectIdentifier for attribute (string representation)
       */
      this.type = getParametersValue(parameters, "type", Attribute.defaultValues("type"));
      /**
       * @type {Array}
       * @desc Any attribute values
       */

      this.values = getParametersValue(parameters, "values", Attribute.defaultValues("values")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "type":
          return "";

        case "values":
          return [];

        default:
          throw new Error("Invalid member name for Attribute class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "type":
          return memberValue === "";

        case "values":
          return memberValue.length === 0;

        default:
          throw new Error("Invalid member name for Attribute class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
     *    type   ATTRIBUTE.&id({IOSet}),
     *    values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [type]
       * @property {string} [setName]
       * @property {string} [values]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.type || ""
        }), new Set({
          name: names.setName || "",
          value: [new Repeated({
            name: names.values || "",
            value: new Any()
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["type", "values"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, Attribute.schema({
        names: {
          type: "type",
          values: "values"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Attribute"); //endregion
      //region Get internal properties from parsed schema

      this.type = asn1.result.type.valueBlock.toString();
      this.values = asn1.result.values; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new ObjectIdentifier({
          value: this.type
        }), new Set({
          value: this.values
        })]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        type: this.type,
        values: Array.from(this.values, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5915
   */


  class ECPrivateKey {
    //**********************************************************************************

    /**
     * Constructor for ECPrivateKey class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", ECPrivateKey.defaultValues("version"));
      /**
       * @type {OctetString}
       * @desc privateKey
       */

      this.privateKey = getParametersValue(parameters, "privateKey", ECPrivateKey.defaultValues("privateKey"));
      if ("namedCurve" in parameters)
        /**
         * @type {string}
         * @desc namedCurve
         */
        this.namedCurve = getParametersValue(parameters, "namedCurve", ECPrivateKey.defaultValues("namedCurve"));
      if ("publicKey" in parameters)
        /**
         * @type {ECPublicKey}
         * @desc publicKey
         */
        this.publicKey = getParametersValue(parameters, "publicKey", ECPrivateKey.defaultValues("publicKey")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
      //region If input argument array contains "json" for this object

      if ("json" in parameters) this.fromJSON(parameters.json); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 1;

        case "privateKey":
          return new OctetString();

        case "namedCurve":
          return "";

        case "publicKey":
          return new ECPublicKey();

        default:
          throw new Error("Invalid member name for ECCPrivateKey class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "version":
          return memberValue === ECPrivateKey.defaultValues(memberName);

        case "privateKey":
          return memberValue.isEqual(ECPrivateKey.defaultValues(memberName));

        case "namedCurve":
          return memberValue === "";

        case "publicKey":
          return ECPublicKey.compareWithDefault("namedCurve", memberValue.namedCurve) && ECPublicKey.compareWithDefault("x", memberValue.x) && ECPublicKey.compareWithDefault("y", memberValue.y);

        default:
          throw new Error("Invalid member name for ECCPrivateKey class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * ECPrivateKey ::= SEQUENCE {
     * version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
     * privateKey     OCTET STRING,
     * parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
     * publicKey  [1] BIT STRING OPTIONAL
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [version]
       * @property {string} [privateKey]
       * @property {string} [namedCurve]
       * @property {string} [publicKey]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Integer({
          name: names.version || ""
        }), new OctetString({
          name: names.privateKey || ""
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new ObjectIdentifier({
            name: names.namedCurve || ""
          })]
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [new BitString({
            name: names.publicKey || ""
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["version", "privateKey", "namedCurve", "publicKey"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, ECPrivateKey.schema({
        names: {
          version: "version",
          privateKey: "privateKey",
          namedCurve: "namedCurve",
          publicKey: "publicKey"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ECPrivateKey"); //endregion
      //region Get internal properties from parsed schema

      this.version = asn1.result.version.valueBlock.valueDec;
      this.privateKey = asn1.result.privateKey;
      if ("namedCurve" in asn1.result) this.namedCurve = asn1.result.namedCurve.valueBlock.toString();

      if ("publicKey" in asn1.result) {
        var publicKeyData = {
          schema: asn1.result.publicKey.valueBlock.valueHex
        };
        if ("namedCurve" in this) publicKeyData.namedCurve = this.namedCurve;
        this.publicKey = new ECPublicKey(publicKeyData);
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var outputArray = [new Integer({
        value: this.version
      }), this.privateKey];

      if ("namedCurve" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new ObjectIdentifier({
            value: this.namedCurve
          })]
        }));
      }

      if ("publicKey" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [new BitString({
            valueHex: this.publicKey.toSchema().toBER(false)
          })]
        }));
      }

      return new Sequence({
        value: outputArray
      });
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      if ("namedCurve" in this === false || ECPrivateKey.compareWithDefault("namedCurve", this.namedCurve)) throw new Error("Not enough information for making JSON: absent \"namedCurve\" value");
      var crvName = "";

      switch (this.namedCurve) {
        case "1.2.840.10045.3.1.7":
          // P-256
          crvName = "P-256";
          break;

        case "1.3.132.0.34":
          // P-384
          crvName = "P-384";
          break;

        case "1.3.132.0.35":
          // P-521
          crvName = "P-521";
          break;

        default:
      }

      var privateKeyJSON = {
        crv: crvName,
        d: toBase64(arrayBufferToString(this.privateKey.valueBlock.valueHex), true, true, false)
      };

      if ("publicKey" in this) {
        var publicKeyJSON = this.publicKey.toJSON();
        privateKeyJSON.x = publicKeyJSON.x;
        privateKeyJSON.y = publicKeyJSON.y;
      }

      return privateKeyJSON;
    } //**********************************************************************************

    /**
     * Convert JSON value into current object
     * @param {Object} json
     */


    fromJSON(json) {
      var coodinateLength = 0;

      if ("crv" in json) {
        switch (json.crv.toUpperCase()) {
          case "P-256":
            this.namedCurve = "1.2.840.10045.3.1.7";
            coodinateLength = 32;
            break;

          case "P-384":
            this.namedCurve = "1.3.132.0.34";
            coodinateLength = 48;
            break;

          case "P-521":
            this.namedCurve = "1.3.132.0.35";
            coodinateLength = 66;
            break;

          default:
        }
      } else throw new Error("Absent mandatory parameter \"crv\"");

      if ("d" in json) {
        var convertBuffer = stringToArrayBuffer(fromBase64(json.d, true));

        if (convertBuffer.byteLength < coodinateLength) {
          var buffer = new ArrayBuffer(coodinateLength);
          var view = new Uint8Array(buffer);
          var convertBufferView = new Uint8Array(convertBuffer);
          view.set(convertBufferView, 1);
          this.privateKey = new OctetString({
            valueHex: buffer
          });
        } else this.privateKey = new OctetString({
          valueHex: convertBuffer.slice(0, coodinateLength)
        });
      } else throw new Error("Absent mandatory parameter \"d\"");

      if ("x" in json && "y" in json) this.publicKey = new ECPublicKey({
        json
      });
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC3447
   */


  class OtherPrimeInfo {
    //**********************************************************************************

    /**
     * Constructor for OtherPrimeInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Integer}
       * @desc prime
       */
      this.prime = getParametersValue(parameters, "prime", OtherPrimeInfo.defaultValues("prime"));
      /**
       * @type {Integer}
       * @desc exponent
       */

      this.exponent = getParametersValue(parameters, "exponent", OtherPrimeInfo.defaultValues("exponent"));
      /**
       * @type {Integer}
       * @desc coefficient
       */

      this.coefficient = getParametersValue(parameters, "coefficient", OtherPrimeInfo.defaultValues("coefficient")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
      //region If input argument array contains "json" for this object

      if ("json" in parameters) this.fromJSON(parameters.json); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "prime":
          return new Integer();

        case "exponent":
          return new Integer();

        case "coefficient":
          return new Integer();

        default:
          throw new Error("Invalid member name for OtherPrimeInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * OtherPrimeInfo ::= Sequence {
     *    prime             Integer,  -- ri
     *    exponent          Integer,  -- di
     *    coefficient       Integer   -- ti
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} prime
       * @property {string} exponent
       * @property {string} coefficient
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Integer({
          name: names.prime || ""
        }), new Integer({
          name: names.exponent || ""
        }), new Integer({
          name: names.coefficient || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["prime", "exponent", "coefficient"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, OtherPrimeInfo.schema({
        names: {
          prime: "prime",
          exponent: "exponent",
          coefficient: "coefficient"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OtherPrimeInfo"); //endregion
      //region Get internal properties from parsed schema

      this.prime = asn1.result.prime.convertFromDER();
      this.exponent = asn1.result.exponent.convertFromDER();
      this.coefficient = asn1.result.coefficient.convertFromDER(); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [this.prime.convertToDER(), this.exponent.convertToDER(), this.coefficient.convertToDER()]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        r: toBase64(arrayBufferToString(this.prime.valueBlock.valueHex), true, true),
        d: toBase64(arrayBufferToString(this.exponent.valueBlock.valueHex), true, true),
        t: toBase64(arrayBufferToString(this.coefficient.valueBlock.valueHex), true, true)
      };
    } //**********************************************************************************

    /**
     * Convert JSON value into current object
     * @param {Object} json
     */


    fromJSON(json) {
      if ("r" in json) this.prime = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.r, true))
      });else throw new Error("Absent mandatory parameter \"r\"");
      if ("d" in json) this.exponent = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.d, true))
      });else throw new Error("Absent mandatory parameter \"d\"");
      if ("t" in json) this.coefficient = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.t, true))
      });else throw new Error("Absent mandatory parameter \"t\"");
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC3447
   */


  class RSAPrivateKey {
    //**********************************************************************************

    /**
     * Constructor for RSAPrivateKey class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", RSAPrivateKey.defaultValues("version"));
      /**
       * @type {Integer}
       * @desc modulus
       */

      this.modulus = getParametersValue(parameters, "modulus", RSAPrivateKey.defaultValues("modulus"));
      /**
       * @type {Integer}
       * @desc publicExponent
       */

      this.publicExponent = getParametersValue(parameters, "publicExponent", RSAPrivateKey.defaultValues("publicExponent"));
      /**
       * @type {Integer}
       * @desc privateExponent
       */

      this.privateExponent = getParametersValue(parameters, "privateExponent", RSAPrivateKey.defaultValues("privateExponent"));
      /**
       * @type {Integer}
       * @desc prime1
       */

      this.prime1 = getParametersValue(parameters, "prime1", RSAPrivateKey.defaultValues("prime1"));
      /**
       * @type {Integer}
       * @desc prime2
       */

      this.prime2 = getParametersValue(parameters, "prime2", RSAPrivateKey.defaultValues("prime2"));
      /**
       * @type {Integer}
       * @desc exponent1
       */

      this.exponent1 = getParametersValue(parameters, "exponent1", RSAPrivateKey.defaultValues("exponent1"));
      /**
       * @type {Integer}
       * @desc exponent2
       */

      this.exponent2 = getParametersValue(parameters, "exponent2", RSAPrivateKey.defaultValues("exponent2"));
      /**
       * @type {Integer}
       * @desc coefficient
       */

      this.coefficient = getParametersValue(parameters, "coefficient", RSAPrivateKey.defaultValues("coefficient"));
      if ("otherPrimeInfos" in parameters)
        /**
         * @type {Array.<OtherPrimeInfo>}
         * @desc otherPrimeInfos
         */
        this.otherPrimeInfos = getParametersValue(parameters, "otherPrimeInfos", RSAPrivateKey.defaultValues("otherPrimeInfos")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
      //region If input argument array contains "json" for this object

      if ("json" in parameters) this.fromJSON(parameters.json); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 0;

        case "modulus":
          return new Integer();

        case "publicExponent":
          return new Integer();

        case "privateExponent":
          return new Integer();

        case "prime1":
          return new Integer();

        case "prime2":
          return new Integer();

        case "exponent1":
          return new Integer();

        case "exponent2":
          return new Integer();

        case "coefficient":
          return new Integer();

        case "otherPrimeInfos":
          return [];

        default:
          throw new Error("Invalid member name for RSAPrivateKey class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * RSAPrivateKey ::= Sequence {
     *    version           Version,
     *    modulus           Integer,  -- n
     *    publicExponent    Integer,  -- e
     *    privateExponent   Integer,  -- d
     *    prime1            Integer,  -- p
     *    prime2            Integer,  -- q
     *    exponent1         Integer,  -- d mod (p-1)
     *    exponent2         Integer,  -- d mod (q-1)
     *    coefficient       Integer,  -- (inverse of q) mod p
     *    otherPrimeInfos   OtherPrimeInfos OPTIONAL
     * }
     *
     * OtherPrimeInfos ::= Sequence SIZE(1..MAX) OF OtherPrimeInfo
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [version]
       * @property {string} [modulus]
       * @property {string} [publicExponent]
       * @property {string} [privateExponent]
       * @property {string} [prime1]
       * @property {string} [prime2]
       * @property {string} [exponent1]
       * @property {string} [exponent2]
       * @property {string} [coefficient]
       * @property {string} [otherPrimeInfosName]
       * @property {Object} [otherPrimeInfo]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Integer({
          name: names.version || ""
        }), new Integer({
          name: names.modulus || ""
        }), new Integer({
          name: names.publicExponent || ""
        }), new Integer({
          name: names.privateExponent || ""
        }), new Integer({
          name: names.prime1 || ""
        }), new Integer({
          name: names.prime2 || ""
        }), new Integer({
          name: names.exponent1 || ""
        }), new Integer({
          name: names.exponent2 || ""
        }), new Integer({
          name: names.coefficient || ""
        }), new Sequence({
          optional: true,
          value: [new Repeated({
            name: names.otherPrimeInfosName || "",
            value: OtherPrimeInfo.schema(names.otherPrimeInfo || {})
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["version", "modulus", "publicExponent", "privateExponent", "prime1", "prime2", "exponent1", "exponent2", "coefficient", "otherPrimeInfos"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, RSAPrivateKey.schema({
        names: {
          version: "version",
          modulus: "modulus",
          publicExponent: "publicExponent",
          privateExponent: "privateExponent",
          prime1: "prime1",
          prime2: "prime2",
          exponent1: "exponent1",
          exponent2: "exponent2",
          coefficient: "coefficient",
          otherPrimeInfo: {
            names: {
              blockName: "otherPrimeInfos"
            }
          }
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RSAPrivateKey"); //endregion
      //region Get internal properties from parsed schema

      this.version = asn1.result.version.valueBlock.valueDec;
      this.modulus = asn1.result.modulus.convertFromDER(256);
      this.publicExponent = asn1.result.publicExponent;
      this.privateExponent = asn1.result.privateExponent.convertFromDER(256);
      this.prime1 = asn1.result.prime1.convertFromDER(128);
      this.prime2 = asn1.result.prime2.convertFromDER(128);
      this.exponent1 = asn1.result.exponent1.convertFromDER(128);
      this.exponent2 = asn1.result.exponent2.convertFromDER(128);
      this.coefficient = asn1.result.coefficient.convertFromDER(128);
      if ("otherPrimeInfos" in asn1.result) this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, element => new OtherPrimeInfo({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(new Integer({
        value: this.version
      }));
      outputArray.push(this.modulus.convertToDER());
      outputArray.push(this.publicExponent);
      outputArray.push(this.privateExponent.convertToDER());
      outputArray.push(this.prime1.convertToDER());
      outputArray.push(this.prime2.convertToDER());
      outputArray.push(this.exponent1.convertToDER());
      outputArray.push(this.exponent2.convertToDER());
      outputArray.push(this.coefficient.convertToDER());

      if ("otherPrimeInfos" in this) {
        outputArray.push(new Sequence({
          value: Array.from(this.otherPrimeInfos, element => element.toSchema())
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var jwk = {
        n: toBase64(arrayBufferToString(this.modulus.valueBlock.valueHex), true, true, true),
        e: toBase64(arrayBufferToString(this.publicExponent.valueBlock.valueHex), true, true, true),
        d: toBase64(arrayBufferToString(this.privateExponent.valueBlock.valueHex), true, true, true),
        p: toBase64(arrayBufferToString(this.prime1.valueBlock.valueHex), true, true, true),
        q: toBase64(arrayBufferToString(this.prime2.valueBlock.valueHex), true, true, true),
        dp: toBase64(arrayBufferToString(this.exponent1.valueBlock.valueHex), true, true, true),
        dq: toBase64(arrayBufferToString(this.exponent2.valueBlock.valueHex), true, true, true),
        qi: toBase64(arrayBufferToString(this.coefficient.valueBlock.valueHex), true, true, true)
      };
      if ("otherPrimeInfos" in this) jwk.oth = Array.from(this.otherPrimeInfos, element => element.toJSON());
      return jwk;
    } //**********************************************************************************

    /**
     * Convert JSON value into current object
     * @param {Object} json
     */


    fromJSON(json) {
      if ("n" in json) this.modulus = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.n, true, true))
      });else throw new Error("Absent mandatory parameter \"n\"");
      if ("e" in json) this.publicExponent = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.e, true, true))
      });else throw new Error("Absent mandatory parameter \"e\"");
      if ("d" in json) this.privateExponent = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.d, true, true))
      });else throw new Error("Absent mandatory parameter \"d\"");
      if ("p" in json) this.prime1 = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.p, true, true))
      });else throw new Error("Absent mandatory parameter \"p\"");
      if ("q" in json) this.prime2 = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.q, true, true))
      });else throw new Error("Absent mandatory parameter \"q\"");
      if ("dp" in json) this.exponent1 = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.dp, true, true))
      });else throw new Error("Absent mandatory parameter \"dp\"");
      if ("dq" in json) this.exponent2 = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.dq, true, true))
      });else throw new Error("Absent mandatory parameter \"dq\"");
      if ("qi" in json) this.coefficient = new Integer({
        valueHex: stringToArrayBuffer(fromBase64(json.qi, true, true))
      });else throw new Error("Absent mandatory parameter \"qi\"");
      if ("oth" in json) this.otherPrimeInfos = Array.from(json.oth, element => new OtherPrimeInfo({
        json: element
      }));
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5208
   */


  class PrivateKeyInfo {
    //**********************************************************************************

    /**
     * Constructor for PrivateKeyInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", PrivateKeyInfo.defaultValues("version"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc privateKeyAlgorithm
       */

      this.privateKeyAlgorithm = getParametersValue(parameters, "privateKeyAlgorithm", PrivateKeyInfo.defaultValues("privateKeyAlgorithm"));
      /**
       * @type {OctetString}
       * @desc privateKey
       */

      this.privateKey = getParametersValue(parameters, "privateKey", PrivateKeyInfo.defaultValues("privateKey"));
      if ("attributes" in parameters)
        /**
         * @type {Array.<Attribute>}
         * @desc attributes
         */
        this.attributes = getParametersValue(parameters, "attributes", PrivateKeyInfo.defaultValues("attributes"));
      if ("parsedKey" in parameters)
        /**
         * @type {ECPrivateKey|RSAPrivateKey}
         * @desc Parsed public key value
         */
        this.parsedKey = getParametersValue(parameters, "parsedKey", PrivateKeyInfo.defaultValues("parsedKey")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
      //region If input argument array contains "json" for this object

      if ("json" in parameters) this.fromJSON(parameters.json); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 0;

        case "privateKeyAlgorithm":
          return new AlgorithmIdentifier();

        case "privateKey":
          return new OctetString();

        case "attributes":
          return [];

        case "parsedKey":
          return {};

        default:
          throw new Error("Invalid member name for PrivateKeyInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PrivateKeyInfo ::= SEQUENCE {
     *    version Version,
     *    privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
     *    privateKey PrivateKey,
     *    attributes [0] Attributes OPTIONAL }
     *
     * Version ::= INTEGER {v1(0)} (v1,...)
     *
     * PrivateKey ::= OCTET STRING
     *
     * Attributes ::= SET OF Attribute
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [version]
       * @property {string} [privateKeyAlgorithm]
       * @property {string} [privateKey]
       * @property {string} [attributes]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Integer({
          name: names.version || ""
        }), AlgorithmIdentifier.schema(names.privateKeyAlgorithm || {}), new OctetString({
          name: names.privateKey || ""
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Repeated({
            name: names.attributes || "",
            value: Attribute.schema()
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["version", "privateKeyAlgorithm", "privateKey", "attributes"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PrivateKeyInfo.schema({
        names: {
          version: "version",
          privateKeyAlgorithm: {
            names: {
              blockName: "privateKeyAlgorithm"
            }
          },
          privateKey: "privateKey",
          attributes: "attributes"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PrivateKeyInfo"); //endregion
      //region Get internal properties from parsed schema

      this.version = asn1.result.version.valueBlock.valueDec;
      this.privateKeyAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.privateKeyAlgorithm
      });
      this.privateKey = asn1.result.privateKey;
      if ("attributes" in asn1.result) this.attributes = Array.from(asn1.result.attributes, element => new Attribute({
        schema: element
      }));

      switch (this.privateKeyAlgorithm.algorithmId) {
        case "1.2.840.113549.1.1.1":
          // RSA
          {
            var privateKeyASN1 = fromBER(this.privateKey.valueBlock.valueHex);
            if (privateKeyASN1.offset !== -1) this.parsedKey = new RSAPrivateKey({
              schema: privateKeyASN1.result
            });
          }
          break;

        case "1.2.840.10045.2.1":
          // ECDSA
          if ("algorithmParams" in this.privateKeyAlgorithm) {
            if (this.privateKeyAlgorithm.algorithmParams instanceof ObjectIdentifier) {
              var _privateKeyASN = fromBER(this.privateKey.valueBlock.valueHex);

              if (_privateKeyASN.offset !== -1) {
                this.parsedKey = new ECPrivateKey({
                  namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),
                  schema: _privateKeyASN.result
                });
              }
            }
          }

          break;

        default:
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [new Integer({
        value: this.version
      }), this.privateKeyAlgorithm.toSchema(), this.privateKey];

      if ("attributes" in this) {
        outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: Array.from(this.attributes, element => element.toSchema())
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      //region Return common value in case we do not have enough info fo making JWK
      if ("parsedKey" in this === false) {
        var object = {
          version: this.version,
          privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),
          privateKey: this.privateKey.toJSON()
        };
        if ("attributes" in this) object.attributes = Array.from(this.attributes, element => element.toJSON());
        return object;
      } //endregion
      //region Making JWK


      var jwk = {};

      switch (this.privateKeyAlgorithm.algorithmId) {
        case "1.2.840.10045.2.1":
          // ECDSA
          jwk.kty = "EC";
          break;

        case "1.2.840.113549.1.1.1":
          // RSA
          jwk.kty = "RSA";
          break;

        default:
      }

      var publicKeyJWK = this.parsedKey.toJSON();

      for (var _i18 = 0, _Object$keys2 = Object.keys(publicKeyJWK); _i18 < _Object$keys2.length; _i18++) {
        var key = _Object$keys2[_i18];
        jwk[key] = publicKeyJWK[key];
      }

      return jwk; //endregion
    } //**********************************************************************************

    /**
     * Convert JSON value into current object
     * @param {Object} json
     */


    fromJSON(json) {
      if ("kty" in json) {
        switch (json.kty.toUpperCase()) {
          case "EC":
            this.parsedKey = new ECPrivateKey({
              json
            });
            this.privateKeyAlgorithm = new AlgorithmIdentifier({
              algorithmId: "1.2.840.10045.2.1",
              algorithmParams: new ObjectIdentifier({
                value: this.parsedKey.namedCurve
              })
            });
            break;

          case "RSA":
            this.parsedKey = new RSAPrivateKey({
              json
            });
            this.privateKeyAlgorithm = new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.1",
              algorithmParams: new Null()
            });
            break;

          default:
            throw new Error("Invalid value for \"kty\" parameter: ".concat(json.kty));
        }

        this.privateKey = new OctetString({
          valueHex: this.parsedKey.toSchema().toBER(false)
        });
      }
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class EncryptedContentInfo {
    //**********************************************************************************

    /**
     * Constructor for EncryptedContentInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc contentType
       */
      this.contentType = getParametersValue(parameters, "contentType", EncryptedContentInfo.defaultValues("contentType"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc contentEncryptionAlgorithm
       */

      this.contentEncryptionAlgorithm = getParametersValue(parameters, "contentEncryptionAlgorithm", EncryptedContentInfo.defaultValues("contentEncryptionAlgorithm"));

      if ("encryptedContent" in parameters) {
        /**
         * @type {OctetString}
         * @desc encryptedContent (!!!) could be contructive or primitive value (!!!)
         */
        this.encryptedContent = parameters.encryptedContent;

        if (this.encryptedContent.idBlock.tagClass === 1 && this.encryptedContent.idBlock.tagNumber === 4) {
          //region Divide OCTETSTRING value down to small pieces
          if (this.encryptedContent.idBlock.isConstructed === false) {
            var constrString = new OctetString({
              idBlock: {
                isConstructed: true
              },
              isConstructed: true
            });
            var offset = 0;
            var length = this.encryptedContent.valueBlock.valueHex.byteLength;

            while (length > 0) {
              var pieceView = new Uint8Array(this.encryptedContent.valueBlock.valueHex, offset, offset + 1024 > this.encryptedContent.valueBlock.valueHex.byteLength ? this.encryptedContent.valueBlock.valueHex.byteLength - offset : 1024);

              var _array = new ArrayBuffer(pieceView.length);

              var _view = new Uint8Array(_array);

              for (var i = 0; i < _view.length; i++) {
                _view[i] = pieceView[i];
              }

              constrString.valueBlock.value.push(new OctetString({
                valueHex: _array
              }));
              length -= pieceView.length;
              offset += pieceView.length;
            }

            this.encryptedContent = constrString;
          } //endregion

        }
      } //endregion
      //region If input argument array contains "schema" for this object


      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "contentType":
          return "";

        case "contentEncryptionAlgorithm":
          return new AlgorithmIdentifier();

        case "encryptedContent":
          return new OctetString();

        default:
          throw new Error("Invalid member name for EncryptedContentInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "contentType":
          return memberValue === "";

        case "contentEncryptionAlgorithm":
          return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;

        case "encryptedContent":
          return memberValue.isEqual(EncryptedContentInfo.defaultValues(memberName));

        default:
          throw new Error("Invalid member name for EncryptedContentInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * EncryptedContentInfo ::= SEQUENCE {
     *    contentType ContentType,
     *    contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
     *    encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }
     *
     * Comment: Strange, but modern crypto engines create "encryptedContent" as "[0] EXPLICIT EncryptedContent"
     *
     * EncryptedContent ::= OCTET STRING
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [contentType]
       * @property {string} [contentEncryptionAlgorithm]
       * @property {string} [encryptedContent]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.contentType || ""
        }), AlgorithmIdentifier.schema(names.contentEncryptionAlgorithm || {}), // The CHOICE we need because "EncryptedContent" could have either "constructive"
        // or "primitive" form of encoding and we need to handle both variants
        new Choice({
          value: [new Constructed({
            name: names.encryptedContent || "",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            value: [new Repeated({
              value: new OctetString()
            })]
          }), new Primitive({
            name: names.encryptedContent || "",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            }
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["contentType", "contentEncryptionAlgorithm", "encryptedContent"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, EncryptedContentInfo.schema({
        names: {
          contentType: "contentType",
          contentEncryptionAlgorithm: {
            names: {
              blockName: "contentEncryptionAlgorithm"
            }
          },
          encryptedContent: "encryptedContent"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for EncryptedContentInfo"); //endregion
      //region Get internal properties from parsed schema

      this.contentType = asn1.result.contentType.valueBlock.toString();
      this.contentEncryptionAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.contentEncryptionAlgorithm
      });

      if ("encryptedContent" in asn1.result) {
        this.encryptedContent = asn1.result.encryptedContent;
        this.encryptedContent.idBlock.tagClass = 1; // UNIVERSAL

        this.encryptedContent.idBlock.tagNumber = 4; // OCTETSTRING (!!!) The value still has instance of "in_window.org.pkijs.asn1.ASN1_CONSTRUCTED / ASN1_PRIMITIVE"
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var sequenceLengthBlock = {
        isIndefiniteForm: false
      };
      var outputArray = [];
      outputArray.push(new ObjectIdentifier({
        value: this.contentType
      }));
      outputArray.push(this.contentEncryptionAlgorithm.toSchema());

      if ("encryptedContent" in this) {
        sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
        var encryptedValue = this.encryptedContent;
        encryptedValue.idBlock.tagClass = 3; // CONTEXT-SPECIFIC

        encryptedValue.idBlock.tagNumber = 0; // [0]

        encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
        outputArray.push(encryptedValue);
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        lenBlock: sequenceLengthBlock,
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        contentType: this.contentType,
        contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()
      };
      if ("encryptedContent" in this) _object.encryptedContent = this.encryptedContent.toJSON();
      return _object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC4055
   */


  class RSASSAPSSParams {
    //**********************************************************************************

    /**
     * Constructor for RSASSAPSSParams class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {AlgorithmIdentifier}
       * @desc Algorithms of hashing (DEFAULT sha1)
       */
      this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", RSASSAPSSParams.defaultValues("hashAlgorithm"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc Algorithm of "mask generaion   (MGF)" (DEFAULT mgf1SHA1)
       */

      this.maskGenAlgorithm = getParametersValue(parameters, "maskGenAlgorithm", RSASSAPSSParams.defaultValues("maskGenAlgorithm"));
      /**
       * @type {number}
       * @desc Salt length (DEFAULT 20)
       */

      this.saltLength = getParametersValue(parameters, "saltLength", RSASSAPSSParams.defaultValues("saltLength"));
      /**
       * @type {number}
       * @desc (DEFAULT 1)
       */

      this.trailerField = getParametersValue(parameters, "trailerField", RSASSAPSSParams.defaultValues("trailerField")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "hashAlgorithm":
          return new AlgorithmIdentifier({
            algorithmId: "1.3.14.3.2.26",
            // SHA-1
            algorithmParams: new Null()
          });

        case "maskGenAlgorithm":
          return new AlgorithmIdentifier({
            algorithmId: "1.2.840.113549.1.1.8",
            // MGF1
            algorithmParams: new AlgorithmIdentifier({
              algorithmId: "1.3.14.3.2.26",
              // SHA-1
              algorithmParams: new Null()
            }).toSchema()
          });

        case "saltLength":
          return 20;

        case "trailerField":
          return 1;

        default:
          throw new Error("Invalid member name for RSASSAPSSParams class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * RSASSA-PSS-params  ::=  Sequence  {
     *    hashAlgorithm      [0] HashAlgorithm DEFAULT sha1Identifier,
     *    maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1Identifier,
     *    saltLength         [2] Integer DEFAULT 20,
     *    trailerField       [3] Integer DEFAULT 1  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [hashAlgorithm]
       * @property {string} [maskGenAlgorithm]
       * @property {string} [saltLength]
       * @property {string} [trailerField]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          optional: true,
          value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          optional: true,
          value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          },
          optional: true,
          value: [new Integer({
            name: names.saltLength || ""
          })]
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 3 // [3]

          },
          optional: true,
          value: [new Integer({
            name: names.trailerField || ""
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["hashAlgorithm", "maskGenAlgorithm", "saltLength", "trailerField"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, RSASSAPSSParams.schema({
        names: {
          hashAlgorithm: {
            names: {
              blockName: "hashAlgorithm"
            }
          },
          maskGenAlgorithm: {
            names: {
              blockName: "maskGenAlgorithm"
            }
          },
          saltLength: "saltLength",
          trailerField: "trailerField"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RSASSAPSSParams"); //endregion
      //region Get internal properties from parsed schema

      if ("hashAlgorithm" in asn1.result) this.hashAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.hashAlgorithm
      });
      if ("maskGenAlgorithm" in asn1.result) this.maskGenAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.maskGenAlgorithm
      });
      if ("saltLength" in asn1.result) this.saltLength = asn1.result.saltLength.valueBlock.valueDec;
      if ("trailerField" in asn1.result) this.trailerField = asn1.result.trailerField.valueBlock.valueDec; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];

      if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues("hashAlgorithm"))) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [this.hashAlgorithm.toSchema()]
        }));
      }

      if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues("maskGenAlgorithm"))) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [this.maskGenAlgorithm.toSchema()]
        }));
      }

      if (this.saltLength !== RSASSAPSSParams.defaultValues("saltLength")) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          },
          value: [new Integer({
            value: this.saltLength
          })]
        }));
      }

      if (this.trailerField !== RSASSAPSSParams.defaultValues("trailerField")) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 3 // [3]

          },
          value: [new Integer({
            value: this.trailerField
          })]
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {};
      if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues("hashAlgorithm"))) object.hashAlgorithm = this.hashAlgorithm.toJSON();
      if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues("maskGenAlgorithm"))) object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
      if (this.saltLength !== RSASSAPSSParams.defaultValues("saltLength")) object.saltLength = this.saltLength;
      if (this.trailerField !== RSASSAPSSParams.defaultValues("trailerField")) object.trailerField = this.trailerField;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC2898
   */


  class PBKDF2Params {
    //**********************************************************************************

    /**
     * Constructor for PBKDF2Params class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Object}
       * @desc salt
       */
      this.salt = getParametersValue(parameters, "salt", PBKDF2Params.defaultValues("salt"));
      /**
       * @type {number}
       * @desc iterationCount
       */

      this.iterationCount = getParametersValue(parameters, "iterationCount", PBKDF2Params.defaultValues("iterationCount"));
      if ("keyLength" in parameters)
        /**
         * @type {number}
         * @desc keyLength
         */
        this.keyLength = getParametersValue(parameters, "keyLength", PBKDF2Params.defaultValues("keyLength"));
      if ("prf" in parameters)
        /**
         * @type {AlgorithmIdentifier}
         * @desc prf
         */
        this.prf = getParametersValue(parameters, "prf", PBKDF2Params.defaultValues("prf")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "salt":
          return {};

        case "iterationCount":
          return -1;

        case "keyLength":
          return 0;

        case "prf":
          return new AlgorithmIdentifier({
            algorithmId: "1.3.14.3.2.26",
            // SHA-1
            algorithmParams: new Null()
          });

        default:
          throw new Error("Invalid member name for PBKDF2Params class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PBKDF2-params ::= SEQUENCE {
     *    salt CHOICE {
     *        specified OCTET STRING,
     *        otherSource AlgorithmIdentifier },
     *  iterationCount INTEGER (1..MAX),
     *  keyLength INTEGER (1..MAX) OPTIONAL,
     *  prf AlgorithmIdentifier
     *    DEFAULT { algorithm hMAC-SHA1, parameters NULL } }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [saltPrimitive]
       * @property {string} [saltConstructed]
       * @property {string} [iterationCount]
       * @property {string} [keyLength]
       * @property {string} [prf]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Choice({
          value: [new OctetString({
            name: names.saltPrimitive || ""
          }), AlgorithmIdentifier.schema(names.saltConstructed || {})]
        }), new Integer({
          name: names.iterationCount || ""
        }), new Integer({
          name: names.keyLength || "",
          optional: true
        }), AlgorithmIdentifier.schema(names.prf || {
          names: {
            optional: true
          }
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["salt", "iterationCount", "keyLength", "prf"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PBKDF2Params.schema({
        names: {
          saltPrimitive: "salt",
          saltConstructed: {
            names: {
              blockName: "salt"
            }
          },
          iterationCount: "iterationCount",
          keyLength: "keyLength",
          prf: {
            names: {
              blockName: "prf",
              optional: true
            }
          }
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PBKDF2Params"); //endregion
      //region Get internal properties from parsed schema

      this.salt = asn1.result.salt;
      this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;
      if ("keyLength" in asn1.result) this.keyLength = asn1.result.keyLength.valueBlock.valueDec;
      if ("prf" in asn1.result) this.prf = new AlgorithmIdentifier({
        schema: asn1.result.prf
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence 
      var outputArray = [];
      outputArray.push(this.salt);
      outputArray.push(new Integer({
        value: this.iterationCount
      }));

      if ("keyLength" in this) {
        if (PBKDF2Params.defaultValues("keyLength") !== this.keyLength) outputArray.push(new Integer({
          value: this.keyLength
        }));
      }

      if ("prf" in this) {
        if (PBKDF2Params.defaultValues("prf").isEqual(this.prf) === false) outputArray.push(this.prf.toSchema());
      } //endregion 
      //region Construct and return new ASN.1 schema for this object 


      return new Sequence({
        value: outputArray
      }); //endregion 
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        salt: this.salt.toJSON(),
        iterationCount: this.iterationCount
      };

      if ("keyLength" in this) {
        if (PBKDF2Params.defaultValues("keyLength") !== this.keyLength) _object.keyLength = this.keyLength;
      }

      if ("prf" in this) {
        if (PBKDF2Params.defaultValues("prf").isEqual(this.prf) === false) _object.prf = this.prf.toJSON();
      }

      return _object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC2898
   */


  class PBES2Params {
    //**********************************************************************************

    /**
     * Constructor for PBES2Params class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {AlgorithmIdentifier}
       * @desc keyDerivationFunc
       */
      this.keyDerivationFunc = getParametersValue(parameters, "keyDerivationFunc", PBES2Params.defaultValues("keyDerivationFunc"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc encryptionScheme
       */

      this.encryptionScheme = getParametersValue(parameters, "encryptionScheme", PBES2Params.defaultValues("encryptionScheme")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "keyDerivationFunc":
          return new AlgorithmIdentifier();

        case "encryptionScheme":
          return new AlgorithmIdentifier();

        default:
          throw new Error("Invalid member name for PBES2Params class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PBES2-params ::= SEQUENCE {
     *    keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
     *    encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [keyDerivationFunc]
       * @property {string} [encryptionScheme]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [AlgorithmIdentifier.schema(names.keyDerivationFunc || {}), AlgorithmIdentifier.schema(names.encryptionScheme || {})]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["keyDerivationFunc", "encryptionScheme"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PBES2Params.schema({
        names: {
          keyDerivationFunc: {
            names: {
              blockName: "keyDerivationFunc"
            }
          },
          encryptionScheme: {
            names: {
              blockName: "encryptionScheme"
            }
          }
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PBES2Params"); //endregion
      //region Get internal properties from parsed schema

      this.keyDerivationFunc = new AlgorithmIdentifier({
        schema: asn1.result.keyDerivationFunc
      });
      this.encryptionScheme = new AlgorithmIdentifier({
        schema: asn1.result.encryptionScheme
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [this.keyDerivationFunc.toSchema(), this.encryptionScheme.toSchema()]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        keyDerivationFunc: this.keyDerivationFunc.toJSON(),
        encryptionScheme: this.encryptionScheme.toJSON()
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Making MAC key using algorithm described in B.2 of PKCS#12 standard.
   */


    makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount) {
    //region Initial variables
    var u;
    var v;
    var result = []; //endregion
    //region Get "u" and "v" values

    switch (hashAlgorithm.toUpperCase()) {
      case "SHA-1":
        u = 20; // 160

        v = 64; // 512

        break;

      case "SHA-256":
        u = 32; // 256

        v = 64; // 512

        break;

      case "SHA-384":
        u = 48; // 384

        v = 128; // 1024

        break;

      case "SHA-512":
        u = 64; // 512

        v = 128; // 1024

        break;

      default:
        throw new Error("Unsupported hashing algorithm");
    } //endregion
    //region Main algorithm making key
    //region Transform password to UTF-8 like string


    var passwordViewInitial = new Uint8Array(password);
    var passwordTransformed = new ArrayBuffer(password.byteLength * 2 + 2);
    var passwordTransformedView = new Uint8Array(passwordTransformed);

    for (var i = 0; i < passwordViewInitial.length; i++) {
      passwordTransformedView[i * 2] = 0x00;
      passwordTransformedView[i * 2 + 1] = passwordViewInitial[i];
    }

    passwordTransformedView[passwordTransformedView.length - 2] = 0x00;
    passwordTransformedView[passwordTransformedView.length - 1] = 0x00;
    password = passwordTransformed.slice(0); //endregion
    //region Construct a string D (the "diversifier") by concatenating v/8 copies of ID

    var D = new ArrayBuffer(v);
    var dView = new Uint8Array(D);

    for (var _i19 = 0; _i19 < D.byteLength; _i19++) {
      dView[_i19] = 3;
    } // The ID value equal to "3" for MACing (see B.3 of standard)
    //endregion
    //region Concatenate copies of the salt together to create a string S of length v * ceil(s / v) bytes (the final copy of the salt may be trunacted to create S)


    var saltLength = salt.byteLength;
    var sLen = v * Math.ceil(saltLength / v);
    var S = new ArrayBuffer(sLen);
    var sView = new Uint8Array(S);
    var saltView = new Uint8Array(salt);

    for (var _i20 = 0; _i20 < sLen; _i20++) {
      sView[_i20] = saltView[_i20 % saltLength];
    } //endregion
    //region Concatenate copies of the password together to create a string P of length v * ceil(p / v) bytes (the final copy of the password may be truncated to create P)


    var passwordLength = password.byteLength;
    var pLen = v * Math.ceil(passwordLength / v);
    var P = new ArrayBuffer(pLen);
    var pView = new Uint8Array(P);
    var passwordView = new Uint8Array(password);

    for (var _i21 = 0; _i21 < pLen; _i21++) {
      pView[_i21] = passwordView[_i21 % passwordLength];
    } //endregion
    //region Set I=S||P to be the concatenation of S and P


    var sPlusPLength = S.byteLength + P.byteLength;
    var I = new ArrayBuffer(sPlusPLength);
    var iView = new Uint8Array(I);
    iView.set(sView);
    iView.set(pView, sView.length); //endregion
    //region Set c=ceil(n / u)

    var c = Math.ceil((keyLength >> 3) / u); //endregion
    //region Initial variables

    var internalSequence = Promise.resolve(I); //endregion
    //region For i=1, 2, ..., c, do the following:

    for (var _i22 = 0; _i22 <= c; _i22++) {
      internalSequence = internalSequence.then(_I => {
        //region Create contecanetion of D and I
        var dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);
        var dAndIView = new Uint8Array(dAndI);
        dAndIView.set(dView);
        dAndIView.set(iView, dView.length); //endregion

        return dAndI;
      }); //region Make "iterationCount" rounds of hashing

      for (var j = 0; j < iterationCount; j++) {
        internalSequence = internalSequence.then(roundBuffer => cryptoEngine.digest({
          name: hashAlgorithm
        }, new Uint8Array(roundBuffer)));
      } //endregion


      internalSequence = internalSequence.then(roundBuffer => {
        //region Concatenate copies of Ai to create a string B of length v bits (the final copy of Ai may be truncated to create B)
        var B = new ArrayBuffer(v);
        var bView = new Uint8Array(B);

        for (var _j = 0; _j < B.byteLength; _j++) {
          bView[_j] = roundBuffer[_j % roundBuffer.length];
        } //endregion
        //region Make new I value


        var k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);
        var iRound = [];
        var sliceStart = 0;
        var sliceLength = v;

        for (var _j2 = 0; _j2 < k; _j2++) {
          var chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));
          sliceStart += v;
          if (sliceStart + v > I.byteLength) sliceLength = I.byteLength - sliceStart;
          var x = 0x1ff;

          for (var l = B.byteLength - 1; l >= 0; l--) {
            x >>= 8;
            x += bView[l] + chunk[l];
            chunk[l] = x & 0xff;
          }

          iRound.push(...chunk);
        }

        I = new ArrayBuffer(iRound.length);
        iView = new Uint8Array(I);
        iView.set(iRound); //endregion

        result.push(...new Uint8Array(roundBuffer));
        return I;
      });
    } //endregion
    //region Initialize final key


    internalSequence = internalSequence.then(() => {
      var resultBuffer = new ArrayBuffer(keyLength >> 3);
      var resultView = new Uint8Array(resultBuffer);
      resultView.set(new Uint8Array(result).slice(0, keyLength >> 3));
      return resultBuffer;
    }); //endregion
    //endregion

    return internalSequence;
  } //**************************************************************************************

  /**
   * Default cryptographic engine for Web Cryptography API
   */


  class CryptoEngine {
    //**********************************************************************************

    /**
     * Constructor for CryptoEngine class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Object}
       * @desc Usually here we are expecting "window.crypto" or an equivalent from custom "crypto engine"
       */
      this.crypto = getParametersValue(parameters, "crypto", {});
      /**
       * @type {Object}
       * @desc Usually here we are expecting "window.crypto.subtle" or an equivalent from custom "crypto engine"
       */

      this.subtle = getParametersValue(parameters, "subtle", {});
      /**
       * @type {string}
       * @desc Name of the "crypto engine"
       */

      this.name = getParametersValue(parameters, "name", ""); //endregion
    } //**********************************************************************************

    /**
     * Import WebCrypto keys from different formats
     * @param {string} format
     * @param {ArrayBuffer|Uint8Array} keyData
     * @param {Object} algorithm
     * @param {boolean} extractable
     * @param {Array} keyUsages
     * @returns {Promise}
     */


    importKey(format, keyData, algorithm, extractable, keyUsages) {
      //region Initial variables
      var jwk = {}; //endregion
      //region Change "keyData" type if needed

      if (keyData instanceof Uint8Array) keyData = keyData.buffer; //endregion

      switch (format.toLowerCase()) {
        case "raw":
          return this.subtle.importKey("raw", keyData, algorithm, extractable, keyUsages);

        case "spki":
          {
            var asn1 = fromBER(keyData);
            if (asn1.offset === -1) return Promise.reject("Incorrect keyData");
            var publicKeyInfo = new PublicKeyInfo();

            try {
              publicKeyInfo.fromSchema(asn1.result);
            } catch (ex) {
              return Promise.reject("Incorrect keyData");
            } // noinspection FallThroughInSwitchStatementJS


            switch (algorithm.name.toUpperCase()) {
              case "RSA-PSS":
                {
                  //region Get information about used hash  
                  switch (algorithm.hash.name.toUpperCase()) {
                    case "SHA-1":
                      jwk.alg = "PS1";
                      break;

                    case "SHA-256":
                      jwk.alg = "PS256";
                      break;

                    case "SHA-384":
                      jwk.alg = "PS384";
                      break;

                    case "SHA-512":
                      jwk.alg = "PS512";
                      break;

                    default:
                      return Promise.reject("Incorrect hash algorithm: ".concat(algorithm.hash.name.toUpperCase()));
                  } //endregion

                }
              // break omitted

              case "RSASSA-PKCS1-V1_5":
                {
                  keyUsages = ["verify"]; // Override existing keyUsages value since the key is a public key

                  jwk.kty = "RSA";
                  jwk.ext = extractable;
                  jwk.key_ops = keyUsages;
                  if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.113549.1.1.1") return Promise.reject("Incorrect public key algorithm: ".concat(publicKeyInfo.algorithm.algorithmId)); //region Get information about used hash  

                  if ("alg" in jwk === false) {
                    switch (algorithm.hash.name.toUpperCase()) {
                      case "SHA-1":
                        jwk.alg = "RS1";
                        break;

                      case "SHA-256":
                        jwk.alg = "RS256";
                        break;

                      case "SHA-384":
                        jwk.alg = "RS384";
                        break;

                      case "SHA-512":
                        jwk.alg = "RS512";
                        break;

                      default:
                        return Promise.reject("Incorrect hash algorithm: ".concat(algorithm.hash.name.toUpperCase()));
                    }
                  } //endregion
                  //region Create RSA Public Key elements


                  var publicKeyJSON = publicKeyInfo.toJSON();

                  for (var _i23 = 0, _Object$keys3 = Object.keys(publicKeyJSON); _i23 < _Object$keys3.length; _i23++) {
                    var key = _Object$keys3[_i23];
                    jwk[key] = publicKeyJSON[key];
                  } //endregion

                }
                break;

              case "ECDSA":
                keyUsages = ["verify"];
              // Override existing keyUsages value since the key is a public key
              // break omitted

              case "ECDH":
                {
                  //region Initial variables
                  jwk = {
                    kty: "EC",
                    ext: extractable,
                    key_ops: keyUsages
                  }; //endregion
                  //region Get information about algorithm

                  if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.10045.2.1") return Promise.reject("Incorrect public key algorithm: ".concat(publicKeyInfo.algorithm.algorithmId)); //endregion
                  //region Create ECDSA Public Key elements

                  var _publicKeyJSON = publicKeyInfo.toJSON();

                  for (var _i24 = 0, _Object$keys4 = Object.keys(_publicKeyJSON); _i24 < _Object$keys4.length; _i24++) {
                    var _key3 = _Object$keys4[_i24];
                    jwk[_key3] = _publicKeyJSON[_key3];
                  } //endregion

                }
                break;

              case "RSA-OAEP":
                {
                  jwk.kty = "RSA";
                  jwk.ext = extractable;
                  jwk.key_ops = keyUsages;
                  if (this.name.toLowerCase() === "safari") jwk.alg = "RSA-OAEP";else {
                    switch (algorithm.hash.name.toUpperCase()) {
                      case "SHA-1":
                        jwk.alg = "RSA-OAEP";
                        break;

                      case "SHA-256":
                        jwk.alg = "RSA-OAEP-256";
                        break;

                      case "SHA-384":
                        jwk.alg = "RSA-OAEP-384";
                        break;

                      case "SHA-512":
                        jwk.alg = "RSA-OAEP-512";
                        break;

                      default:
                        return Promise.reject("Incorrect hash algorithm: ".concat(algorithm.hash.name.toUpperCase()));
                    }
                  } //region Create ECDSA Public Key elements

                  var _publicKeyJSON2 = publicKeyInfo.toJSON();

                  for (var _i25 = 0, _Object$keys5 = Object.keys(_publicKeyJSON2); _i25 < _Object$keys5.length; _i25++) {
                    var _key4 = _Object$keys5[_i25];
                    jwk[_key4] = _publicKeyJSON2[_key4];
                  } //endregion

                }
                break;

              default:
                return Promise.reject("Incorrect algorithm name: ".concat(algorithm.name.toUpperCase()));
            }
          }
          break;

        case "pkcs8":
          {
            var privateKeyInfo = new PrivateKeyInfo(); //region Parse "PrivateKeyInfo" object

            var _asn = fromBER(keyData);

            if (_asn.offset === -1) return Promise.reject("Incorrect keyData");

            try {
              privateKeyInfo.fromSchema(_asn.result);
            } catch (ex) {
              return Promise.reject("Incorrect keyData");
            }

            if ("parsedKey" in privateKeyInfo === false) return Promise.reject("Incorrect keyData"); //endregion
            // noinspection FallThroughInSwitchStatementJS
            // noinspection FallThroughInSwitchStatementJS

            switch (algorithm.name.toUpperCase()) {
              case "RSA-PSS":
                {
                  //region Get information about used hash  
                  switch (algorithm.hash.name.toUpperCase()) {
                    case "SHA-1":
                      jwk.alg = "PS1";
                      break;

                    case "SHA-256":
                      jwk.alg = "PS256";
                      break;

                    case "SHA-384":
                      jwk.alg = "PS384";
                      break;

                    case "SHA-512":
                      jwk.alg = "PS512";
                      break;

                    default:
                      return Promise.reject("Incorrect hash algorithm: ".concat(algorithm.hash.name.toUpperCase()));
                  } //endregion

                }
              // break omitted

              case "RSASSA-PKCS1-V1_5":
                {
                  keyUsages = ["sign"]; // Override existing keyUsages value since the key is a private key

                  jwk.kty = "RSA";
                  jwk.ext = extractable;
                  jwk.key_ops = keyUsages; //region Get information about used hash  

                  if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.113549.1.1.1") return Promise.reject("Incorrect private key algorithm: ".concat(privateKeyInfo.privateKeyAlgorithm.algorithmId)); //endregion
                  //region Get information about used hash  

                  if ("alg" in jwk === false) {
                    switch (algorithm.hash.name.toUpperCase()) {
                      case "SHA-1":
                        jwk.alg = "RS1";
                        break;

                      case "SHA-256":
                        jwk.alg = "RS256";
                        break;

                      case "SHA-384":
                        jwk.alg = "RS384";
                        break;

                      case "SHA-512":
                        jwk.alg = "RS512";
                        break;

                      default:
                        return Promise.reject("Incorrect hash algorithm: ".concat(algorithm.hash.name.toUpperCase()));
                    }
                  } //endregion
                  //region Create RSA Private Key elements


                  var privateKeyJSON = privateKeyInfo.toJSON();

                  for (var _i26 = 0, _Object$keys6 = Object.keys(privateKeyJSON); _i26 < _Object$keys6.length; _i26++) {
                    var _key5 = _Object$keys6[_i26];
                    jwk[_key5] = privateKeyJSON[_key5];
                  } //endregion

                }
                break;

              case "ECDSA":
                keyUsages = ["sign"];
              // Override existing keyUsages value since the key is a private key
              // break omitted

              case "ECDH":
                {
                  //region Initial variables
                  jwk = {
                    kty: "EC",
                    ext: extractable,
                    key_ops: keyUsages
                  }; //endregion
                  //region Get information about used hash  

                  if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.10045.2.1") return Promise.reject("Incorrect algorithm: ".concat(privateKeyInfo.privateKeyAlgorithm.algorithmId)); //endregion
                  //region Create ECDSA Private Key elements

                  var _privateKeyJSON = privateKeyInfo.toJSON();

                  for (var _i27 = 0, _Object$keys7 = Object.keys(_privateKeyJSON); _i27 < _Object$keys7.length; _i27++) {
                    var _key6 = _Object$keys7[_i27];
                    jwk[_key6] = _privateKeyJSON[_key6];
                  } //endregion

                }
                break;

              case "RSA-OAEP":
                {
                  jwk.kty = "RSA";
                  jwk.ext = extractable;
                  jwk.key_ops = keyUsages; //region Get information about used hash  

                  if (this.name.toLowerCase() === "safari") jwk.alg = "RSA-OAEP";else {
                    switch (algorithm.hash.name.toUpperCase()) {
                      case "SHA-1":
                        jwk.alg = "RSA-OAEP";
                        break;

                      case "SHA-256":
                        jwk.alg = "RSA-OAEP-256";
                        break;

                      case "SHA-384":
                        jwk.alg = "RSA-OAEP-384";
                        break;

                      case "SHA-512":
                        jwk.alg = "RSA-OAEP-512";
                        break;

                      default:
                        return Promise.reject("Incorrect hash algorithm: ".concat(algorithm.hash.name.toUpperCase()));
                    }
                  } //endregion
                  //region Create RSA Private Key elements

                  var _privateKeyJSON2 = privateKeyInfo.toJSON();

                  for (var _i28 = 0, _Object$keys8 = Object.keys(_privateKeyJSON2); _i28 < _Object$keys8.length; _i28++) {
                    var _key7 = _Object$keys8[_i28];
                    jwk[_key7] = _privateKeyJSON2[_key7];
                  } //endregion

                }
                break;

              default:
                return Promise.reject("Incorrect algorithm name: ".concat(algorithm.name.toUpperCase()));
            }
          }
          break;

        case "jwk":
          jwk = keyData;
          break;

        default:
          return Promise.reject("Incorrect format: ".concat(format));
      } //region Special case for Safari browser (since its acting not as WebCrypto standard describes)


      if (this.name.toLowerCase() === "safari") {
        // Try to use both ways - import using ArrayBuffer and pure JWK (for Safari Technology Preview)
        return Promise.resolve().then(() => this.subtle.importKey("jwk", stringToArrayBuffer(JSON.stringify(jwk)), algorithm, extractable, keyUsages)).then(result => result, () => this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages));
      } //endregion


      return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
    } //**********************************************************************************

    /**
     * Export WebCrypto keys to different formats
     * @param {string} format
     * @param {Object} key
     * @returns {Promise}
     */


    exportKey(format, key) {
      var sequence = this.subtle.exportKey("jwk", key); //region Currently Safari returns ArrayBuffer as JWK thus we need an additional transformation

      if (this.name.toLowerCase() === "safari") {
        sequence = sequence.then(result => {
          // Some additional checks for Safari Technology Preview
          if (result instanceof ArrayBuffer) return JSON.parse(arrayBufferToString(result));
          return result;
        });
      } //endregion


      switch (format.toLowerCase()) {
        case "raw":
          return this.subtle.exportKey("raw", key);

        case "spki":
          sequence = sequence.then(result => {
            var publicKeyInfo = new PublicKeyInfo();

            try {
              publicKeyInfo.fromJSON(result);
            } catch (ex) {
              return Promise.reject("Incorrect key data");
            }

            return publicKeyInfo.toSchema().toBER(false);
          });
          break;

        case "pkcs8":
          sequence = sequence.then(result => {
            var privateKeyInfo = new PrivateKeyInfo();

            try {
              privateKeyInfo.fromJSON(result);
            } catch (ex) {
              return Promise.reject("Incorrect key data");
            }

            return privateKeyInfo.toSchema().toBER(false);
          });
          break;

        case "jwk":
          break;

        default:
          return Promise.reject("Incorrect format: ".concat(format));
      }

      return sequence;
    } //**********************************************************************************

    /**
     * Convert WebCrypto keys between different export formats
     * @param {string} inputFormat
     * @param {string} outputFormat
     * @param {ArrayBuffer|Object} keyData
     * @param {Object} algorithm
     * @param {boolean} extractable
     * @param {Array} keyUsages
     * @returns {Promise}
     */


    convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {
      switch (inputFormat.toLowerCase()) {
        case "raw":
          switch (outputFormat.toLowerCase()) {
            case "raw":
              return Promise.resolve(keyData);

            case "spki":
              return Promise.resolve().then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("spki", result));

            case "pkcs8":
              return Promise.resolve().then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("pkcs8", result));

            case "jwk":
              return Promise.resolve().then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("jwk", result));

            default:
              return Promise.reject("Incorrect outputFormat: ".concat(outputFormat));
          }

        case "spki":
          switch (outputFormat.toLowerCase()) {
            case "raw":
              return Promise.resolve().then(() => this.importKey("spki", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("raw", result));

            case "spki":
              return Promise.resolve(keyData);

            case "pkcs8":
              return Promise.reject("Impossible to convert between SPKI/PKCS8");

            case "jwk":
              return Promise.resolve().then(() => this.importKey("spki", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("jwk", result));

            default:
              return Promise.reject("Incorrect outputFormat: ".concat(outputFormat));
          }

        case "pkcs8":
          switch (outputFormat.toLowerCase()) {
            case "raw":
              return Promise.resolve().then(() => this.importKey("pkcs8", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("raw", result));

            case "spki":
              return Promise.reject("Impossible to convert between SPKI/PKCS8");

            case "pkcs8":
              return Promise.resolve(keyData);

            case "jwk":
              return Promise.resolve().then(() => this.importKey("pkcs8", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("jwk", result));

            default:
              return Promise.reject("Incorrect outputFormat: ".concat(outputFormat));
          }

        case "jwk":
          switch (outputFormat.toLowerCase()) {
            case "raw":
              return Promise.resolve().then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("raw", result));

            case "spki":
              return Promise.resolve().then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("spki", result));

            case "pkcs8":
              return Promise.resolve().then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey("pkcs8", result));

            case "jwk":
              return Promise.resolve(keyData);

            default:
              return Promise.reject("Incorrect outputFormat: ".concat(outputFormat));
          }

        default:
          return Promise.reject("Incorrect inputFormat: ".concat(inputFormat));
      }
    } //**********************************************************************************

    /**
     * Wrapper for standard   "encrypt"
     * @param args
     * @returns {Promise}
     */


    encrypt() {
      return this.subtle.encrypt(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "decrypt"
     * @param args
     * @returns {Promise}
     */


    decrypt() {
      return this.subtle.decrypt(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "sign"
     * @param args
     * @returns {Promise}
     */


    sign() {
      return this.subtle.sign(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "verify"
     * @param args
     * @returns {Promise}
     */


    verify() {
      return this.subtle.verify(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "digest"
     * @param args
     * @returns {Promise}
     */


    digest() {
      return this.subtle.digest(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "generateKey"
     * @param args
     * @returns {Promise}
     */


    generateKey() {
      return this.subtle.generateKey(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "deriveKey"
     * @param args
     * @returns {Promise}
     */


    deriveKey() {
      return this.subtle.deriveKey(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "deriveBits"
     * @param args
     * @returns {Promise}
     */


    deriveBits() {
      return this.subtle.deriveBits(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "wrapKey"
     * @param args
     * @returns {Promise}
     */


    wrapKey() {
      return this.subtle.wrapKey(...arguments);
    } //**********************************************************************************

    /**
     * Wrapper for standard   "unwrapKey"
     * @param args
     * @returns {Promise}
     */


    unwrapKey() {
      return this.subtle.unwrapKey(...arguments);
    } //**********************************************************************************

    /**
     * Initialize input Uint8Array by random values (with help from current "crypto engine")
     * @param {!Uint8Array} view
     * @returns {*}
     */


    getRandomValues(view) {
      if ("getRandomValues" in this.crypto === false) throw new Error("No support for getRandomValues");
      return this.crypto.getRandomValues(view);
    } //**********************************************************************************

    /**
     * Get WebCrypto algorithm by wel-known OID
     * @param {string} oid well-known OID to search for
     * @returns {Object}
     */


    getAlgorithmByOID(oid) {
      switch (oid) {
        case "1.2.840.113549.1.1.1":
        case "1.2.840.113549.1.1.5":
          return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
              name: "SHA-1"
            }
          };

        case "1.2.840.113549.1.1.11":
          return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
              name: "SHA-256"
            }
          };

        case "1.2.840.113549.1.1.12":
          return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
              name: "SHA-384"
            }
          };

        case "1.2.840.113549.1.1.13":
          return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
              name: "SHA-512"
            }
          };

        case "1.2.840.113549.1.1.10":
          return {
            name: "RSA-PSS"
          };

        case "1.2.840.113549.1.1.7":
          return {
            name: "RSA-OAEP"
          };

        case "1.2.840.10045.2.1":
        case "1.2.840.10045.4.1":
          return {
            name: "ECDSA",
            hash: {
              name: "SHA-1"
            }
          };

        case "1.2.840.10045.4.3.2":
          return {
            name: "ECDSA",
            hash: {
              name: "SHA-256"
            }
          };

        case "1.2.840.10045.4.3.3":
          return {
            name: "ECDSA",
            hash: {
              name: "SHA-384"
            }
          };

        case "1.2.840.10045.4.3.4":
          return {
            name: "ECDSA",
            hash: {
              name: "SHA-512"
            }
          };

        case "1.3.133.16.840.63.0.2":
          return {
            name: "ECDH",
            kdf: "SHA-1"
          };

        case "1.3.132.1.11.1":
          return {
            name: "ECDH",
            kdf: "SHA-256"
          };

        case "1.3.132.1.11.2":
          return {
            name: "ECDH",
            kdf: "SHA-384"
          };

        case "1.3.132.1.11.3":
          return {
            name: "ECDH",
            kdf: "SHA-512"
          };

        case "2.16.840.1.101.3.4.1.2":
          return {
            name: "AES-CBC",
            length: 128
          };

        case "2.16.840.1.101.3.4.1.22":
          return {
            name: "AES-CBC",
            length: 192
          };

        case "2.16.840.1.101.3.4.1.42":
          return {
            name: "AES-CBC",
            length: 256
          };

        case "2.16.840.1.101.3.4.1.6":
          return {
            name: "AES-GCM",
            length: 128
          };

        case "2.16.840.1.101.3.4.1.26":
          return {
            name: "AES-GCM",
            length: 192
          };

        case "2.16.840.1.101.3.4.1.46":
          return {
            name: "AES-GCM",
            length: 256
          };

        case "2.16.840.1.101.3.4.1.4":
          return {
            name: "AES-CFB",
            length: 128
          };

        case "2.16.840.1.101.3.4.1.24":
          return {
            name: "AES-CFB",
            length: 192
          };

        case "2.16.840.1.101.3.4.1.44":
          return {
            name: "AES-CFB",
            length: 256
          };

        case "2.16.840.1.101.3.4.1.5":
          return {
            name: "AES-KW",
            length: 128
          };

        case "2.16.840.1.101.3.4.1.25":
          return {
            name: "AES-KW",
            length: 192
          };

        case "2.16.840.1.101.3.4.1.45":
          return {
            name: "AES-KW",
            length: 256
          };

        case "1.2.840.113549.2.7":
          return {
            name: "HMAC",
            hash: {
              name: "SHA-1"
            }
          };

        case "1.2.840.113549.2.9":
          return {
            name: "HMAC",
            hash: {
              name: "SHA-256"
            }
          };

        case "1.2.840.113549.2.10":
          return {
            name: "HMAC",
            hash: {
              name: "SHA-384"
            }
          };

        case "1.2.840.113549.2.11":
          return {
            name: "HMAC",
            hash: {
              name: "SHA-512"
            }
          };

        case "1.2.840.113549.1.9.16.3.5":
          return {
            name: "DH"
          };

        case "1.3.14.3.2.26":
          return {
            name: "SHA-1"
          };

        case "2.16.840.1.101.3.4.2.1":
          return {
            name: "SHA-256"
          };

        case "2.16.840.1.101.3.4.2.2":
          return {
            name: "SHA-384"
          };

        case "2.16.840.1.101.3.4.2.3":
          return {
            name: "SHA-512"
          };

        case "1.2.840.113549.1.5.12":
          return {
            name: "PBKDF2"
          };
        //region Special case - OIDs for ECC curves

        case "1.2.840.10045.3.1.7":
          return {
            name: "P-256"
          };

        case "1.3.132.0.34":
          return {
            name: "P-384"
          };

        case "1.3.132.0.35":
          return {
            name: "P-521"
          };
        //endregion

        default:
      }

      return {};
    } //**********************************************************************************

    /**
     * Get OID for each specific algorithm
     * @param {Object} algorithm
     * @returns {string}
     */


    getOIDByAlgorithm(algorithm) {
      var result = "";

      switch (algorithm.name.toUpperCase()) {
        case "RSASSA-PKCS1-V1_5":
          switch (algorithm.hash.name.toUpperCase()) {
            case "SHA-1":
              result = "1.2.840.113549.1.1.5";
              break;

            case "SHA-256":
              result = "1.2.840.113549.1.1.11";
              break;

            case "SHA-384":
              result = "1.2.840.113549.1.1.12";
              break;

            case "SHA-512":
              result = "1.2.840.113549.1.1.13";
              break;

            default:
          }

          break;

        case "RSA-PSS":
          result = "1.2.840.113549.1.1.10";
          break;

        case "RSA-OAEP":
          result = "1.2.840.113549.1.1.7";
          break;

        case "ECDSA":
          switch (algorithm.hash.name.toUpperCase()) {
            case "SHA-1":
              result = "1.2.840.10045.4.1";
              break;

            case "SHA-256":
              result = "1.2.840.10045.4.3.2";
              break;

            case "SHA-384":
              result = "1.2.840.10045.4.3.3";
              break;

            case "SHA-512":
              result = "1.2.840.10045.4.3.4";
              break;

            default:
          }

          break;

        case "ECDH":
          switch (algorithm.kdf.toUpperCase()) {
            // Non-standard addition - hash algorithm of KDF  
            case "SHA-1":
              result = "1.3.133.16.840.63.0.2"; // dhSinglePass-stdDH-sha1kdf-scheme

              break;

            case "SHA-256":
              result = "1.3.132.1.11.1"; // dhSinglePass-stdDH-sha256kdf-scheme

              break;

            case "SHA-384":
              result = "1.3.132.1.11.2"; // dhSinglePass-stdDH-sha384kdf-scheme

              break;

            case "SHA-512":
              result = "1.3.132.1.11.3"; // dhSinglePass-stdDH-sha512kdf-scheme

              break;

            default:
          }

          break;

        case "AES-CTR":
          break;

        case "AES-CBC":
          switch (algorithm.length) {
            case 128:
              result = "2.16.840.1.101.3.4.1.2";
              break;

            case 192:
              result = "2.16.840.1.101.3.4.1.22";
              break;

            case 256:
              result = "2.16.840.1.101.3.4.1.42";
              break;

            default:
          }

          break;

        case "AES-CMAC":
          break;

        case "AES-GCM":
          switch (algorithm.length) {
            case 128:
              result = "2.16.840.1.101.3.4.1.6";
              break;

            case 192:
              result = "2.16.840.1.101.3.4.1.26";
              break;

            case 256:
              result = "2.16.840.1.101.3.4.1.46";
              break;

            default:
          }

          break;

        case "AES-CFB":
          switch (algorithm.length) {
            case 128:
              result = "2.16.840.1.101.3.4.1.4";
              break;

            case 192:
              result = "2.16.840.1.101.3.4.1.24";
              break;

            case 256:
              result = "2.16.840.1.101.3.4.1.44";
              break;

            default:
          }

          break;

        case "AES-KW":
          switch (algorithm.length) {
            case 128:
              result = "2.16.840.1.101.3.4.1.5";
              break;

            case 192:
              result = "2.16.840.1.101.3.4.1.25";
              break;

            case 256:
              result = "2.16.840.1.101.3.4.1.45";
              break;

            default:
          }

          break;

        case "HMAC":
          switch (algorithm.hash.name.toUpperCase()) {
            case "SHA-1":
              result = "1.2.840.113549.2.7";
              break;

            case "SHA-256":
              result = "1.2.840.113549.2.9";
              break;

            case "SHA-384":
              result = "1.2.840.113549.2.10";
              break;

            case "SHA-512":
              result = "1.2.840.113549.2.11";
              break;

            default:
          }

          break;

        case "DH":
          result = "1.2.840.113549.1.9.16.3.5";
          break;

        case "SHA-1":
          result = "1.3.14.3.2.26";
          break;

        case "SHA-256":
          result = "2.16.840.1.101.3.4.2.1";
          break;

        case "SHA-384":
          result = "2.16.840.1.101.3.4.2.2";
          break;

        case "SHA-512":
          result = "2.16.840.1.101.3.4.2.3";
          break;

        case "CONCAT":
          break;

        case "HKDF":
          break;

        case "PBKDF2":
          result = "1.2.840.113549.1.5.12";
          break;
        //region Special case - OIDs for ECC curves

        case "P-256":
          result = "1.2.840.10045.3.1.7";
          break;

        case "P-384":
          result = "1.3.132.0.34";
          break;

        case "P-521":
          result = "1.3.132.0.35";
          break;
        //endregion

        default:
      }

      return result;
    } //**********************************************************************************

    /**
     * Get default algorithm parameters for each kind of operation
     * @param {string} algorithmName Algorithm name to get common parameters for
     * @param {string} operation Kind of operation: "sign", "encrypt", "generatekey", "importkey", "exportkey", "verify"
     * @returns {*}
     */


    getAlgorithmParameters(algorithmName, operation) {
      var result = {
        algorithm: {},
        usages: []
      };

      switch (algorithmName.toUpperCase()) {
        case "RSASSA-PKCS1-V1_5":
          switch (operation.toLowerCase()) {
            case "generatekey":
              result = {
                algorithm: {
                  name: "RSASSA-PKCS1-v1_5",
                  modulusLength: 2048,
                  publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                  hash: {
                    name: "SHA-256"
                  }
                },
                usages: ["sign", "verify"]
              };
              break;

            case "verify":
            case "sign":
            case "importkey":
              result = {
                algorithm: {
                  name: "RSASSA-PKCS1-v1_5",
                  hash: {
                    name: "SHA-256"
                  }
                },
                usages: ["verify"] // For importKey("pkcs8") usage must be "sign" only

              };
              break;

            case "exportkey":
            default:
              return {
                algorithm: {
                  name: "RSASSA-PKCS1-v1_5"
                },
                usages: []
              };
          }

          break;

        case "RSA-PSS":
          switch (operation.toLowerCase()) {
            case "sign":
            case "verify":
              result = {
                algorithm: {
                  name: "RSA-PSS",
                  hash: {
                    name: "SHA-1"
                  },
                  saltLength: 20
                },
                usages: ["sign", "verify"]
              };
              break;

            case "generatekey":
              result = {
                algorithm: {
                  name: "RSA-PSS",
                  modulusLength: 2048,
                  publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                  hash: {
                    name: "SHA-1"
                  }
                },
                usages: ["sign", "verify"]
              };
              break;

            case "importkey":
              result = {
                algorithm: {
                  name: "RSA-PSS",
                  hash: {
                    name: "SHA-1"
                  }
                },
                usages: ["verify"] // For importKey("pkcs8") usage must be "sign" only

              };
              break;

            case "exportkey":
            default:
              return {
                algorithm: {
                  name: "RSA-PSS"
                },
                usages: []
              };
          }

          break;

        case "RSA-OAEP":
          switch (operation.toLowerCase()) {
            case "encrypt":
            case "decrypt":
              result = {
                algorithm: {
                  name: "RSA-OAEP"
                },
                usages: ["encrypt", "decrypt"]
              };
              break;

            case "generatekey":
              result = {
                algorithm: {
                  name: "RSA-OAEP",
                  modulusLength: 2048,
                  publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                  hash: {
                    name: "SHA-256"
                  }
                },
                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
              };
              break;

            case "importkey":
              result = {
                algorithm: {
                  name: "RSA-OAEP",
                  hash: {
                    name: "SHA-256"
                  }
                },
                usages: ["encrypt"] // encrypt for "spki" and decrypt for "pkcs8"

              };
              break;

            case "exportkey":
            default:
              return {
                algorithm: {
                  name: "RSA-OAEP"
                },
                usages: []
              };
          }

          break;

        case "ECDSA":
          switch (operation.toLowerCase()) {
            case "generatekey":
              result = {
                algorithm: {
                  name: "ECDSA",
                  namedCurve: "P-256"
                },
                usages: ["sign", "verify"]
              };
              break;

            case "importkey":
              result = {
                algorithm: {
                  name: "ECDSA",
                  namedCurve: "P-256"
                },
                usages: ["verify"] // "sign" for "pkcs8"

              };
              break;

            case "verify":
            case "sign":
              result = {
                algorithm: {
                  name: "ECDSA",
                  hash: {
                    name: "SHA-256"
                  }
                },
                usages: ["sign"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "ECDSA"
                },
                usages: []
              };
          }

          break;

        case "ECDH":
          switch (operation.toLowerCase()) {
            case "exportkey":
            case "importkey":
            case "generatekey":
              result = {
                algorithm: {
                  name: "ECDH",
                  namedCurve: "P-256"
                },
                usages: ["deriveKey", "deriveBits"]
              };
              break;

            case "derivekey":
            case "derivebits":
              result = {
                algorithm: {
                  name: "ECDH",
                  namedCurve: "P-256",
                  public: [] // Must be a "publicKey"

                },
                usages: ["encrypt", "decrypt"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "ECDH"
                },
                usages: []
              };
          }

          break;

        case "AES-CTR":
          switch (operation.toLowerCase()) {
            case "importkey":
            case "exportkey":
            case "generatekey":
              result = {
                algorithm: {
                  name: "AES-CTR",
                  length: 256
                },
                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
              };
              break;

            case "decrypt":
            case "encrypt":
              result = {
                algorithm: {
                  name: "AES-CTR",
                  counter: new Uint8Array(16),
                  length: 10
                },
                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "AES-CTR"
                },
                usages: []
              };
          }

          break;

        case "AES-CBC":
          switch (operation.toLowerCase()) {
            case "importkey":
            case "exportkey":
            case "generatekey":
              result = {
                algorithm: {
                  name: "AES-CBC",
                  length: 256
                },
                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
              };
              break;

            case "decrypt":
            case "encrypt":
              result = {
                algorithm: {
                  name: "AES-CBC",
                  iv: this.getRandomValues(new Uint8Array(16)) // For "decrypt" the value should be replaced with value got on "encrypt" step

                },
                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "AES-CBC"
                },
                usages: []
              };
          }

          break;

        case "AES-GCM":
          switch (operation.toLowerCase()) {
            case "importkey":
            case "exportkey":
            case "generatekey":
              result = {
                algorithm: {
                  name: "AES-GCM",
                  length: 256
                },
                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
              };
              break;

            case "decrypt":
            case "encrypt":
              result = {
                algorithm: {
                  name: "AES-GCM",
                  iv: this.getRandomValues(new Uint8Array(16)) // For "decrypt" the value should be replaced with value got on "encrypt" step

                },
                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "AES-GCM"
                },
                usages: []
              };
          }

          break;

        case "AES-KW":
          switch (operation.toLowerCase()) {
            case "importkey":
            case "exportkey":
            case "generatekey":
            case "wrapkey":
            case "unwrapkey":
              result = {
                algorithm: {
                  name: "AES-KW",
                  length: 256
                },
                usages: ["wrapKey", "unwrapKey"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "AES-KW"
                },
                usages: []
              };
          }

          break;

        case "HMAC":
          switch (operation.toLowerCase()) {
            case "sign":
            case "verify":
              result = {
                algorithm: {
                  name: "HMAC"
                },
                usages: ["sign", "verify"]
              };
              break;

            case "importkey":
            case "exportkey":
            case "generatekey":
              result = {
                algorithm: {
                  name: "HMAC",
                  length: 32,
                  hash: {
                    name: "SHA-256"
                  }
                },
                usages: ["sign", "verify"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "HMAC"
                },
                usages: []
              };
          }

          break;

        case "HKDF":
          switch (operation.toLowerCase()) {
            case "derivekey":
              result = {
                algorithm: {
                  name: "HKDF",
                  hash: "SHA-256",
                  salt: new Uint8Array([]),
                  info: new Uint8Array([])
                },
                usages: ["encrypt", "decrypt"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "HKDF"
                },
                usages: []
              };
          }

          break;

        case "PBKDF2":
          switch (operation.toLowerCase()) {
            case "derivekey":
              result = {
                algorithm: {
                  name: "PBKDF2",
                  hash: {
                    name: "SHA-256"
                  },
                  salt: new Uint8Array([]),
                  iterations: 10000
                },
                usages: ["encrypt", "decrypt"]
              };
              break;

            default:
              return {
                algorithm: {
                  name: "PBKDF2"
                },
                usages: []
              };
          }

          break;

        default:
      }

      return result;
    } //**********************************************************************************

    /**
     * Getting hash algorithm by signature algorithm
     * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm
     * @returns {string}
     */


    getHashAlgorithm(signatureAlgorithm) {
      var result = "";

      switch (signatureAlgorithm.algorithmId) {
        case "1.2.840.10045.4.1": // ecdsa-with-SHA1

        case "1.2.840.113549.1.1.5":
          result = "SHA-1";
          break;

        case "1.2.840.10045.4.3.2": // ecdsa-with-SHA256

        case "1.2.840.113549.1.1.11":
          result = "SHA-256";
          break;

        case "1.2.840.10045.4.3.3": // ecdsa-with-SHA384

        case "1.2.840.113549.1.1.12":
          result = "SHA-384";
          break;

        case "1.2.840.10045.4.3.4": // ecdsa-with-SHA512

        case "1.2.840.113549.1.1.13":
          result = "SHA-512";
          break;

        case "1.2.840.113549.1.1.10":
          // RSA-PSS
          {
            try {
              var params = new RSASSAPSSParams({
                schema: signatureAlgorithm.algorithmParams
              });

              if ("hashAlgorithm" in params) {
                var algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
                if ("name" in algorithm === false) return "";
                result = algorithm.name;
              } else result = "SHA-1";
            } catch (ex) {}
          }
          break;

        default:
      }

      return result;
    } //**********************************************************************************

    /**
     * Specialized   encrypting "EncryptedContentInfo" object using parameters
     * @param {Object} parameters
     * @returns {Promise}
     */


    encryptEncryptedContentInfo(parameters) {
      //region Check for input parameters
      if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
      if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
      if ("contentEncryptionAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentEncryptionAlgorithm\"");
      if ("hmacHashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"hmacHashAlgorithm\"");
      if ("iterationCount" in parameters === false) return Promise.reject("Absent mandatory parameter \"iterationCount\"");
      if ("contentToEncrypt" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentToEncrypt\"");
      if ("contentType" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentType\"");
      var contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm);
      if (contentEncryptionOID === "") return Promise.reject("Wrong \"contentEncryptionAlgorithm\" value");
      var pbkdf2OID = this.getOIDByAlgorithm({
        name: "PBKDF2"
      });
      if (pbkdf2OID === "") return Promise.reject("Can not find OID for PBKDF2");
      var hmacOID = this.getOIDByAlgorithm({
        name: "HMAC",
        hash: {
          name: parameters.hmacHashAlgorithm
        }
      });
      if (hmacOID === "") return Promise.reject("Incorrect value for \"hmacHashAlgorithm\": ".concat(parameters.hmacHashAlgorithm)); //endregion
      //region Initial variables

      var sequence = Promise.resolve();
      var ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long

      var ivView = new Uint8Array(ivBuffer);
      this.getRandomValues(ivView);
      var saltBuffer = new ArrayBuffer(64);
      var saltView = new Uint8Array(saltBuffer);
      this.getRandomValues(saltView);
      var contentView = new Uint8Array(parameters.contentToEncrypt);
      var pbkdf2Params = new PBKDF2Params({
        salt: new OctetString({
          valueHex: saltBuffer
        }),
        iterationCount: parameters.iterationCount,
        prf: new AlgorithmIdentifier({
          algorithmId: hmacOID,
          algorithmParams: new Null()
        })
      }); //endregion
      //region Derive PBKDF2 key from "password" buffer

      sequence = sequence.then(() => {
        var passwordView = new Uint8Array(parameters.password);
        return this.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
      }, error => Promise.reject(error)); //endregion
      //region Derive key for "contentEncryptionAlgorithm"

      sequence = sequence.then(result => this.deriveKey({
        name: "PBKDF2",
        hash: {
          name: parameters.hmacHashAlgorithm
        },
        salt: saltView,
        iterations: parameters.iterationCount
      }, result, parameters.contentEncryptionAlgorithm, false, ["encrypt"]), error => Promise.reject(error)); //endregion
      //region Encrypt content

      sequence = sequence.then(result => this.encrypt({
        name: parameters.contentEncryptionAlgorithm.name,
        iv: ivView
      }, result, contentView), error => Promise.reject(error)); //endregion
      //region Store all parameters in EncryptedData object

      sequence = sequence.then(result => {
        var pbes2Parameters = new PBES2Params({
          keyDerivationFunc: new AlgorithmIdentifier({
            algorithmId: pbkdf2OID,
            algorithmParams: pbkdf2Params.toSchema()
          }),
          encryptionScheme: new AlgorithmIdentifier({
            algorithmId: contentEncryptionOID,
            algorithmParams: new OctetString({
              valueHex: ivBuffer
            })
          })
        });
        return new EncryptedContentInfo({
          contentType: parameters.contentType,
          contentEncryptionAlgorithm: new AlgorithmIdentifier({
            algorithmId: "1.2.840.113549.1.5.13",
            // pkcs5PBES2
            algorithmParams: pbes2Parameters.toSchema()
          }),
          encryptedContent: new OctetString({
            valueHex: result
          })
        });
      }, error => Promise.reject(error)); //endregion

      return sequence;
    } //**********************************************************************************

    /**
     * Decrypt data stored in "EncryptedContentInfo" object using parameters
     * @param parameters
     * @return {Promise}
     */


    decryptEncryptedContentInfo(parameters) {
      //region Check for input parameters
      if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
      if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
      if ("encryptedContentInfo" in parameters === false) return Promise.reject("Absent mandatory parameter \"encryptedContentInfo\"");
      if (parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== "1.2.840.113549.1.5.13") // pkcs5PBES2
        return Promise.reject("Unknown \"contentEncryptionAlgorithm\": ".concat(parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)); //endregion
      //region Initial variables

      var sequence = Promise.resolve();
      var pbes2Parameters;

      try {
        pbes2Parameters = new PBES2Params({
          schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams
        });
      } catch (ex) {
        return Promise.reject("Incorrectly encoded \"pbes2Parameters\"");
      }

      var pbkdf2Params;

      try {
        pbkdf2Params = new PBKDF2Params({
          schema: pbes2Parameters.keyDerivationFunc.algorithmParams
        });
      } catch (ex) {
        return Promise.reject("Incorrectly encoded \"pbkdf2Params\"");
      }

      var contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId);
      if ("name" in contentEncryptionAlgorithm === false) return Promise.reject("Incorrect OID for \"contentEncryptionAlgorithm\": ".concat(pbes2Parameters.encryptionScheme.algorithmId));
      var ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
      var ivView = new Uint8Array(ivBuffer);
      var saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
      var saltView = new Uint8Array(saltBuffer);
      var iterationCount = pbkdf2Params.iterationCount;
      var hmacHashAlgorithm = "SHA-1";

      if ("prf" in pbkdf2Params) {
        var algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
        if ("name" in algorithm === false) return Promise.reject("Incorrect OID for HMAC hash algorithm");
        hmacHashAlgorithm = algorithm.hash.name;
      } //endregion
      //region Derive PBKDF2 key from "password" buffer


      sequence = sequence.then(() => this.importKey("raw", parameters.password, "PBKDF2", false, ["deriveKey"]), error => Promise.reject(error)); //endregion
      //region Derive key for "contentEncryptionAlgorithm"

      sequence = sequence.then(result => this.deriveKey({
        name: "PBKDF2",
        hash: {
          name: hmacHashAlgorithm
        },
        salt: saltView,
        iterations: iterationCount
      }, result, contentEncryptionAlgorithm, false, ["decrypt"]), error => Promise.reject(error)); //endregion
      //region Decrypt internal content using derived key

      sequence = sequence.then(result => {
        //region Create correct data block for decryption
        var dataBuffer = new ArrayBuffer(0);
        if (parameters.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = parameters.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else {
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = parameters.encryptedContentInfo.encryptedContent.valueBlock.value[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var content = _step4.value;
              dataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        } //endregion

        return this.decrypt({
          name: contentEncryptionAlgorithm.name,
          iv: ivView
        }, result, dataBuffer);
      }, error => Promise.reject(error)); //endregion

      return sequence;
    } //**********************************************************************************

    /**
     * Stamping (signing) data using algorithm simular to HMAC
     * @param {Object} parameters
     * @return {Promise.<T>|Promise}
     */


    stampDataWithPassword(parameters) {
      //region Check for input parameters
      if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
      if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
      if ("hashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
      if ("salt" in parameters === false) return Promise.reject("Absent mandatory parameter \"iterationCount\"");
      if ("iterationCount" in parameters === false) return Promise.reject("Absent mandatory parameter \"salt\"");
      if ("contentToStamp" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentToStamp\""); //endregion
      //region Choose correct length for HMAC key

      var length;

      switch (parameters.hashAlgorithm.toLowerCase()) {
        case "sha-1":
          length = 160;
          break;

        case "sha-256":
          length = 256;
          break;

        case "sha-384":
          length = 384;
          break;

        case "sha-512":
          length = 512;
          break;

        default:
          return Promise.reject("Incorrect \"parameters.hashAlgorithm\" parameter: ".concat(parameters.hashAlgorithm));
      } //endregion
      //region Initial variables


      var sequence = Promise.resolve();
      var hmacAlgorithm = {
        name: "HMAC",
        length,
        hash: {
          name: parameters.hashAlgorithm
        }
      }; //endregion
      //region Create PKCS#12 key for integrity checking

      sequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount)); //endregion
      //region Import HMAC key
      // noinspection JSCheck Signatures

      sequence = sequence.then(result => this.importKey("raw", new Uint8Array(result), hmacAlgorithm, false, ["sign"])); //endregion
      //region Make signed HMAC value

      sequence = sequence.then(result => this.sign(hmacAlgorithm, result, new Uint8Array(parameters.contentToStamp)), error => Promise.reject(error)); //endregion

      return sequence;
    } //**********************************************************************************


    verifyDataStampedWithPassword(parameters) {
      //region Check for input parameters
      if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
      if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
      if ("hashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
      if ("salt" in parameters === false) return Promise.reject("Absent mandatory parameter \"iterationCount\"");
      if ("iterationCount" in parameters === false) return Promise.reject("Absent mandatory parameter \"salt\"");
      if ("contentToVerify" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentToVerify\"");
      if ("signatureToVerify" in parameters === false) return Promise.reject("Absent mandatory parameter \"signatureToVerify\""); //endregion
      //region Choose correct length for HMAC key

      var length;

      switch (parameters.hashAlgorithm.toLowerCase()) {
        case "sha-1":
          length = 160;
          break;

        case "sha-256":
          length = 256;
          break;

        case "sha-384":
          length = 384;
          break;

        case "sha-512":
          length = 512;
          break;

        default:
          return Promise.reject("Incorrect \"parameters.hashAlgorithm\" parameter: ".concat(parameters.hashAlgorithm));
      } //endregion
      //region Initial variables


      var sequence = Promise.resolve();
      var hmacAlgorithm = {
        name: "HMAC",
        length,
        hash: {
          name: parameters.hashAlgorithm
        }
      }; //endregion
      //region Create PKCS#12 key for integrity checking

      sequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount)); //endregion
      //region Import HMAC key
      // noinspection JSCheck Signatures

      sequence = sequence.then(result => this.importKey("raw", new Uint8Array(result), hmacAlgorithm, false, ["verify"])); //endregion
      //region Make signed HMAC value

      sequence = sequence.then(result => this.verify(hmacAlgorithm, result, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify)), error => Promise.reject(error)); //endregion

      return sequence;
    } //**********************************************************************************

    /**
     * Get signature parameters by analyzing private key algorithm
     * @param {Object} privateKey The private key user would like to use
     * @param {string} [hashAlgorithm="SHA-1"] Hash algorithm user would like to use
     * @return {Promise.<T>|Promise}
     */


    getSignatureParameters(privateKey) {
      var hashAlgorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "SHA-1";
      //region Check hashing algorithm
      var oid = this.getOIDByAlgorithm({
        name: hashAlgorithm
      });
      if (oid === "") return Promise.reject("Unsupported hash algorithm: ".concat(hashAlgorithm)); //endregion
      //region Initial variables

      var signatureAlgorithm = new AlgorithmIdentifier(); //endregion
      //region Get a "default parameters" for current algorithm

      var parameters = this.getAlgorithmParameters(privateKey.algorithm.name, "sign");
      parameters.algorithm.hash.name = hashAlgorithm; //endregion
      //region Fill internal structures base on "privateKey" and "hashAlgorithm"

      switch (privateKey.algorithm.name.toUpperCase()) {
        case "RSASSA-PKCS1-V1_5":
        case "ECDSA":
          signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(parameters.algorithm);
          break;

        case "RSA-PSS":
          {
            //region Set "saltLength" as a length (in octets) of hash   result
            switch (hashAlgorithm.toUpperCase()) {
              case "SHA-256":
                parameters.algorithm.saltLength = 32;
                break;

              case "SHA-384":
                parameters.algorithm.saltLength = 48;
                break;

              case "SHA-512":
                parameters.algorithm.saltLength = 64;
                break;

              default:
            } //endregion
            //region Fill "RSASSA_PSS_params" object


            var paramsObject = {};

            if (hashAlgorithm.toUpperCase() !== "SHA-1") {
              var hashAlgorithmOID = this.getOIDByAlgorithm({
                name: hashAlgorithm
              });
              if (hashAlgorithmOID === "") return Promise.reject("Unsupported hash algorithm: ".concat(hashAlgorithm));
              paramsObject.hashAlgorithm = new AlgorithmIdentifier({
                algorithmId: hashAlgorithmOID,
                algorithmParams: new Null()
              });
              paramsObject.maskGenAlgorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.113549.1.1.8",
                // MGF1
                algorithmParams: paramsObject.hashAlgorithm.toSchema()
              });
            }

            if (parameters.algorithm.saltLength !== 20) paramsObject.saltLength = parameters.algorithm.saltLength;
            var pssParameters = new RSASSAPSSParams(paramsObject); //endregion
            //region Automatically set signature algorithm

            signatureAlgorithm.algorithmId = "1.2.840.113549.1.1.10";
            signatureAlgorithm.algorithmParams = pssParameters.toSchema(); //endregion
          }
          break;

        default:
          return Promise.reject("Unsupported signature algorithm: ".concat(privateKey.algorithm.name));
      } //endregion


      return Promise.resolve().then(() => ({
        signatureAlgorithm,
        parameters
      }));
    } //**********************************************************************************

    /**
     * Sign data with pre-defined private key
     * @param {ArrayBuffer} data Data to be signed
     * @param {Object} privateKey Private key to use
     * @param {Object} parameters Parameters for used algorithm
     * @return {Promise.<T>|Promise}
     */


    signWithPrivateKey(data, privateKey, parameters) {
      return this.sign(parameters.algorithm, privateKey, new Uint8Array(data)).then(result => {
        //region Special case for ECDSA algorithm
        if (parameters.algorithm.name === "ECDSA") result = createCMSECDSASignature(result); //endregion

        return result;
      }, error => Promise.reject("Signing error: ".concat(error)));
    } //**********************************************************************************


    fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {
      var parameters = {}; //region Find signer's hashing algorithm

      var shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
      if (shaAlgorithm === "") return Promise.reject("Unsupported signature algorithm: ".concat(signatureAlgorithm.algorithmId)); //endregion
      //region Get information about public key algorithm and default parameters for import

      var algorithmId;
      if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10") algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;
      var algorithmObject = this.getAlgorithmByOID(algorithmId);
      if ("name" in algorithmObject === "") return Promise.reject("Unsupported public key algorithm: ".concat(signatureAlgorithm.algorithmId));
      parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importkey");
      if ("hash" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm; //region Special case for ECDSA

      if (algorithmObject.name === "ECDSA") {
        //region Get information about named curve
        var algorithmParamsChecked = false;

        if ("algorithmParams" in publicKeyInfo.algorithm === true) {
          if ("idBlock" in publicKeyInfo.algorithm.algorithmParams) {
            if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;
          }
        }

        if (algorithmParamsChecked === false) return Promise.reject("Incorrect type for ECDSA public key parameters");
        var curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
        if ("name" in curveObject === false) return Promise.reject("Unsupported named curve algorithm: ".concat(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString())); //endregion

        parameters.algorithm.algorithm.namedCurve = curveObject.name;
      } //endregion
      //endregion


      return parameters;
    } //**********************************************************************************


    getPublicKey(publicKeyInfo, signatureAlgorithm) {
      var parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (parameters === null) parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
      var publicKeyInfoSchema = publicKeyInfo.toSchema();
      var publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);
      var publicKeyInfoView = new Uint8Array(publicKeyInfoBuffer);
      return this.importKey("spki", publicKeyInfoView, parameters.algorithm.algorithm, true, parameters.algorithm.usages);
    } //**********************************************************************************


    verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm) {
      var shaAlgorithm = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      //region Initial variables
      var sequence = Promise.resolve(); //endregion
      //region Find signer's hashing algorithm

      if (shaAlgorithm === null) {
        shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
        if (shaAlgorithm === "") return Promise.reject("Unsupported signature algorithm: ".concat(signatureAlgorithm.algorithmId)); //region Import public key

        sequence = sequence.then(() => this.getPublicKey(publicKeyInfo, signatureAlgorithm)); //endregion
      } else {
        var parameters = {}; //region Get information about public key algorithm and default parameters for import

        var algorithmId;
        if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10") algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;
        var algorithmObject = this.getAlgorithmByOID(algorithmId);
        if ("name" in algorithmObject === "") return Promise.reject("Unsupported public key algorithm: ".concat(signatureAlgorithm.algorithmId));
        parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importkey");
        if ("hash" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm; //region Special case for ECDSA

        if (algorithmObject.name === "ECDSA") {
          //region Get information about named curve
          var algorithmParamsChecked = false;

          if ("algorithmParams" in publicKeyInfo.algorithm === true) {
            if ("idBlock" in publicKeyInfo.algorithm.algorithmParams) {
              if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;
            }
          }

          if (algorithmParamsChecked === false) return Promise.reject("Incorrect type for ECDSA public key parameters");
          var curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
          if ("name" in curveObject === false) return Promise.reject("Unsupported named curve algorithm: ".concat(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString())); //endregion

          parameters.algorithm.algorithm.namedCurve = curveObject.name;
        } //endregion
        //endregion
        //region Import public key


        sequence = sequence.then(() => this.getPublicKey(publicKeyInfo, null, parameters)); //endregion
      } //endregion
      //region Verify signature


      sequence = sequence.then(publicKey => {
        //region Get default algorithm parameters for verification
        var algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, "verify");
        if ("hash" in algorithm.algorithm) algorithm.algorithm.hash.name = shaAlgorithm; //endregion
        //region Special case for ECDSA signatures

        var signatureValue = signature.valueBlock.valueHex;

        if (publicKey.algorithm.name === "ECDSA") {
          var asn1 = fromBER(signatureValue); // noinspection JSCheck Signatures

          signatureValue = createECDSASignatureFromCMS(asn1.result);
        } //endregion
        //region Special case for RSA-PSS


        if (publicKey.algorithm.name === "RSA-PSS") {
          var pssParameters;

          try {
            pssParameters = new RSASSAPSSParams({
              schema: signatureAlgorithm.algorithmParams
            });
          } catch (ex) {
            return Promise.reject(ex);
          }

          if ("saltLength" in pssParameters) algorithm.algorithm.saltLength = pssParameters.saltLength;else algorithm.algorithm.saltLength = 20;
          var hashAlgo = "SHA-1";

          if ("hashAlgorithm" in pssParameters) {
            var hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId);
            if ("name" in hashAlgorithm === false) return Promise.reject("Unrecognized hash algorithm: ".concat(pssParameters.hashAlgorithm.algorithmId));
            hashAlgo = hashAlgorithm.name;
          }

          algorithm.algorithm.hash.name = hashAlgo;
        } //endregion


        return this.verify(algorithm.algorithm, publicKey, new Uint8Array(signatureValue), new Uint8Array(data));
      }); //endregion

      return sequence;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************
  //region Crypto engine related  
  //**************************************************************************************


  var engine = {
    name: "none",
    crypto: null,
    subtle: null
  }; //**************************************************************************************

    setEngine(name, crypto, subtle) {
    //region We are in Node
    // noinspection JSUnresolvedVariable
    if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined" && typeof window === "undefined") {
      // noinspection ES6ModulesDependencies, JSUnresolvedVariable
      if (typeof global[process.pid] === "undefined") {
        // noinspection JSUnresolvedVariable
        global[process.pid] = {};
      } else {
        // noinspection JSUnresolvedVariable
        if (typeof global[process.pid] !== "object") {
          // noinspection JSUnresolvedVariable
          throw new Error("Name global.".concat(process.pid, " already exists and it is not an object"));
        }
      } // noinspection JSUnresolvedVariable


      if (typeof global[process.pid].pkijs === "undefined") {
        // noinspection JSUnresolvedVariable
        global[process.pid].pkijs = {};
      } else {
        // noinspection JSUnresolvedVariable
        if (typeof global[process.pid].pkijs !== "object") {
          // noinspection JSUnresolvedVariable
          throw new Error("Name global.".concat(process.pid, ".pkijs already exists and it is not an object"));
        }
      } // noinspection JSUnresolvedVariable


      global[process.pid].pkijs.engine = {
        name: name,
        crypto: crypto,
        subtle: subtle
      };
    } //endregion
    //region We are in browser
    else {
        engine = {
          name: name,
          crypto: crypto,
          subtle: subtle
        };
      } //endregion

  } //**************************************************************************************


    getEngine() {
    //region We are in Node
    // noinspection JSUnresolvedVariable
    if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined" && typeof window === "undefined") {
      var _engine;

      try {
        // noinspection JSUnresolvedVariable
        _engine = global[process.pid].pkijs.engine;
      } catch (ex) {
        throw new Error("Please call \"setEngine\" before call to \"getEngine\"");
      }

      return _engine;
    } //endregion


    return engine;
  } //**************************************************************************************


  (  initCryptoEngine() {
    if (typeof self !== "undefined") {
      if ("crypto" in self) {
        var engineName = "webcrypto";
        /**
         * Standard crypto object
         * @type {Object}
         * @property {Object} [webkitSubtle] Subtle object from Apple
         */

        var cryptoObject = self.crypto;
        var subtleObject; // Apple Safari support

        if ("webkitSubtle" in self.crypto) {
          try {
            subtleObject = self.crypto.webkitSubtle;
          } catch (ex) {
            subtleObject = self.crypto.subtle;
          }

          engineName = "safari";
        }

        if ("subtle" in self.crypto) subtleObject = self.crypto.subtle;

        if (typeof subtleObject === "undefined") {
          engine = {
            name: engineName,
            crypto: cryptoObject,
            subtle: null
          };
        } else {
          engine = {
            name: engineName,
            crypto: cryptoObject,
            subtle: new CryptoEngine({
              name: engineName,
              crypto: self.crypto,
              subtle: subtleObject
            })
          };
        }
      }
    }

    setEngine(engine.name, engine.crypto, engine.subtle);
  })(); //**************************************************************************************
  //endregion
  //**************************************************************************************
  //region Declaration of common  s
  //**************************************************************************************

  /**
   * Get crypto subtle from current "crypto engine" or "undefined"
   * @returns {({decrypt, deriveKey, digest, encrypt, exportKey, generateKey, importKey, sign, unwrapKey, verify, wrapKey}|null)}
   */


    getCrypto() {
    var _engine = getEngine();

    if (_engine.subtle !== null) return _engine.subtle;
    return undefined;
  } //**************************************************************************************

  /**
   * Get OID for each specific algorithm
   * @param {Object} algorithm
   * @returns {string}
   */


    getOIDByAlgorithm(algorithm) {
    return getEngine().subtle.getOIDByAlgorithm(algorithm);
  } //**************************************************************************************

  /**
   * Create CMS ECDSA signature from WebCrypto ECDSA signature
   * @param {ArrayBuffer} signatureBuffer WebCrypto result of "sign"  
   * @returns {ArrayBuffer}
   */


    createCMSECDSASignature(signatureBuffer) {
    //region Initial check for correct length
    if (signatureBuffer.byteLength % 2 !== 0) return new ArrayBuffer(0); //endregion
    //region Initial variables

    var length = signatureBuffer.byteLength / 2; // There are two equal parts inside incoming ArrayBuffer

    var rBuffer = new ArrayBuffer(length);
    var rView = new Uint8Array(rBuffer);
    rView.set(new Uint8Array(signatureBuffer, 0, length));
    var rInteger = new Integer({
      valueHex: rBuffer
    });
    var sBuffer = new ArrayBuffer(length);
    var sView = new Uint8Array(sBuffer);
    sView.set(new Uint8Array(signatureBuffer, length, length));
    var sInteger = new Integer({
      valueHex: sBuffer
    }); //endregion

    return new Sequence({
      value: [rInteger.convertToDER(), sInteger.convertToDER()]
    }).toBER(false);
  } //**************************************************************************************

  /**
   * String preparation  . In a future here will be realization of algorithm from RFC4518
   * @param {string} inputString JavaScript string. As soon as for each ASN.1 string type we have a specific transformation   here we will work with pure JavaScript string
   * @returns {string} Formated string
   */


    stringPrep(inputString) {
    //region Initial variables
    var isSpace = false;
    var cuttedResult = ""; //endregion

    var result = inputString.trim(); // Trim input string
    //region Change all sequence of SPACE down to SPACE char

    for (var i = 0; i < result.length; i++) {
      if (result.charCodeAt(i) === 32) {
        if (isSpace === false) isSpace = true;
      } else {
        if (isSpace) {
          cuttedResult += " ";
          isSpace = false;
        }

        cuttedResult += result[i];
      }
    } //endregion


    return cuttedResult.toLowerCase();
  } //**************************************************************************************

  /**
   * Create a single ArrayBuffer from CMS ECDSA signature
   * @param {Sequence} cmsSignature ASN.1 SEQUENCE contains CMS ECDSA signature
   * @returns {ArrayBuffer}
   */


    createECDSASignatureFromCMS(cmsSignature) {
    //region Check input variables
    if (cmsSignature instanceof Sequence === false) return new ArrayBuffer(0);
    if (cmsSignature.valueBlock.value.length !== 2) return new ArrayBuffer(0);
    if (cmsSignature.valueBlock.value[0] instanceof Integer === false) return new ArrayBuffer(0);
    if (cmsSignature.valueBlock.value[1] instanceof Integer === false) return new ArrayBuffer(0); //endregion

    var rValue = cmsSignature.valueBlock.value[0].convertFromDER();
    var sValue = cmsSignature.valueBlock.value[1].convertFromDER(); //region Check the lengths of two parts are equal

    switch (true) {
      case rValue.valueBlock.valueHex.byteLength < sValue.valueBlock.valueHex.byteLength:
        {
          if (sValue.valueBlock.valueHex.byteLength - rValue.valueBlock.valueHex.byteLength !== 1) throw new Error("Incorrect DER integer decoding");
          var correctedLength = sValue.valueBlock.valueHex.byteLength;
          var rValueView = new Uint8Array(rValue.valueBlock.valueHex);
          var rValueBufferCorrected = new ArrayBuffer(correctedLength);
          var rValueViewCorrected = new Uint8Array(rValueBufferCorrected);
          rValueViewCorrected.set(rValueView, 1);
          rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here

          return utilConcatBuf(rValueBufferCorrected, sValue.valueBlock.valueHex);
        }

      case rValue.valueBlock.valueHex.byteLength > sValue.valueBlock.valueHex.byteLength:
        {
          if (rValue.valueBlock.valueHex.byteLength - sValue.valueBlock.valueHex.byteLength !== 1) throw new Error("Incorrect DER integer decoding");
          var _correctedLength = rValue.valueBlock.valueHex.byteLength;
          var sValueView = new Uint8Array(sValue.valueBlock.valueHex);
          var sValueBufferCorrected = new ArrayBuffer(_correctedLength);
          var sValueViewCorrected = new Uint8Array(sValueBufferCorrected);
          sValueViewCorrected.set(sValueView, 1);
          sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here

          return utilConcatBuf(rValue.valueBlock.valueHex, sValueBufferCorrected);
        }

      default:
        {
          //region In case we have equal length and the length is not even with 2
          if (rValue.valueBlock.valueHex.byteLength % 2) {
            var _correctedLength2 = rValue.valueBlock.valueHex.byteLength + 1;

            var _rValueView = new Uint8Array(rValue.valueBlock.valueHex);

            var _rValueBufferCorrected = new ArrayBuffer(_correctedLength2);

            var _rValueViewCorrected = new Uint8Array(_rValueBufferCorrected);

            _rValueViewCorrected.set(_rValueView, 1);

            _rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here

            var _sValueView = new Uint8Array(sValue.valueBlock.valueHex);

            var _sValueBufferCorrected = new ArrayBuffer(_correctedLength2);

            var _sValueViewCorrected = new Uint8Array(_sValueBufferCorrected);

            _sValueViewCorrected.set(_sValueView, 1);

            _sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here

            return utilConcatBuf(_rValueBufferCorrected, _sValueBufferCorrected);
          } //endregion

        }
    } //endregion


    return utilConcatBuf(rValue.valueBlock.valueHex, sValue.valueBlock.valueHex);
  } //**************************************************************************************

  /**
   * Get WebCrypto algorithm by wel-known OID
   * @param {string} oid well-known OID to search for
   * @returns {Object}
   */


    getAlgorithmByOID(oid) {
    return getEngine().subtle.getAlgorithmByOID(oid);
  } //**************************************************************************************
  //endregion
  //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class ContentInfo {
    //**********************************************************************************

    /**
     * Constructor for ContentInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc contentType
       */
      this.contentType = getParametersValue(parameters, "contentType", ContentInfo.defaultValues("contentType"));
      /**
       * @type {Any}
       * @desc content
       */

      this.content = getParametersValue(parameters, "content", ContentInfo.defaultValues("content")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "contentType":
          return "";

        case "content":
          return new Any();

        default:
          throw new Error("Invalid member name for ContentInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "contentType":
          return memberValue === "";

        case "content":
          return memberValue instanceof Any;

        default:
          throw new Error("Invalid member name for ContentInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * ContentInfo ::= SEQUENCE {
     *    contentType ContentType,
     *    content [0] EXPLICIT ANY DEFINED BY contentType }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [contentType]
       * @property {string} [content]
       */
      var names = getParametersValue(parameters, "names", {});
      if ("optional" in names === false) names.optional = false;
      return new Sequence({
        name: names.blockName || "ContentInfo",
        optional: names.optional,
        value: [new ObjectIdentifier({
          name: names.contentType || "contentType"
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Any({
            name: names.content || "content"
          })] // EXPLICIT ANY value

        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["contentType", "content"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, ContentInfo.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ContentInfo"); //endregion
      //region Get internal properties from parsed schema

      this.contentType = asn1.result.contentType.valueBlock.toString();
      this.content = asn1.result.content; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new ObjectIdentifier({
          value: this.contentType
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [this.content] // EXPLICIT ANY value

        })]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        contentType: this.contentType
      };
      if (!(this.content instanceof Any)) object.content = this.content.toJSON();
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class EncapsulatedContentInfo {
    //**********************************************************************************

    /**
     * Constructor for EncapsulatedContentInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc eContentType
       */
      this.eContentType = getParametersValue(parameters, "eContentType", EncapsulatedContentInfo.defaultValues("eContentType"));

      if ("eContent" in parameters) {
        /**
         * @type {OctetString}
         * @desc eContent
         */
        this.eContent = getParametersValue(parameters, "eContent", EncapsulatedContentInfo.defaultValues("eContent"));

        if (this.eContent.idBlock.tagClass === 1 && this.eContent.idBlock.tagNumber === 4) {
          //region Divide OCTETSTRING value down to small pieces
          if (this.eContent.idBlock.isConstructed === false) {
            var constrString = new OctetString({
              idBlock: {
                isConstructed: true
              },
              isConstructed: true
            });
            var offset = 0;
            var length = this.eContent.valueBlock.valueHex.byteLength;

            while (length > 0) {
              var pieceView = new Uint8Array(this.eContent.valueBlock.valueHex, offset, offset + 65536 > this.eContent.valueBlock.valueHex.byteLength ? this.eContent.valueBlock.valueHex.byteLength - offset : 65536);

              var _array = new ArrayBuffer(pieceView.length);

              var _view = new Uint8Array(_array);

              for (var i = 0; i < _view.length; i++) {
                _view[i] = pieceView[i];
              }

              constrString.valueBlock.value.push(new OctetString({
                valueHex: _array
              }));
              length -= pieceView.length;
              offset += pieceView.length;
            }

            this.eContent = constrString;
          } //endregion

        }
      } //endregion
      //region If input argument array contains "schema" for this object


      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "eContentType":
          return "";

        case "eContent":
          return new OctetString();

        default:
          throw new Error("Invalid member name for EncapsulatedContentInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "eContentType":
          return memberValue === "";

        case "eContent":
          {
            if (memberValue.idBlock.tagClass === 1 && memberValue.idBlock.tagNumber === 4) return memberValue.isEqual(EncapsulatedContentInfo.defaultValues("eContent"));
            return false;
          }

        default:
          throw new Error("Invalid member name for EncapsulatedContentInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * EncapsulatedContentInfo ::= SEQUENCE {
     *    eContentType ContentType,
     *    eContent [0] EXPLICIT OCTET STRING OPTIONAL } * Changed it to ANY, as in PKCS#7
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [type]
       * @property {string} [setName]
       * @property {string} [values]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.eContentType || ""
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Any({
            name: names.eContent || ""
          }) // In order to aling this with PKCS#7 and CMS as well
          ]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["eContentType", "eContent"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, EncapsulatedContentInfo.schema({
        names: {
          eContentType: "eContentType",
          eContent: "eContent"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for EncapsulatedContentInfo"); //endregion
      //region Get internal properties from parsed schema

      this.eContentType = asn1.result.eContentType.valueBlock.toString();
      if ("eContent" in asn1.result) this.eContent = asn1.result.eContent; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence 
      var outputArray = [];
      outputArray.push(new ObjectIdentifier({
        value: this.eContentType
      }));

      if ("eContent" in this) {
        if (EncapsulatedContentInfo.compareWithDefault("eContent", this.eContent) === false) {
          outputArray.push(new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            value: [this.eContent]
          }));
        }
      } //endregion 
      //region Construct and return new ASN.1 schema for this object 


      return new Sequence({
        value: outputArray
      }); //endregion 
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        eContentType: this.eContentType
      };

      if ("eContent" in this) {
        if (EncapsulatedContentInfo.compareWithDefault("eContent", this.eContent) === false) _object.eContent = this.eContent.toJSON();
      }

      return _object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class AttributeTypeAndValue {
    //**********************************************************************************

    /**
     * Constructor for AttributeTypeAndValue class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc type
       */
      this.type = getParametersValue(parameters, "type", AttributeTypeAndValue.defaultValues("type"));
      /**
       * @type {Object}
       * @desc Value of the AttributeTypeAndValue class
       */

      this.value = getParametersValue(parameters, "value", AttributeTypeAndValue.defaultValues("value")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "type":
          return "";

        case "value":
          return {};

        default:
          throw new Error("Invalid member name for AttributeTypeAndValue class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AttributeTypeAndValue ::= Sequence {
     *    type     AttributeType,
     *    value    AttributeValue }
     *
     * AttributeType ::= OBJECT IDENTIFIER
     *
     * AttributeValue ::= ANY -- DEFINED BY AttributeType
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName] Name for entire block
       * @property {string} [type] Name for "type" element
       * @property {string} [value] Name for "value" element
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.type || ""
        }), new Any({
          name: names.value || ""
        })]
      });
    } //**********************************************************************************


    static blockName() {
      return "AttributeTypeAndValue";
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["type", "typeValue"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AttributeTypeAndValue.schema({
        names: {
          type: "type",
          value: "typeValue"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue"); //endregion
      //region Get internal properties from parsed schema

      this.type = asn1.result.type.valueBlock.toString(); // noinspection JSUnresolvedVariable

      this.value = asn1.result.typeValue; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new ObjectIdentifier({
          value: this.type
        }), this.value]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        type: this.type
      };
      if (Object.keys(this.value).length !== 0) _object.value = this.value.toJSON();else _object.value = this.value;
      return _object;
    } //**********************************************************************************

    /**
     * Compare two AttributeTypeAndValue values, or AttributeTypeAndValue with ArrayBuffer value
     * @param {(AttributeTypeAndValue|ArrayBuffer)} compareTo The value compare to current
     * @returns {boolean}
     */


    isEqual(compareTo) {
      var stringBlockNames = [Utf8String.blockName(), BmpString.blockName(), UniversalString.blockName(), NumericString.blockName(), PrintableString.blockName(), TeletexString.blockName(), VideotexString.blockName(), IA5String.blockName(), GraphicString.blockName(), VisibleString.blockName(), GeneralString.blockName(), CharacterString.blockName()];

      if (compareTo.constructor.blockName() === AttributeTypeAndValue.blockName()) {
        if (this.type !== compareTo.type) return false; //region Check we do have both strings

        var isString = false;
        var thisName = this.value.constructor.blockName();

        if (thisName === compareTo.value.constructor.blockName()) {
          for (var _i29 = 0, _stringBlockNames = stringBlockNames; _i29 < _stringBlockNames.length; _i29++) {
            var name = _stringBlockNames[_i29];

            if (thisName === name) {
              isString = true;
              break;
            }
          }
        } //endregion


        if (isString) {
          var value1 = stringPrep(this.value.valueBlock.value);
          var value2 = stringPrep(compareTo.value.valueBlock.value);
          if (value1.localeCompare(value2) !== 0) return false;
        } else // Comparing as two ArrayBuffers
          {
            if (isEqualBuffer(this.value.valueBeforeDecode, compareTo.value.valueBeforeDecode) === false) return false;
          }

        return true;
      }

      if (compareTo instanceof ArrayBuffer) return isEqualBuffer(this.value.valueBeforeDecode, compareTo);
      return false;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class RelativeDistinguishedNames {
    //**********************************************************************************

    /**
     * Constructor for RelativeDistinguishedNames class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     * @property {Array.<AttributeTypeAndValue>} [typesAndValues] Array of "type and value" objects
     * @property {ArrayBuffer} [valueBeforeDecode] Value of the RDN before decoding from schema
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<AttributeTypeAndValue>}
       * @desc Array of "type and value" objects
       */
      this.typesAndValues = getParametersValue(parameters, "typesAndValues", RelativeDistinguishedNames.defaultValues("typesAndValues"));
      /**
       * @type {ArrayBuffer}
       * @desc Value of the RDN before decoding from schema
       */

      this.valueBeforeDecode = getParametersValue(parameters, "valueBeforeDecode", RelativeDistinguishedNames.defaultValues("valueBeforeDecode")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "typesAndValues":
          return [];

        case "valueBeforeDecode":
          return new ArrayBuffer(0);

        default:
          throw new Error("Invalid member name for RelativeDistinguishedNames class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "typesAndValues":
          return memberValue.length === 0;

        case "valueBeforeDecode":
          return memberValue.byteLength === 0;

        default:
          throw new Error("Invalid member name for RelativeDistinguishedNames class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * RDNSequence ::= Sequence OF RelativeDistinguishedName
     *
     * RelativeDistinguishedName ::=
     * SET SIZE (1..MAX) OF AttributeTypeAndValue
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName] Name for entire block
       * @property {string} [repeatedSequence] Name for "repeatedSequence" block
       * @property {string} [repeatedSet] Name for "repeatedSet" block
       * @property {string} [typeAndValue] Name for "typeAndValue" block
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.repeatedSequence || "",
          value: new Set({
            value: [new Repeated({
              name: names.repeatedSet || "",
              value: AttributeTypeAndValue.schema(names.typeAndValue || {})
            })]
          })
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["RDN", "typesAndValues"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, RelativeDistinguishedNames.schema({
        names: {
          blockName: "RDN",
          repeatedSet: "typesAndValues"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames"); //endregion
      //region Get internal properties from parsed schema

      if ("typesAndValues" in asn1.result) // Could be a case when there is no "types and values"
        this.typesAndValues = Array.from(asn1.result.typesAndValues, element => new AttributeTypeAndValue({
          schema: element
        })); // noinspection JSUnresolvedVariable

      this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecode; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Decode stored TBS value
      if (this.valueBeforeDecode.byteLength === 0) // No stored encoded array, create "from scratch"
        {
          return new Sequence({
            value: [new Set({
              value: Array.from(this.typesAndValues, element => element.toSchema())
            })]
          });
        }

      var asn1 = fromBER(this.valueBeforeDecode); //endregion
      //region Construct and return new ASN.1 schema for this object

      return asn1.result; //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        typesAndValues: Array.from(this.typesAndValues, element => element.toJSON())
      };
    } //**********************************************************************************

    /**
     * Compare two RDN values, or RDN with ArrayBuffer value
     * @param {(RelativeDistinguishedNames|ArrayBuffer)} compareTo The value compare to current
     * @returns {boolean}
     */


    isEqual(compareTo) {
      if (compareTo instanceof RelativeDistinguishedNames) {
        if (this.typesAndValues.length !== compareTo.typesAndValues.length) return false;
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = this.typesAndValues.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _step5$value = _slicedToArray(_step5.value, 2),
                index = _step5$value[0],
                typeAndValue = _step5$value[1];

            if (typeAndValue.isEqual(compareTo.typesAndValues[index]) === false) return false;
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        return true;
      }

      if (compareTo instanceof ArrayBuffer) return isEqualBuffer(this.valueBeforeDecode, compareTo);
      return false;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class Time {
    //**********************************************************************************

    /**
     * Constructor for Time class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     * @property {number} [type] 0 - UTCTime; 1 - GeneralizedTime; 2 - empty value
     * @property {Date} [value] Value of the TIME class
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc 0 - UTCTime; 1 - GeneralizedTime; 2 - empty value
       */
      this.type = getParametersValue(parameters, "type", Time.defaultValues("type"));
      /**
       * @type {Date}
       * @desc Value of the TIME class
       */

      this.value = getParametersValue(parameters, "value", Time.defaultValues("value")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "type":
          return 0;

        case "value":
          return new Date(0, 0, 0);

        default:
          throw new Error("Invalid member name for Time class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * Time ::= CHOICE {
        *   utcTime        UTCTime,
        *   generalTime    GeneralizedTime }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @param {boolean} optional Flag that current schema should be optional
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [utcTimeName] Name for "utcTimeName" choice
       * @property {string} [generalTimeName] Name for "generalTimeName" choice
       */
      var names = getParametersValue(parameters, "names", {});
      return new Choice({
        optional,
        value: [new UTCTime({
          name: names.utcTimeName || ""
        }), new GeneralizedTime({
          name: names.generalTimeName || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["utcTimeName", "generalTimeName"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, Time.schema({
        names: {
          utcTimeName: "utcTimeName",
          generalTimeName: "generalTimeName"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Time"); //endregion
      //region Get internal properties from parsed schema

      if ("utcTimeName" in asn1.result) {
        this.type = 0;
        this.value = asn1.result.utcTimeName.toDate();
      }

      if ("generalTimeName" in asn1.result) {
        this.type = 1;
        this.value = asn1.result.generalTimeName.toDate();
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      var result = {};
      if (this.type === 0) result = new UTCTime({
        valueDate: this.value
      });
      if (this.type === 1) result = new GeneralizedTime({
        valueDate: this.value
      });
      return result; //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        type: this.type,
        value: this.value
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class SubjectDirectoryAttributes {
    //**********************************************************************************

    /**
     * Constructor for SubjectDirectoryAttributes class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<Attribute>}
       * @desc attributes
       */
      this.attributes = getParametersValue(parameters, "attributes", SubjectDirectoryAttributes.defaultValues("attributes")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "attributes":
          return [];

        default:
          throw new Error("Invalid member name for SubjectDirectoryAttributes class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * SubjectDirectoryAttributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [utcTimeName] Name for "utcTimeName" choice
       * @property {string} [generalTimeName] Name for "generalTimeName" choice
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.attributes || "",
          value: Attribute.schema()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["attributes"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, SubjectDirectoryAttributes.schema({
        names: {
          attributes: "attributes"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes"); //endregion
      //region Get internal properties from parsed schema

      this.attributes = Array.from(asn1.result.attributes, element => new Attribute({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.attributes, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        attributes: Array.from(this.attributes, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class PrivateKeyUsagePeriod {
    //**********************************************************************************

    /**
     * Constructor for PrivateKeyUsagePeriod class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("notBefore" in parameters)
        /**
         * @type {Date}
         * @desc notBefore
         */
        this.notBefore = getParametersValue(parameters, "notBefore", PrivateKeyUsagePeriod.defaultValues("notBefore"));
      if ("notAfter" in parameters)
        /**
         * @type {Date}
         * @desc notAfter
         */
        this.notAfter = getParametersValue(parameters, "notAfter", PrivateKeyUsagePeriod.defaultValues("notAfter")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "notBefore":
          return new Date();

        case "notAfter":
          return new Date();

        default:
          throw new Error("Invalid member name for PrivateKeyUsagePeriod class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PrivateKeyUsagePeriod OID ::= 2.5.29.16
     *
     * PrivateKeyUsagePeriod ::= SEQUENCE {
     *    notBefore       [0]     GeneralizedTime OPTIONAL,
     *    notAfter        [1]     GeneralizedTime OPTIONAL }
     * -- either notBefore or notAfter MUST be present
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [notBefore]
       * @property {string} [notAfter]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Primitive({
          name: names.notBefore || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          }
        }), new Primitive({
          name: names.notAfter || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          }
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["notBefore", "notAfter"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PrivateKeyUsagePeriod.schema({
        names: {
          notBefore: "notBefore",
          notAfter: "notAfter"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod"); //endregion
      //region Get internal properties from parsed schema

      if ("notBefore" in asn1.result) {
        var localNotBefore = new GeneralizedTime();
        localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);
        this.notBefore = localNotBefore.toDate();
      }

      if ("notAfter" in asn1.result) {
        var localNotAfter = new GeneralizedTime({
          valueHex: asn1.result.notAfter.valueBlock.valueHex
        });
        localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);
        this.notAfter = localNotAfter.toDate();
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];

      if ("notBefore" in this) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          valueHex: new GeneralizedTime({
            valueDate: this.notBefore
          }).valueBlock.valueHex
        }));
      }

      if ("notAfter" in this) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          valueHex: new GeneralizedTime({
            valueDate: this.notAfter
          }).valueBlock.valueHex
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {};
      if ("notBefore" in this) object.notBefore = this.notBefore;
      if ("notAfter" in this) object.notAfter = this.notAfter;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************
  //region Additional asn1js schema elements existing inside GeneralName schema
  //**************************************************************************************

  /**
   * Schema for "builtInStandardAttributes" of "ORAddress"
   * @param {Object} parameters
   * @property {Object} [names]
   * @param {boolean} optional
   * @returns {Sequence}
   */


    builtInStandardAttributes() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    //builtInStandardAttributes ::= Sequence {
    //    country-name                  CountryName OPTIONAL,
    //    administration-domain-name    AdministrationDomainName OPTIONAL,
    //    network-address           [0] IMPLICIT NetworkAddress OPTIONAL,
    //    terminal-identifier       [1] IMPLICIT TerminalIdentifier OPTIONAL,
    //    private-domain-name       [2] PrivateDomainName OPTIONAL,
    //    organization-name         [3] IMPLICIT OrganizationName OPTIONAL,
    //    numeric-user-identifier   [4] IMPLICIT NumericUserIdentifier OPTIONAL,
    //    personal-name             [5] IMPLICIT PersonalName OPTIONAL,
    //    organizational-unit-names [6] IMPLICIT OrganizationalUnitNames OPTIONAL }

    /**
     * @type {Object}
     * @property {string} [country_name]
     * @property {string} [administration_domain_name]
     * @property {string} [network_address]
     * @property {string} [terminal_identifier]
     * @property {string} [private_domain_name]
     * @property {string} [organization_name]
     * @property {string} [numeric_user_identifier]
     * @property {string} [personal_name]
     * @property {string} [organizational_unit_names]
     */
    var names = getParametersValue(parameters, "names", {});
    return new Sequence({
      optional,
      value: [new Constructed({
        optional: true,
        idBlock: {
          tagClass: 2,
          // APPLICATION-SPECIFIC
          tagNumber: 1 // [1]

        },
        name: names.country_name || "",
        value: [new Choice({
          value: [new NumericString(), new PrintableString()]
        })]
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 2,
          // APPLICATION-SPECIFIC
          tagNumber: 2 // [2]

        },
        name: names.administration_domain_name || "",
        value: [new Choice({
          value: [new NumericString(), new PrintableString()]
        })]
      }), new Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 0 // [0]

        },
        name: names.network_address || "",
        isHexOnly: true
      }), new Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 1 // [1]

        },
        name: names.terminal_identifier || "",
        isHexOnly: true
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 2 // [2]

        },
        name: names.private_domain_name || "",
        value: [new Choice({
          value: [new NumericString(), new PrintableString()]
        })]
      }), new Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 3 // [3]

        },
        name: names.organization_name || "",
        isHexOnly: true
      }), new Primitive({
        optional: true,
        name: names.numeric_user_identifier || "",
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 4 // [4]

        },
        isHexOnly: true
      }), new Constructed({
        optional: true,
        name: names.personal_name || "",
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 5 // [5]

        },
        value: [new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          isHexOnly: true
        }), new Primitive({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          isHexOnly: true
        }), new Primitive({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          },
          isHexOnly: true
        }), new Primitive({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 3 // [3]

          },
          isHexOnly: true
        })]
      }), new Constructed({
        optional: true,
        name: names.organizational_unit_names || "",
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 6 // [6]

        },
        value: [new Repeated({
          value: new PrintableString()
        })]
      })]
    });
  } //**************************************************************************************

  /**
   * Schema for "builtInDomainDefinedAttributes" of "ORAddress"
   * @param {boolean} optional
   * @returns {Sequence}
   */


    builtInDomainDefinedAttributes() {
    var optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return new Sequence({
      optional,
      value: [new PrintableString(), new PrintableString()]
    });
  } //**************************************************************************************

  /**
   * Schema for "builtInDomainDefinedAttributes" of "ORAddress"
   * @param {boolean} optional
   * @returns {Set}
   */


    extensionAttributes() {
    var optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return new Set({
      optional,
      value: [new Primitive({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 0 // [0]

        },
        isHexOnly: true
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 1 // [1]

        },
        value: [new Any()]
      })]
    });
  } //**************************************************************************************
  //endregion
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class GeneralName {
    //**********************************************************************************

    /**
     * Constructor for GeneralName class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     * @property {number} [type] value type - from a tagged value (0 for "otherName", 1 for "rfc822Name" etc.)
     * @property {Object} [value] asn1js object having GeneralName value (type depends on "type" value)
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc value type - from a tagged value (0 for "otherName", 1 for "rfc822Name" etc.)
       */
      this.type = getParametersValue(parameters, "type", GeneralName.defaultValues("type"));
      /**
       * @type {Object}
       * @desc asn1js object having GeneralName value (type depends on "type" value)
       */

      this.value = getParametersValue(parameters, "value", GeneralName.defaultValues("value")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "type":
          return 9;

        case "value":
          return {};

        default:
          throw new Error("Invalid member name for GeneralName class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "type":
          return memberValue === GeneralName.defaultValues(memberName);

        case "value":
          return Object.keys(memberValue).length === 0;

        default:
          throw new Error("Invalid member name for GeneralName class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * GeneralName ::= Choice {
     *    otherName                       [0]     OtherName,
     *    rfc822Name                      [1]     IA5String,
     *    dNSName                         [2]     IA5String,
     *    x400Address                     [3]     ORAddress,
     *    directoryName                   [4]     value,
     *    ediPartyName                    [5]     EDIPartyName,
     *    uniformResourceIdentifier       [6]     IA5String,
     *    iPAddress                       [7]     OCTET STRING,
     *    registeredID                    [8]     OBJECT IDENTIFIER }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {Object} [directoryName]
       * @property {Object} [builtInStandardAttributes]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Choice({
        value: [new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          name: names.blockName || "",
          value: [new ObjectIdentifier(), new Constructed({
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            value: [new Any()]
          })]
        }), new Primitive({
          name: names.blockName || "",
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          }
        }), new Primitive({
          name: names.blockName || "",
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          }
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 3 // [3]

          },
          name: names.blockName || "",
          value: [builtInStandardAttributes(names.builtInStandardAttributes || {}, false), builtInDomainDefinedAttributes(true), extensionAttributes(true)]
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 4 // [4]

          },
          name: names.blockName || "",
          value: [RelativeDistinguishedNames.schema(names.directoryName || {})]
        }), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 5 // [5]

          },
          name: names.blockName || "",
          value: [new Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            value: [new Choice({
              value: [new TeletexString(), new PrintableString(), new UniversalString(), new Utf8String(), new BmpString()]
            })]
          }), new Constructed({
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 1 // [1]

            },
            value: [new Choice({
              value: [new TeletexString(), new PrintableString(), new UniversalString(), new Utf8String(), new BmpString()]
            })]
          })]
        }), new Primitive({
          name: names.blockName || "",
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 6 // [6]

          }
        }), new Primitive({
          name: names.blockName || "",
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 7 // [7]

          }
        }), new Primitive({
          name: names.blockName || "",
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 8 // [8]

          }
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["blockName", "otherName", "rfc822Name", "dNSName", "x400Address", "directoryName", "ediPartyName", "uniformResourceIdentifier", "iPAddress", "registeredID"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, GeneralName.schema({
        names: {
          blockName: "blockName",
          otherName: "otherName",
          rfc822Name: "rfc822Name",
          dNSName: "dNSName",
          x400Address: "x400Address",
          directoryName: {
            names: {
              blockName: "directoryName"
            }
          },
          ediPartyName: "ediPartyName",
          uniformResourceIdentifier: "uniformResourceIdentifier",
          iPAddress: "iPAddress",
          registeredID: "registeredID"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for GeneralName"); //endregion
      //region Get internal properties from parsed schema

      this.type = asn1.result.blockName.idBlock.tagNumber;

      switch (this.type) {
        case 0:
          // otherName
          this.value = asn1.result.blockName;
          break;

        case 1: // rfc822Name + dNSName + uniformResourceIdentifier

        case 2:
        case 6:
          {
            var value = asn1.result.blockName;
            value.idBlock.tagClass = 1; // UNIVERSAL

            value.idBlock.tagNumber = 22; // IA5STRING

            var valueBER = value.toBER(false);
            this.value = fromBER(valueBER).result.valueBlock.value;
          }
          break;

        case 3:
          // x400Address
          this.value = asn1.result.blockName;
          break;

        case 4:
          // directoryName
          this.value = new RelativeDistinguishedNames({
            schema: asn1.result.directoryName
          });
          break;

        case 5:
          // ediPartyName
          this.value = asn1.result.ediPartyName;
          break;

        case 7:
          // iPAddress
          this.value = new OctetString({
            valueHex: asn1.result.blockName.valueBlock.valueHex
          });
          break;

        case 8:
          // registeredID
          {
            var _value2 = asn1.result.blockName;
            _value2.idBlock.tagClass = 1; // UNIVERSAL

            _value2.idBlock.tagNumber = 6; // ObjectIdentifier

            var _valueBER = _value2.toBER(false);

            this.value = fromBER(_valueBER).result.valueBlock.toString(); // Getting a string representation of the ObjectIdentifier
          }
          break;

        default:
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      switch (this.type) {
        case 0:
        case 3:
        case 5:
          return new Constructed({
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: this.type
            },
            value: [this.value]
          });

        case 1:
        case 2:
        case 6:
          {
            var value = new IA5String({
              value: this.value
            });
            value.idBlock.tagClass = 3;
            value.idBlock.tagNumber = this.type;
            return value;
          }

        case 4:
          return new Constructed({
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 4
            },
            value: [this.value.toSchema()]
          });

        case 7:
          {
            var _value3 = this.value;
            _value3.idBlock.tagClass = 3;
            _value3.idBlock.tagNumber = this.type;
            return _value3;
          }

        case 8:
          {
            var _value4 = new ObjectIdentifier({
              value: this.value
            });

            _value4.idBlock.tagClass = 3;
            _value4.idBlock.tagNumber = this.type;
            return _value4;
          }

        default:
          return GeneralName.schema();
      } //endregion

    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        type: this.type,
        value: ""
      };
      if (typeof this.value === "string") _object.value = this.value;else {
        try {
          _object.value = this.value.toJSON();
        } catch (ex) {}
      }
      return _object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class AltName {
    //**********************************************************************************

    /**
     * Constructor for AltName class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<GeneralName>}
       * @desc Array of alternative names in GeneralName type
       */
      this.altNames = getParametersValue(parameters, "altNames", AltName.defaultValues("altNames")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "altNames":
          return [];

        default:
          throw new Error("Invalid member name for AltName class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AltName ::= GeneralNames
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [altNames]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.altNames || "",
          value: GeneralName.schema()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["altNames"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AltName.schema({
        names: {
          altNames: "altNames"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AltName"); //endregion
      //region Get internal properties from parsed schema

      if ("altNames" in asn1.result) this.altNames = Array.from(asn1.result.altNames, element => new GeneralName({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.altNames, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        altNames: Array.from(this.altNames, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class BasicConstraints {
    //**********************************************************************************

    /**
     * Constructor for BasicConstraints class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     * @property {Object} [cA]
     * @property {Object} [pathLenConstraint]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {boolean}
       * @desc cA
       */
      this.cA = getParametersValue(parameters, "cA", false);
      if ("pathLenConstraint" in parameters)
        /**
         * @type {number|Integer}
         * @desc pathLenConstraint
         */
        this.pathLenConstraint = getParametersValue(parameters, "pathLenConstraint", 0); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "cA":
          return false;

        default:
          throw new Error("Invalid member name for BasicConstraints class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * BasicConstraints ::= SEQUENCE {
     *    cA                      BOOLEAN DEFAULT FALSE,
     *    pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [cA]
       * @property {string} [pathLenConstraint]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Boolean({
          optional: true,
          name: names.cA || ""
        }), new Integer({
          optional: true,
          name: names.pathLenConstraint || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["cA", "pathLenConstraint"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, BasicConstraints.schema({
        names: {
          cA: "cA",
          pathLenConstraint: "pathLenConstraint"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for BasicConstraints"); //endregion
      //region Get internal properties from parsed schema

      if ("cA" in asn1.result) this.cA = asn1.result.cA.valueBlock.value;

      if ("pathLenConstraint" in asn1.result) {
        if (asn1.result.pathLenConstraint.valueBlock.isHexOnly) this.pathLenConstraint = asn1.result.pathLenConstraint;else this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      if (this.cA !== BasicConstraints.defaultValues("cA")) outputArray.push(new Boolean({
        value: this.cA
      }));

      if ("pathLenConstraint" in this) {
        if (this.pathLenConstraint instanceof Integer) outputArray.push(this.pathLenConstraint);else outputArray.push(new Integer({
          value: this.pathLenConstraint
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {};
      if (this.cA !== BasicConstraints.defaultValues("cA")) object.cA = this.cA;

      if ("pathLenConstraint" in this) {
        if (this.pathLenConstraint instanceof Integer) object.pathLenConstraint = this.pathLenConstraint.toJSON();else object.pathLenConstraint = this.pathLenConstraint;
      }

      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class IssuingDistributionPoint {
    //**********************************************************************************

    /**
     * Constructor for IssuingDistributionPoint class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("distributionPoint" in parameters)
        /**
         * @type {Array.<GeneralName>|RelativeDistinguishedNames}
         * @desc distributionPoint
         */
        this.distributionPoint = getParametersValue(parameters, "distributionPoint", IssuingDistributionPoint.defaultValues("distributionPoint"));
      /**
       * @type {boolean}
       * @desc onlyContainsUserCerts
       */

      this.onlyContainsUserCerts = getParametersValue(parameters, "onlyContainsUserCerts", IssuingDistributionPoint.defaultValues("onlyContainsUserCerts"));
      /**
       * @type {boolean}
       * @desc onlyContainsCACerts
       */

      this.onlyContainsCACerts = getParametersValue(parameters, "onlyContainsCACerts", IssuingDistributionPoint.defaultValues("onlyContainsCACerts"));
      if ("onlySomeReasons" in parameters)
        /**
         * @type {number}
         * @desc onlySomeReasons
         */
        this.onlySomeReasons = getParametersValue(parameters, "onlySomeReasons", IssuingDistributionPoint.defaultValues("onlySomeReasons"));
      /**
       * @type {boolean}
       * @desc indirectCRL
       */

      this.indirectCRL = getParametersValue(parameters, "indirectCRL", IssuingDistributionPoint.defaultValues("indirectCRL"));
      /**
       * @type {boolean}
       * @desc onlyContainsAttributeCerts
       */

      this.onlyContainsAttributeCerts = getParametersValue(parameters, "onlyContainsAttributeCerts", IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "distributionPoint":
          return [];

        case "onlyContainsUserCerts":
          return false;

        case "onlyContainsCACerts":
          return false;

        case "onlySomeReasons":
          return 0;

        case "indirectCRL":
          return false;

        case "onlyContainsAttributeCerts":
          return false;

        default:
          throw new Error("Invalid member name for IssuingDistributionPoint class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * IssuingDistributionPoint ::= SEQUENCE {
     *    distributionPoint          [0] DistributionPointName OPTIONAL,
     *    onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE,
     *    onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE,
     *    onlySomeReasons            [3] ReasonFlags OPTIONAL,
     *    indirectCRL                [4] BOOLEAN DEFAULT FALSE,
     *    onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
     *
     * ReasonFlags ::= BIT STRING {
     *    unused                  (0),
     *    keyCompromise           (1),
     *    cACompromise            (2),
     *    affiliationChanged      (3),
     *    superseded              (4),
     *    cessationOfOperation    (5),
     *    certificateHold         (6),
     *    privilegeWithdrawn      (7),
     *    aACompromise            (8) }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [distributionPoint]
       * @property {string} [distributionPointNames]
       * @property {string} [onlyContainsUserCerts]
       * @property {string} [onlyContainsCACerts]
       * @property {string} [onlySomeReasons]
       * @property {string} [indirectCRL]
       * @property {string} [onlyContainsAttributeCerts]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Choice({
            value: [new Constructed({
              name: names.distributionPoint || "",
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 0 // [0]

              },
              value: [new Repeated({
                name: names.distributionPointNames || "",
                value: GeneralName.schema()
              })]
            }), new Constructed({
              name: names.distributionPoint || "",
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 1 // [1]

              },
              value: RelativeDistinguishedNames.schema().valueBlock.value
            })]
          })]
        }), new Primitive({
          name: names.onlyContainsUserCerts || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          }
        }), // IMPLICIT boolean value
        new Primitive({
          name: names.onlyContainsCACerts || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          }
        }), // IMPLICIT boolean value
        new Primitive({
          name: names.onlySomeReasons || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 3 // [3]

          }
        }), // IMPLICIT bitstring value
        new Primitive({
          name: names.indirectCRL || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 4 // [4]

          }
        }), // IMPLICIT boolean value
        new Primitive({
          name: names.onlyContainsAttributeCerts || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 5 // [5]

          }
        }) // IMPLICIT boolean value
        ]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["distributionPoint", "distributionPointNames", "onlyContainsUserCerts", "onlyContainsCACerts", "onlySomeReasons", "indirectCRL", "onlyContainsAttributeCerts"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, IssuingDistributionPoint.schema({
        names: {
          distributionPoint: "distributionPoint",
          distributionPointNames: "distributionPointNames",
          onlyContainsUserCerts: "onlyContainsUserCerts",
          onlyContainsCACerts: "onlyContainsCACerts",
          onlySomeReasons: "onlySomeReasons",
          indirectCRL: "indirectCRL",
          onlyContainsAttributeCerts: "onlyContainsAttributeCerts"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint"); //endregion
      //region Get internal properties from parsed schema

      if ("distributionPoint" in asn1.result) {
        switch (true) {
          case asn1.result.distributionPoint.idBlock.tagNumber === 0:
            // GENERAL_NAMES variant
            this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new GeneralName({
              schema: element
            }));
            break;

          case asn1.result.distributionPoint.idBlock.tagNumber === 1:
            // RDN variant
            {
              this.distributionPoint = new RelativeDistinguishedNames({
                schema: new Sequence({
                  value: asn1.result.distributionPoint.valueBlock.value
                })
              });
            }
            break;

          default:
            throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}");
        }
      }

      if ("onlyContainsUserCerts" in asn1.result) {
        var view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);
        this.onlyContainsUserCerts = view[0] !== 0x00;
      }

      if ("onlyContainsCACerts" in asn1.result) {
        var _view4 = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);

        this.onlyContainsCACerts = _view4[0] !== 0x00;
      }

      if ("onlySomeReasons" in asn1.result) {
        var _view5 = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);

        this.onlySomeReasons = _view5[0];
      }

      if ("indirectCRL" in asn1.result) {
        var _view6 = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);

        this.indirectCRL = _view6[0] !== 0x00;
      }

      if ("onlyContainsAttributeCerts" in asn1.result) {
        var _view7 = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);

        this.onlyContainsAttributeCerts = _view7[0] !== 0x00;
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];

      if ("distributionPoint" in this) {
        var value;

        if (this.distributionPoint instanceof Array) {
          value = new Constructed({
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            value: Array.from(this.distributionPoint, element => element.toSchema())
          });
        } else {
          value = this.distributionPoint.toSchema();
          value.idBlock.tagClass = 3; // CONTEXT - SPECIFIC

          value.idBlock.tagNumber = 1; // [1]
        }

        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [value]
        }));
      }

      if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues("onlyContainsUserCerts")) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          valueHex: new Uint8Array([0xFF]).buffer
        }));
      }

      if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues("onlyContainsCACerts")) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          },
          valueHex: new Uint8Array([0xFF]).buffer
        }));
      }

      if ("onlySomeReasons" in this) {
        var buffer = new ArrayBuffer(1);
        var view = new Uint8Array(buffer);
        view[0] = this.onlySomeReasons;
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 3 // [3]

          },
          valueHex: buffer
        }));
      }

      if (this.indirectCRL !== IssuingDistributionPoint.defaultValues("indirectCRL")) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 4 // [4]

          },
          valueHex: new Uint8Array([0xFF]).buffer
        }));
      }

      if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts")) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 5 // [5]

          },
          valueHex: new Uint8Array([0xFF]).buffer
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {};

      if ("distributionPoint" in this) {
        if (this.distributionPoint instanceof Array) object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());else object.distributionPoint = this.distributionPoint.toJSON();
      }

      if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues("onlyContainsUserCerts")) object.onlyContainsUserCerts = this.onlyContainsUserCerts;
      if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues("onlyContainsCACerts")) object.onlyContainsCACerts = this.onlyContainsCACerts;
      if ("onlySomeReasons" in this) object.onlySomeReasons = this.onlySomeReasons;
      if (this.indirectCRL !== IssuingDistributionPoint.defaultValues("indirectCRL")) object.indirectCRL = this.indirectCRL;
      if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts")) object.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class GeneralNames {
    //**********************************************************************************

    /**
     * Constructor for GeneralNames class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<GeneralName>}
       * @desc Array of "general names"
       */
      this.names = getParametersValue(parameters, "names", GeneralNames.defaultValues("names")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "names":
          return [];

        default:
          throw new Error("Invalid member name for GeneralNames class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @param {boolean} [optional=false] Flag would be element optional or not
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      /**
       * @type {Object}
       * @property {string} utcTimeName Name for "utcTimeName" choice
       * @property {string} generalTimeName Name for "generalTimeName" choice
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        optional,
        name: names.blockName || "",
        value: [new Repeated({
          name: names.generalNames || "",
          value: GeneralName.schema()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["names", "generalNames"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, GeneralNames.schema({
        names: {
          blockName: "names",
          generalNames: "generalNames"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for GeneralNames"); //endregion
      //region Get internal properties from parsed schema

      this.names = Array.from(asn1.result.generalNames, element => new GeneralName({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.names, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        names: Array.from(this.names, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class GeneralSubtree {
    //**********************************************************************************

    /**
     * Constructor for GeneralSubtree class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {GeneralName}
       * @desc base
       */
      this.base = getParametersValue(parameters, "base", GeneralSubtree.defaultValues("base"));
      /**
       * @type {number|Integer}
       * @desc base
       */

      this.minimum = getParametersValue(parameters, "minimum", GeneralSubtree.defaultValues("minimum"));
      if ("maximum" in parameters)
        /**
         * @type {number|Integer}
         * @desc minimum
         */
        this.maximum = getParametersValue(parameters, "maximum", GeneralSubtree.defaultValues("maximum")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "base":
          return new GeneralName();

        case "minimum":
          return 0;

        case "maximum":
          return 0;

        default:
          throw new Error("Invalid member name for GeneralSubtree class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * GeneralSubtree ::= SEQUENCE {
     *    base                    GeneralName,
     *    minimum         [0]     BaseDistance DEFAULT 0,
     *    maximum         [1]     BaseDistance OPTIONAL }
     *
     * BaseDistance ::= INTEGER (0..MAX)
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [base]
       * @property {string} [minimum]
       * @property {string} [maximum]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [GeneralName.schema(names.base || {}), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Integer({
            name: names.minimum || ""
          })]
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [new Integer({
            name: names.maximum || ""
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["base", "minimum", "maximum"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, GeneralSubtree.schema({
        names: {
          base: {
            names: {
              blockName: "base"
            }
          },
          minimum: "minimum",
          maximum: "maximum"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for GeneralSubtree"); //endregion
      //region Get internal properties from parsed schema

      this.base = new GeneralName({
        schema: asn1.result.base
      });

      if ("minimum" in asn1.result) {
        if (asn1.result.minimum.valueBlock.isHexOnly) this.minimum = asn1.result.minimum;else this.minimum = asn1.result.minimum.valueBlock.valueDec;
      }

      if ("maximum" in asn1.result) {
        if (asn1.result.maximum.valueBlock.isHexOnly) this.maximum = asn1.result.maximum;else this.maximum = asn1.result.maximum.valueBlock.valueDec;
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(this.base.toSchema());

      if (this.minimum !== 0) {
        var valueMinimum = 0;
        if (this.minimum instanceof Integer) valueMinimum = this.minimum;else valueMinimum = new Integer({
          value: this.minimum
        });
        outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [valueMinimum]
        }));
      }

      if ("maximum" in this) {
        var valueMaximum = 0;
        if (this.maximum instanceof Integer) valueMaximum = this.maximum;else valueMaximum = new Integer({
          value: this.maximum
        });
        outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [valueMaximum]
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        base: this.base.toJSON()
      };

      if (this.minimum !== 0) {
        if (typeof this.minimum === "number") object.minimum = this.minimum;else object.minimum = this.minimum.toJSON();
      }

      if ("maximum" in this) {
        if (typeof this.maximum === "number") object.maximum = this.maximum;else object.maximum = this.maximum.toJSON();
      }

      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class NameConstraints {
    //**********************************************************************************

    /**
     * Constructor for NameConstraints class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("permittedSubtrees" in parameters)
        /**
         * @type {Array.<GeneralSubtree>}
         * @desc permittedSubtrees
         */
        this.permittedSubtrees = getParametersValue(parameters, "permittedSubtrees", NameConstraints.defaultValues("permittedSubtrees"));
      if ("excludedSubtrees" in parameters)
        /**
         * @type {Array.<GeneralSubtree>}
         * @desc excludedSubtrees
         */
        this.excludedSubtrees = getParametersValue(parameters, "excludedSubtrees", NameConstraints.defaultValues("excludedSubtrees")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "permittedSubtrees":
          return [];

        case "excludedSubtrees":
          return [];

        default:
          throw new Error("Invalid member name for NameConstraints class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * NameConstraints ::= SEQUENCE {
     *    permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
     *    excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [permittedSubtrees]
       * @property {string} [excludedSubtrees]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Repeated({
            name: names.permittedSubtrees || "",
            value: GeneralSubtree.schema()
          })]
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [new Repeated({
            name: names.excludedSubtrees || "",
            value: GeneralSubtree.schema()
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["permittedSubtrees", "excludedSubtrees"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, NameConstraints.schema({
        names: {
          permittedSubtrees: "permittedSubtrees",
          excludedSubtrees: "excludedSubtrees"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for NameConstraints"); //endregion
      //region Get internal properties from parsed schema

      if ("permittedSubtrees" in asn1.result) this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, element => new GeneralSubtree({
        schema: element
      }));
      if ("excludedSubtrees" in asn1.result) this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, element => new GeneralSubtree({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];

      if ("permittedSubtrees" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: Array.from(this.permittedSubtrees, element => element.toSchema())
        }));
      }

      if ("excludedSubtrees" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: Array.from(this.excludedSubtrees, element => element.toSchema())
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {};
      if ("permittedSubtrees" in this) object.permittedSubtrees = Array.from(this.permittedSubtrees, element => element.toJSON());
      if ("excludedSubtrees" in this) object.excludedSubtrees = Array.from(this.excludedSubtrees, element => element.toJSON());
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class DistributionPoint {
    //**********************************************************************************

    /**
     * Constructor for DistributionPoint class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     * @property {Object} [distributionPoint]
     * @property {Object} [reasons]
     * @property {Object} [cRLIssuer]
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("distributionPoint" in parameters)
        /**
         * @type {Array.<GeneralName>}
         * @desc distributionPoint
         */
        this.distributionPoint = getParametersValue(parameters, "distributionPoint", DistributionPoint.defaultValues("distributionPoint"));
      if ("reasons" in parameters)
        /**
         * @type {BitString}
         * @desc values
         */
        this.reasons = getParametersValue(parameters, "reasons", DistributionPoint.defaultValues("reasons"));
      if ("cRLIssuer" in parameters)
        /**
         * @type {Array.<GeneralName>}
         * @desc cRLIssuer
         */
        this.cRLIssuer = getParametersValue(parameters, "cRLIssuer", DistributionPoint.defaultValues("cRLIssuer")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "distributionPoint":
          return [];

        case "reasons":
          return new BitString();

        case "cRLIssuer":
          return [];

        default:
          throw new Error("Invalid member name for DistributionPoint class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * DistributionPoint ::= SEQUENCE {
     *    distributionPoint       [0]     DistributionPointName OPTIONAL,
     *    reasons                 [1]     ReasonFlags OPTIONAL,
     *    cRLIssuer               [2]     GeneralNames OPTIONAL }
     *
     * DistributionPointName ::= CHOICE {
     *    fullName                [0]     GeneralNames,
     *    nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }
     *
     * ReasonFlags ::= BIT STRING {
     *    unused                  (0),
     *    keyCompromise           (1),
     *    cACompromise            (2),
     *    affiliationChanged      (3),
     *    superseded              (4),
     *    cessationOfOperation    (5),
     *    certificateHold         (6),
     *    privilegeWithdrawn      (7),
     *    aACompromise            (8) }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [distributionPoint]
       * @property {string} [distributionPointNames]
       * @property {string} [reasons]
       * @property {string} [cRLIssuer]
       * @property {string} [cRLIssuerNames]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Choice({
            value: [new Constructed({
              name: names.distributionPoint || "",
              optional: true,
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 0 // [0]

              },
              value: [new Repeated({
                name: names.distributionPointNames || "",
                value: GeneralName.schema()
              })]
            }), new Constructed({
              name: names.distributionPoint || "",
              optional: true,
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 1 // [1]

              },
              value: RelativeDistinguishedNames.schema().valueBlock.value
            })]
          })]
        }), new Primitive({
          name: names.reasons || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          }
        }), // IMPLICIT bitstring value
        new Constructed({
          name: names.cRLIssuer || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          },
          value: [new Repeated({
            name: names.cRLIssuerNames || "",
            value: GeneralName.schema()
          })]
        }) // IMPLICIT bitstring value
        ]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["distributionPoint", "distributionPointNames", "reasons", "cRLIssuer", "cRLIssuerNames"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, DistributionPoint.schema({
        names: {
          distributionPoint: "distributionPoint",
          distributionPointNames: "distributionPointNames",
          reasons: "reasons",
          cRLIssuer: "cRLIssuer",
          cRLIssuerNames: "cRLIssuerNames"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for DistributionPoint"); //endregion
      //region Get internal properties from parsed schema

      if ("distributionPoint" in asn1.result) {
        if (asn1.result.distributionPoint.idBlock.tagNumber === 0) // GENERAL_NAMES variant
          this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new GeneralName({
            schema: element
          }));

        if (asn1.result.distributionPoint.idBlock.tagNumber === 1) // RDN variant
          {
            this.distributionPoint = new RelativeDistinguishedNames({
              schema: new Sequence({
                value: asn1.result.distributionPoint.valueBlock.value
              })
            });
          }
      }

      if ("reasons" in asn1.result) this.reasons = new BitString({
        valueHex: asn1.result.reasons.valueBlock.valueHex
      });
      if ("cRLIssuer" in asn1.result) this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, element => new GeneralName({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];

      if ("distributionPoint" in this) {
        var internalValue;

        if (this.distributionPoint instanceof Array) {
          internalValue = new Constructed({
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            value: Array.from(this.distributionPoint, element => element.toSchema())
          });
        } else {
          internalValue = new Constructed({
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 1 // [1]

            },
            value: [this.distributionPoint.toSchema()]
          });
        }

        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [internalValue]
        }));
      }

      if ("reasons" in this) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          valueHex: this.reasons.valueBlock.valueHex
        }));
      }

      if ("cRLIssuer" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          },
          value: Array.from(this.cRLIssuer, element => element.toSchema())
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {};

      if ("distributionPoint" in this) {
        if (this.distributionPoint instanceof Array) object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());else object.distributionPoint = this.distributionPoint.toJSON();
      }

      if ("reasons" in this) object.reasons = this.reasons.toJSON();
      if ("cRLIssuer" in this) object.cRLIssuer = Array.from(this.cRLIssuer, element => element.toJSON());
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class CRLDistributionPoints {
    //**********************************************************************************

    /**
     * Constructor for CRLDistributionPoints class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<DistributionPoint>}
       * @desc distributionPoints
       */
      this.distributionPoints = getParametersValue(parameters, "distributionPoints", CRLDistributionPoints.defaultValues("distributionPoints")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "distributionPoints":
          return [];

        default:
          throw new Error("Invalid member name for CRLDistributionPoints class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [distributionPoints]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.distributionPoints || "",
          value: DistributionPoint.schema()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["distributionPoints"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, CRLDistributionPoints.schema({
        names: {
          distributionPoints: "distributionPoints"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CRLDistributionPoints"); //endregion
      //region Get internal properties from parsed schema

      this.distributionPoints = Array.from(asn1.result.distributionPoints, element => new DistributionPoint({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.distributionPoints, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        distributionPoints: Array.from(this.distributionPoints, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class PolicyQualifierInfo {
    //**********************************************************************************

    /**
     * Constructor for PolicyQualifierInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc policyQualifierId
       */
      this.policyQualifierId = getParametersValue(parameters, "policyQualifierId", PolicyQualifierInfo.defaultValues("policyQualifierId"));
      /**
       * @type {Object}
       * @desc qualifier
       */

      this.qualifier = getParametersValue(parameters, "qualifier", PolicyQualifierInfo.defaultValues("qualifier")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "policyQualifierId":
          return "";

        case "qualifier":
          return new Any();

        default:
          throw new Error("Invalid member name for PolicyQualifierInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PolicyQualifierInfo ::= SEQUENCE {
     *    policyQualifierId  PolicyQualifierId,
     *    qualifier          ANY DEFINED BY policyQualifierId }
     *
     * id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
     * id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
     * id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
     *
     * PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [policyQualifierId]
       * @property {string} [qualifier]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.policyQualifierId || ""
        }), new Any({
          name: names.qualifier || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["policyQualifierId", "qualifier"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PolicyQualifierInfo.schema({
        names: {
          policyQualifierId: "policyQualifierId",
          qualifier: "qualifier"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo"); //endregion
      //region Get internal properties from parsed schema

      this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();
      this.qualifier = asn1.result.qualifier; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new ObjectIdentifier({
          value: this.policyQualifierId
        }), this.qualifier]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        policyQualifierId: this.policyQualifierId,
        qualifier: this.qualifier.toJSON()
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class PolicyInformation {
    //**********************************************************************************

    /**
     * Constructor for PolicyInformation class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc policyIdentifier
       */
      this.policyIdentifier = getParametersValue(parameters, "policyIdentifier", PolicyInformation.defaultValues("policyIdentifier"));
      if ("policyQualifiers" in parameters)
        /**
         * @type {Array.<PolicyQualifierInfo>}
         * @desc Value of the TIME class
         */
        this.policyQualifiers = getParametersValue(parameters, "policyQualifiers", PolicyInformation.defaultValues("policyQualifiers")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "policyIdentifier":
          return "";

        case "policyQualifiers":
          return [];

        default:
          throw new Error("Invalid member name for PolicyInformation class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PolicyInformation ::= SEQUENCE {
     *    policyIdentifier   CertPolicyId,
     *    policyQualifiers   SEQUENCE SIZE (1..MAX) OF
     *    PolicyQualifierInfo OPTIONAL }
     *
     * CertPolicyId ::= OBJECT IDENTIFIER
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [policyIdentifier]
       * @property {string} [policyQualifiers]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.policyIdentifier || ""
        }), new Sequence({
          optional: true,
          value: [new Repeated({
            name: names.policyQualifiers || "",
            value: PolicyQualifierInfo.schema()
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["policyIdentifier", "policyQualifiers"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PolicyInformation.schema({
        names: {
          policyIdentifier: "policyIdentifier",
          policyQualifiers: "policyQualifiers"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyInformation"); //endregion
      //region Get internal properties from parsed schema

      this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();
      if ("policyQualifiers" in asn1.result) this.policyQualifiers = Array.from(asn1.result.policyQualifiers, element => new PolicyQualifierInfo({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(new ObjectIdentifier({
        value: this.policyIdentifier
      }));

      if ("policyQualifiers" in this) {
        outputArray.push(new Sequence({
          value: Array.from(this.policyQualifiers, element => element.toSchema())
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        policyIdentifier: this.policyIdentifier
      };
      if ("policyQualifiers" in this) object.policyQualifiers = Array.from(this.policyQualifiers, element => element.toJSON());
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class CertificatePolicies {
    //**********************************************************************************

    /**
     * Constructor for CertificatePolicies class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<PolicyInformation>}
       * @desc certificatePolicies
       */
      this.certificatePolicies = getParametersValue(parameters, "certificatePolicies", CertificatePolicies.defaultValues("certificatePolicies")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "certificatePolicies":
          return [];

        default:
          throw new Error("Invalid member name for CertificatePolicies class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * certificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [certificatePolicies]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.certificatePolicies || "",
          value: PolicyInformation.schema()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["certificatePolicies"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, CertificatePolicies.schema({
        names: {
          certificatePolicies: "certificatePolicies"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertificatePolicies"); //endregion
      //region Get internal properties from parsed schema

      this.certificatePolicies = Array.from(asn1.result.certificatePolicies, element => new PolicyInformation({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.certificatePolicies, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        certificatePolicies: Array.from(this.certificatePolicies, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class PolicyMapping {
    //**********************************************************************************

    /**
     * Constructor for PolicyMapping class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc issuerDomainPolicy
       */
      this.issuerDomainPolicy = getParametersValue(parameters, "issuerDomainPolicy", PolicyMapping.defaultValues("issuerDomainPolicy"));
      /**
       * @type {string}
       * @desc subjectDomainPolicy
       */

      this.subjectDomainPolicy = getParametersValue(parameters, "subjectDomainPolicy", PolicyMapping.defaultValues("subjectDomainPolicy")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "issuerDomainPolicy":
          return "";

        case "subjectDomainPolicy":
          return "";

        default:
          throw new Error("Invalid member name for PolicyMapping class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PolicyMapping ::= SEQUENCE {
     *    issuerDomainPolicy      CertPolicyId,
     *    subjectDomainPolicy     CertPolicyId }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [issuerDomainPolicy]
       * @property {string} [subjectDomainPolicy]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.issuerDomainPolicy || ""
        }), new ObjectIdentifier({
          name: names.subjectDomainPolicy || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["issuerDomainPolicy", "subjectDomainPolicy"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PolicyMapping.schema({
        names: {
          issuerDomainPolicy: "issuerDomainPolicy",
          subjectDomainPolicy: "subjectDomainPolicy"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyMapping"); //endregion
      //region Get internal properties from parsed schema

      this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();
      this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString(); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new ObjectIdentifier({
          value: this.issuerDomainPolicy
        }), new ObjectIdentifier({
          value: this.subjectDomainPolicy
        })]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        issuerDomainPolicy: this.issuerDomainPolicy,
        subjectDomainPolicy: this.subjectDomainPolicy
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class PolicyMappings {
    //**********************************************************************************

    /**
     * Constructor for PolicyMappings class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<PolicyMapping>}
       * @desc mappings
       */
      this.mappings = getParametersValue(parameters, "mappings", PolicyMappings.defaultValues("mappings")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "mappings":
          return [];

        default:
          throw new Error("Invalid member name for PolicyMappings class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF PolicyMapping
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [utcTimeName] Name for "utcTimeName" choice
       * @property {string} [generalTimeName] Name for "generalTimeName" choice
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.mappings || "",
          value: PolicyMapping.schema()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["mappings"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PolicyMappings.schema({
        names: {
          mappings: "mappings"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyMappings"); //endregion
      //region Get internal properties from parsed schema

      this.mappings = Array.from(asn1.result.mappings, element => new PolicyMapping({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.mappings, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        mappings: Array.from(this.mappings, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class AuthorityKeyIdentifier {
    //**********************************************************************************

    /**
     * Constructor for AuthorityKeyIdentifier class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("keyIdentifier" in parameters)
        /**
         * @type {OctetString}
         * @desc keyIdentifier
         */
        this.keyIdentifier = getParametersValue(parameters, "keyIdentifier", AuthorityKeyIdentifier.defaultValues("keyIdentifier"));
      if ("authorityCertIssuer" in parameters)
        /**
         * @type {Array.<GeneralName>}
         * @desc authorityCertIssuer
         */
        this.authorityCertIssuer = getParametersValue(parameters, "authorityCertIssuer", AuthorityKeyIdentifier.defaultValues("authorityCertIssuer"));
      if ("authorityCertSerialNumber" in parameters)
        /**
         * @type {Integer}
         * @desc authorityCertIssuer
         */
        this.authorityCertSerialNumber = getParametersValue(parameters, "authorityCertSerialNumber", AuthorityKeyIdentifier.defaultValues("authorityCertSerialNumber")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "keyIdentifier":
          return new OctetString();

        case "authorityCertIssuer":
          return [];

        case "authorityCertSerialNumber":
          return new Integer();

        default:
          throw new Error("Invalid member name for AuthorityKeyIdentifier class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AuthorityKeyIdentifier OID ::= 2.5.29.35
     *
     * AuthorityKeyIdentifier ::= SEQUENCE {
     *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,
     *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,
     *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
     *
     * KeyIdentifier ::= OCTET STRING
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [keyIdentifier]
       * @property {string} [authorityCertIssuer]
       * @property {string} [authorityCertSerialNumber]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Primitive({
          name: names.keyIdentifier || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          }
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [new Repeated({
            name: names.authorityCertIssuer || "",
            value: GeneralName.schema()
          })]
        }), new Primitive({
          name: names.authorityCertSerialNumber || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          }
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["keyIdentifier", "authorityCertIssuer", "authorityCertSerialNumber"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AuthorityKeyIdentifier.schema({
        names: {
          keyIdentifier: "keyIdentifier",
          authorityCertIssuer: "authorityCertIssuer",
          authorityCertSerialNumber: "authorityCertSerialNumber"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier"); //endregion
      //region Get internal properties from parsed schema

      if ("keyIdentifier" in asn1.result) this.keyIdentifier = new OctetString({
        valueHex: asn1.result.keyIdentifier.valueBlock.valueHex
      });
      if ("authorityCertIssuer" in asn1.result) this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, element => new GeneralName({
        schema: element
      }));
      if ("authorityCertSerialNumber" in asn1.result) this.authorityCertSerialNumber = new Integer({
        valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];

      if ("keyIdentifier" in this) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          valueHex: this.keyIdentifier.valueBlock.valueHex
        }));
      }

      if ("authorityCertIssuer" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: Array.from(this.authorityCertIssuer, element => element.toSchema())
        }));
      }

      if ("authorityCertSerialNumber" in this) {
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          },
          valueHex: this.authorityCertSerialNumber.valueBlock.valueHex
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {};
      if ("keyIdentifier" in this) object.keyIdentifier = this.keyIdentifier.toJSON();
      if ("authorityCertIssuer" in this) object.authorityCertIssuer = Array.from(this.authorityCertIssuer, element => element.toJSON());
      if ("authorityCertSerialNumber" in this) object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class PolicyConstraints {
    //**********************************************************************************

    /**
     * Constructor for PolicyConstraints class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("requireExplicitPolicy" in parameters)
        /**
         * @type {number}
         * @desc requireExplicitPolicy
         */
        this.requireExplicitPolicy = getParametersValue(parameters, "requireExplicitPolicy", PolicyConstraints.defaultValues("requireExplicitPolicy"));
      if ("inhibitPolicyMapping" in parameters)
        /**
         * @type {number}
         * @desc Value of the TIME class
         */
        this.inhibitPolicyMapping = getParametersValue(parameters, "inhibitPolicyMapping", PolicyConstraints.defaultValues("inhibitPolicyMapping")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "requireExplicitPolicy":
          return 0;

        case "inhibitPolicyMapping":
          return 0;

        default:
          throw new Error("Invalid member name for PolicyConstraints class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * PolicyConstraints ::= SEQUENCE {
     *    requireExplicitPolicy           [0] SkipCerts OPTIONAL,
     *    inhibitPolicyMapping            [1] SkipCerts OPTIONAL }
     *
     * SkipCerts ::= INTEGER (0..MAX)
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [requireExplicitPolicy]
       * @property {string} [inhibitPolicyMapping]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Primitive({
          name: names.requireExplicitPolicy || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          }
        }), // IMPLICIT integer value
        new Primitive({
          name: names.inhibitPolicyMapping || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          }
        }) // IMPLICIT integer value
        ]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["requireExplicitPolicy", "inhibitPolicyMapping"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, PolicyConstraints.schema({
        names: {
          requireExplicitPolicy: "requireExplicitPolicy",
          inhibitPolicyMapping: "inhibitPolicyMapping"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyConstraints"); //endregion
      //region Get internal properties from parsed schema

      if ("requireExplicitPolicy" in asn1.result) {
        var field1 = asn1.result.requireExplicitPolicy;
        field1.idBlock.tagClass = 1; // UNIVERSAL

        field1.idBlock.tagNumber = 2; // INTEGER

        var ber1 = field1.toBER(false);
        var int1 = fromBER(ber1);
        this.requireExplicitPolicy = int1.result.valueBlock.valueDec;
      }

      if ("inhibitPolicyMapping" in asn1.result) {
        var field2 = asn1.result.inhibitPolicyMapping;
        field2.idBlock.tagClass = 1; // UNIVERSAL

        field2.idBlock.tagNumber = 2; // INTEGER

        var ber2 = field2.toBER(false);
        var int2 = fromBER(ber2);
        this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create correct values for output sequence
      var outputArray = [];

      if ("requireExplicitPolicy" in this) {
        var int1 = new Integer({
          value: this.requireExplicitPolicy
        });
        int1.idBlock.tagClass = 3; // CONTEXT-SPECIFIC

        int1.idBlock.tagNumber = 0; // [0]

        outputArray.push(int1);
      }

      if ("inhibitPolicyMapping" in this) {
        var int2 = new Integer({
          value: this.inhibitPolicyMapping
        });
        int2.idBlock.tagClass = 3; // CONTEXT-SPECIFIC

        int2.idBlock.tagNumber = 1; // [1]

        outputArray.push(int2);
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {};
      if ("requireExplicitPolicy" in this) object.requireExplicitPolicy = this.requireExplicitPolicy;
      if ("inhibitPolicyMapping" in this) object.inhibitPolicyMapping = this.inhibitPolicyMapping;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class ExtKeyUsage {
    //**********************************************************************************

    /**
     * Constructor for ExtKeyUsage class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<string>}
       * @desc keyPurposes
       */
      this.keyPurposes = getParametersValue(parameters, "keyPurposes", ExtKeyUsage.defaultValues("keyPurposes")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "keyPurposes":
          return [];

        default:
          throw new Error("Invalid member name for ExtKeyUsage class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * ExtKeyUsage ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
     *
     * KeyPurposeId ::= OBJECT IDENTIFIER
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [keyPurposes]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.keyPurposes || "",
          value: new ObjectIdentifier()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["keyPurposes"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, ExtKeyUsage.schema({
        names: {
          keyPurposes: "keyPurposes"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ExtKeyUsage"); //endregion
      //region Get internal properties from parsed schema

      this.keyPurposes = Array.from(asn1.result.keyPurposes, element => element.valueBlock.toString()); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.keyPurposes, element => new ObjectIdentifier({
          value: element
        }))
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        keyPurposes: Array.from(this.keyPurposes)
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class AccessDescription {
    //**********************************************************************************

    /**
     * Constructor for AccessDescription class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc The type and format of the information are specified by the accessMethod field. This profile defines two accessMethod OIDs: id-ad-caIssuers and id-ad-ocsp
       */
      this.accessMethod = getParametersValue(parameters, "accessMethod", AccessDescription.defaultValues("accessMethod"));
      /**
       * @type {GeneralName}
       * @desc The accessLocation field specifies the location of the information
       */

      this.accessLocation = getParametersValue(parameters, "accessLocation", AccessDescription.defaultValues("accessLocation")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "accessMethod":
          return "";

        case "accessLocation":
          return new GeneralName();

        default:
          throw new Error("Invalid member name for AccessDescription class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AccessDescription  ::=  SEQUENCE {
     *    accessMethod          OBJECT IDENTIFIER,
     *    accessLocation        GeneralName  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [accessMethod]
       * @property {string} [accessLocation]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.accessMethod || ""
        }), GeneralName.schema(names.accessLocation || {})]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["accessMethod", "accessLocation"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AccessDescription.schema({
        names: {
          accessMethod: "accessMethod",
          accessLocation: {
            names: {
              blockName: "accessLocation"
            }
          }
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AccessDescription"); //endregion
      //region Get internal properties from parsed schema

      this.accessMethod = asn1.result.accessMethod.valueBlock.toString();
      this.accessLocation = new GeneralName({
        schema: asn1.result.accessLocation
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new ObjectIdentifier({
          value: this.accessMethod
        }), this.accessLocation.toSchema()]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        accessMethod: this.accessMethod,
        accessLocation: this.accessLocation.toJSON()
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class InfoAccess {
    //**********************************************************************************

    /**
     * Constructor for InfoAccess class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<AccessDescription>}
       * @desc accessDescriptions
       */
      this.accessDescriptions = getParametersValue(parameters, "accessDescriptions", InfoAccess.defaultValues("accessDescriptions")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "accessDescriptions":
          return [];

        default:
          throw new Error("Invalid member name for InfoAccess class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AuthorityInfoAccessSyntax  ::=
     * SEQUENCE SIZE (1..MAX) OF AccessDescription
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [accessDescriptions]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.accessDescriptions || "",
          value: AccessDescription.schema()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["accessDescriptions"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, InfoAccess.schema({
        names: {
          accessDescriptions: "accessDescriptions"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for InfoAccess"); //endregion
      //region Get internal properties from parsed schema

      this.accessDescriptions = Array.from(asn1.result.accessDescriptions, element => new AccessDescription({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.accessDescriptions, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        accessDescriptions: Array.from(this.accessDescriptions, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************

  /*
   * Copyright (c) 2016-2018, Peculiar Ventures
   * All rights reserved.
   *
   * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.
   *
   */
  //**************************************************************************************


  class ByteStream {
    //**********************************************************************************
    // noinspection  WithMultipleLoopsJS

    /**
     * Constructor for ByteStream class
     * @param {{[length]: number, [stub]: number, [view]: Uint8Array, [buffer]: ArrayBuffer, [string]: string, [hexstring]: string}} parameters
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.clear();

      for (var _i30 = 0, _Object$keys9 = Object.keys(parameters); _i30 < _Object$keys9.length; _i30++) {
        var key = _Object$keys9[_i30];

        switch (key) {
          case "length":
            this.length = parameters.length;
            break;

          case "stub":
            // noinspection NonBlockStatementBodyJS
            for (var i = 0; i < this._view.length; i++) {
              this._view[i] = parameters.stub;
            }

            break;

          case "view":
            this.fromUint8Array(parameters.view);
            break;

          case "buffer":
            this.fromArrayBuffer(parameters.buffer);
            break;

          case "string":
            this.fromString(parameters.string);
            break;

          case "hexstring":
            this.fromHexString(parameters.hexstring);
            break;

          default:
        }
      }
    } //**********************************************************************************

    /**
     * Setter for "buffer"
     * @param {ArrayBuffer} value
     */


    set buffer(value) {
      this._buffer = value.slice(0);
      this._view = new Uint8Array(this._buffer);
    } //**********************************************************************************

    /**
     * Getter for "buffer"
     * @returns {ArrayBuffer}
     */


    get buffer() {
      return this._buffer;
    } //**********************************************************************************

    /**
     * Setter for "view"
     * @param {Uint8Array} value
     */


    set view(value) {
      this._buffer = new ArrayBuffer(value.length);
      this._view = new Uint8Array(this._buffer);

      this._view.set(value);
    } //**********************************************************************************

    /**
     * Getter for "view"
     * @returns {Uint8Array}
     */


    get view() {
      return this._view;
    } //**********************************************************************************

    /**
     * Getter for "length"
     * @returns {number}
     */


    get length() {
      return this._buffer.byteLength;
    } //**********************************************************************************

    /**
     * Setter for "length"
     * @param {number} value
     */


    set length(value) {
      this._buffer = new ArrayBuffer(value);
      this._view = new Uint8Array(this._buffer);
    } //**********************************************************************************

    /**
     * Clear existing stream
     */


    clear() {
      this._buffer = new ArrayBuffer(0);
      this._view = new Uint8Array(this._buffer);
    } //**********************************************************************************

    /**
     * Initialize "Stream" object from existing "ArrayBuffer"
     * @param {!ArrayBuffer} array The ArrayBuffer to copy from
     */


    fromArrayBuffer(array) {
      this.buffer = array;
    } //**********************************************************************************
    // noinspection  NamingConventionJS

    /**
     * Initialize "Stream" object from existing "Uint8Array"
     * @param {!Uint8Array} array The Uint8Array to copy from
     */


    fromUint8Array(array) {
      this._buffer = new ArrayBuffer(array.length);
      this._view = new Uint8Array(this._buffer);

      this._view.set(array);
    } //**********************************************************************************

    /**
     * Initialize "Stream" object from existing string
     * @param {string} string The string to initialize from
     */


    fromString(string) {
      var stringLength = string.length;
      this.length = stringLength; // noinspection NonBlockStatementBodyJS

      for (var i = 0; i < stringLength; i++) {
        this.view[i] = string.charCodeAt(i);
      }
    } //**********************************************************************************

    /**
     * Represent "Stream" object content as a string
     * @param {number} [start] Start position to convert to string
     * @param {number} [length] Length of array to convert to string
     * @returns {string}
     */


    toString() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.view.length - start;
      //region Initial variables
      var result = ""; //endregion
      //region Check input parameters
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (start >= this.view.length || start < 0) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      } // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS


      if (length >= this.view.length || length < 0) {
        // noinspection AssignmentTo ParameterJS
        length = this.view.length - start;
      } //endregion
      //region Convert array of bytes to string
      // noinspection NonBlockStatementBodyJS


      for (var i = start; i < start + length; i++) {
        result += String.fromCharCode(this.view[i]);
      } //endregion


      return result;
    } //**********************************************************************************
    // noinspection  TooLongJS

    /**
     * Initialize "Stream" object from existing hexdecimal string
     * @param {string} hexString String to initialize from
     */


    fromHexString(hexString) {
      //region Initial variables
      var stringLength = hexString.length;
      this.buffer = new ArrayBuffer(stringLength >> 1);
      this.view = new Uint8Array(this.buffer);
      var hexMap = new Map(); // noinspection MagicNumberJS

      hexMap.set("0", 0x00); // noinspection MagicNumberJS

      hexMap.set("1", 0x01); // noinspection MagicNumberJS

      hexMap.set("2", 0x02); // noinspection MagicNumberJS

      hexMap.set("3", 0x03); // noinspection MagicNumberJS

      hexMap.set("4", 0x04); // noinspection MagicNumberJS

      hexMap.set("5", 0x05); // noinspection MagicNumberJS

      hexMap.set("6", 0x06); // noinspection MagicNumberJS

      hexMap.set("7", 0x07); // noinspection MagicNumberJS

      hexMap.set("8", 0x08); // noinspection MagicNumberJS

      hexMap.set("9", 0x09); // noinspection MagicNumberJS

      hexMap.set("A", 0x0A); // noinspection MagicNumberJS

      hexMap.set("a", 0x0A); // noinspection MagicNumberJS

      hexMap.set("B", 0x0B); // noinspection MagicNumberJS

      hexMap.set("b", 0x0B); // noinspection MagicNumberJS

      hexMap.set("C", 0x0C); // noinspection MagicNumberJS

      hexMap.set("c", 0x0C); // noinspection MagicNumberJS

      hexMap.set("D", 0x0D); // noinspection MagicNumberJS

      hexMap.set("d", 0x0D); // noinspection MagicNumberJS

      hexMap.set("E", 0x0E); // noinspection MagicNumberJS

      hexMap.set("e", 0x0E); // noinspection MagicNumberJS

      hexMap.set("F", 0x0F); // noinspection MagicNumberJS

      hexMap.set("f", 0x0F);
      var j = 0; // noinspection MagicNumberJS

      var temp = 0x00; //endregion
      //region Convert char-by-char

      for (var i = 0; i < stringLength; i++) {
        // noinspection NegatedIfStatementJS
        if (!(i % 2)) {
          // noinspection Nested CallJS
          temp = hexMap.get(hexString.charAt(i)) << 4;
        } else {
          // noinspection Nested CallJS
          temp |= hexMap.get(hexString.charAt(i));
          this.view[j] = temp;
          j++;
        }
      } //endregion

    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Represent "Stream" object content as a hexdecimal string
     * @param {number} [start=0] Start position to convert to string
     * @param {number} [length=(this.view.length - start)] Length of array to convert to string
     * @returns {string}
     */


    toHexString() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.view.length - start;
      //region Initial variables
      var result = ""; //endregion
      //region Check input parameters
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (start >= this.view.length || start < 0) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      } // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS


      if (length >= this.view.length || length < 0) {
        // noinspection AssignmentTo ParameterJS
        length = this.view.length - start;
      } //endregion


      for (var i = start; i < start + length; i++) {
        // noinspection Chained CallJS
        var str = this.view[i].toString(16).toUpperCase(); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS

        result = result + (str.length == 1 ? "0" : "") + str;
      }

      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS

    /**
     * Return copy of existing "Stream"
     * @param {number} [start=0] Start position of the copy
     * @param {number} [length=this.view.length] Length of the copy
     * @returns {ByteStream}
     */


    copy() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._buffer.byteLength - start;
      //region Check input parameters
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
      if (start === 0 && this._buffer.byteLength === 0) return new ByteStream(); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS

      if (start < 0 || start > this._buffer.byteLength - 1) throw new Error("Wrong start position: ".concat(start)); //endregion

      var stream = new ByteStream();
      stream._buffer = this._buffer.slice(start, start + length);
      stream._view = new Uint8Array(stream._buffer);
      return stream;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Return slice of existing "Stream"
     * @param {number} [start=0] Start position of the slice
     * @param {number} [end=this._buffer.byteLength] End position of the slice
     * @returns {ByteStream}
     */


    slice() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._buffer.byteLength;
      //region Check input parameters
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
      if (start === 0 && this._buffer.byteLength === 0) return new ByteStream(); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS

      if (start < 0 || start > this._buffer.byteLength - 1) throw new Error("Wrong start position: ".concat(start)); //endregion

      var stream = new ByteStream();
      stream._buffer = this._buffer.slice(start, end);
      stream._view = new Uint8Array(stream._buffer);
      return stream;
    } //**********************************************************************************

    /**
     * Change size of existing "Stream"
     * @param {!number} size Size for new "Stream"
     */


    realloc(size) {
      //region Initial variables
      var buffer = new ArrayBuffer(size);
      var view = new Uint8Array(buffer); //endregion
      //region Create a new ArrayBuffer content
      // noinspection NonBlockStatementBodyJS

      if (size > this._view.length) view.set(this._view);else {
        // noinspection Nested CallJS
        view.set(new Uint8Array(this._buffer, 0, size));
      } //endregion
      //region Initialize "Stream" with new "ArrayBuffer"

      this._buffer = buffer.slice(0);
      this._view = new Uint8Array(this._buffer); //endregion
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Append a new "Stream" content to the current "Stream"
     * @param {ByteStream} stream A new "stream" to append to current "stream"
     */


    append(stream) {
      //region Initial variables
      var initialSize = this._buffer.byteLength;
      var streamViewLength = stream._buffer.byteLength;

      var copyView = stream._view.slice(); //endregion
      //region Re-allocate current internal buffer


      this.realloc(initialSize + streamViewLength); //endregion
      //region Copy input stream content to a new place

      this._view.set(copyView, initialSize); //endregion

    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Insert "Stream" content to the current "Stream" at specific position
     * @param {ByteStream} stream A new "stream" to insert to current "stream"
     * @param {number} [start=0] Start position to insert to
     * @param {number} [length]
     * @returns {boolean}
     */


    insert(stream) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._buffer.byteLength - start;
      //region Initial variables
      // noinspection NonBlockStatementBodyJS
      if (start > this._buffer.byteLength - 1) return false;

      if (length > this._buffer.byteLength - start) {
        // noinspection AssignmentTo ParameterJS
        length = this._buffer.byteLength - start;
      } //endregion
      //region Check input variables


      if (length > stream._buffer.byteLength) {
        // noinspection AssignmentTo ParameterJS
        length = stream._buffer.byteLength;
      } //endregion
      //region Update content of the current stream
      // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS


      if (length == stream._buffer.byteLength) this._view.set(stream._view, start);else {
        // noinspection Nested CallJS
        this._view.set(stream._view.slice(0, length), start);
      } //endregion

      return true;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS

    /**
     * Check that two "Stream" objects has equal content
     * @param {ByteStream} stream Stream to compare with
     * @returns {boolean}
     */


    isEqual(stream) {
      //region Check length of both buffers
      // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
      if (this._buffer.byteLength != stream._buffer.byteLength) return false; //endregion
      //region Compare each byte of both buffers

      for (var i = 0; i < stream._buffer.byteLength; i++) {
        // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
        if (this.view[i] != stream.view[i]) return false;
      } //endregion


      return true;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Check that current "Stream" objects has equal content with input "Uint8Array"
     * @param {Uint8Array} view View to compare with
     * @returns {boolean}
     */


    isEqualView(view) {
      //region Check length of both buffers
      // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
      if (view.length != this.view.length) return false; //endregion
      //region Compare each byte of both buffers

      for (var i = 0; i < view.length; i++) {
        // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
        if (this.view[i] != view[i]) return false;
      } //endregion


      return true;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleLoopsJS,  WithMultipleReturnPointsJS, OverlyComplex JS,  TooLongJS

    /**
     * Find any byte pattern in "Stream"
     * @param {ByteStream} pattern Stream having pattern value
     * @param {?number} [start] Start position to search from
     * @param {?number} [length] Length of byte block to search at
     * @param {boolean} [backward] Flag to search in backward order
     * @returns {number}
     */


    findPattern(pattern) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      //region Check input variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (start == null) {
        // noinspection AssignmentTo ParameterJS, ConditionalExpressionJS
        start = backward ? this.buffer.byteLength : 0;
      }

      if (start > this.buffer.byteLength) {
        // noinspection AssignmentTo ParameterJS
        start = this.buffer.byteLength;
      }

      if (backward) {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }

        if (length > start) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }
      } else {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }

        if (length > this.buffer.byteLength - start) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }
      } //endregion
      //region Initial variables


      var patternLength = pattern.buffer.byteLength; // noinspection NonBlockStatementBodyJS

      if (patternLength > length) return -1; //endregion
      //region Make a "pre-read" array for pattern

      var patternArray = []; // noinspection NonBlockStatementBodyJS

      for (var i = 0; i < patternLength; i++) {
        patternArray.push(pattern.view[i]);
      } //endregion
      //region Search for pattern


      for (var _i31 = 0; _i31 <= length - patternLength; _i31++) {
        var equal = true; // noinspection ConditionalExpressionJS

        var equalStart = backward ? start - patternLength - _i31 : start + _i31;

        for (var j = 0; j < patternLength; j++) {
          // noinspection EqualityComparisonWithCoercionJS
          if (this.view[j + equalStart] != patternArray[j]) {
            equal = false; // noinspection BreakStatementJS

            break;
          }
        }

        if (equal) {
          // noinspection ConditionalExpressionJS
          return backward ? start - patternLength - _i31 : start + patternLength + _i31; // Position after the pattern found
        }
      } //endregion


      return -1;
    } //**********************************************************************************
    // noinspection OverlyComplex JS

    /**
     * Find first position of any pattern from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be found
     * @param {?number} [start] Start position to search from
     * @param {?number} [length] Length of byte block to search at
     * @param {boolean} [backward=false] Flag to search in backward order
     * @returns {{id: number, position: number}}
     */


    findFirstIn(patterns) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (start == null) {
        // noinspection AssignmentTo ParameterJS, ConditionalExpressionJS
        start = backward ? this.buffer.byteLength : 0;
      }

      if (start > this.buffer.byteLength) {
        // noinspection AssignmentTo ParameterJS
        start = this.buffer.byteLength;
      }

      if (backward) {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }

        if (length > start) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }
      } else {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }

        if (length > this.buffer.byteLength - start) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }
      } // noinspection ConditionalExpressionJS


      var result = {
        id: -1,
        position: backward ? 0 : start + length,
        length: 0
      }; //endregion

      for (var i = 0; i < patterns.length; i++) {
        var position = this.findPattern(patterns[i], start, length, backward); // noinspection EqualityComparisonWithCoercionJS

        if (position != -1) {
          var valid = false;
          var patternLength = patterns[i].length;

          if (backward) {
            // noinspection NonBlockStatementBodyJS
            if (position - patternLength >= result.position - result.length) valid = true;
          } else {
            // noinspection NonBlockStatementBodyJS
            if (position - patternLength <= result.position - result.length) valid = true;
          }

          if (valid) {
            result.position = position;
            result.id = i;
            result.length = patternLength;
          }
        }
      }

      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS

    /**
     * Find all positions of any pattern from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be found
     * @param {?number} [start] Start position to search from
     * @param {?number} [length] Length of byte block to search at
     * @returns {Array}
     */


    findAllIn(patterns) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.buffer.byteLength - start;
      //region Initial variables
      var result = []; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (start == null) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      } // noinspection NonBlockStatementBodyJS


      if (start > this.buffer.byteLength - 1) return result; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (length == null) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      if (length > this.buffer.byteLength - start) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      var patternFound = {
        id: -1,
        position: start
      }; //endregion
      //region Find all accurences of patterns

      do {
        var position = patternFound.position;
        patternFound = this.findFirstIn(patterns, patternFound.position, length); // noinspection EqualityComparisonWithCoercionJS

        if (patternFound.id == -1) {
          // noinspection BreakStatementJS
          break;
        } // noinspection AssignmentTo ParameterJS


        length -= patternFound.position - position;
        result.push({
          id: patternFound.id,
          position: patternFound.position
        });
      } while (true); // eslint-disable-line
      //endregion


      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleLoopsJS,  WithMultipleReturnPointsJS

    /**
     * Find all positions of a pattern
     * @param {ByteStream} pattern Stream having pattern value
     * @param {?number} [start] Start position to search from
     * @param {?number} [length] Length of byte block to search at
     * @returns {Array|number} Array with all pattern positions or (-1) if failed
     */


    findAllPatternIn(pattern) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.buffer.byteLength - start;

      //region Check input variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (start == null) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      }

      if (start > this.buffer.byteLength) {
        // noinspection AssignmentTo ParameterJS
        start = this.buffer.byteLength;
      } // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS


      if (length == null) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      if (length > this.buffer.byteLength - start) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      } //endregion
      //region Initial variables


      var result = [];
      var patternLength = pattern.buffer.byteLength; // noinspection NonBlockStatementBodyJS

      if (patternLength > length) return -1; //endregion
      //region Make a "pre-read" array for pattern

      var patternArray = Array.from(pattern.view); //endregion
      //region Search for pattern

      for (var i = 0; i <= length - patternLength; i++) {
        var equal = true;
        var equalStart = start + i;

        for (var j = 0; j < patternLength; j++) {
          // noinspection EqualityComparisonWithCoercionJS
          if (this.view[j + equalStart] != patternArray[j]) {
            equal = false; // noinspection BreakStatementJS

            break;
          }
        }

        if (equal) {
          result.push(start + patternLength + i); // Position after the pattern found

          i += patternLength - 1; // On next step of "for" we will have "i++"
        }
      } //endregion


      return result;
    } //**********************************************************************************
    // noinspection OverlyComplex JS,  TooLongJS

    /**
     * Find first position of data, not included in patterns from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
     * @param {?number} [start] Start position to search from
     * @param {?number} [length] Length of byte block to search at
     * @param {boolean} [backward=false] Flag to search in backward order
     * @returns {{left: {id: number, position: *}, right: {id: number, position: number}, value: ByteStream}}
     */


    findFirstNotIn(patterns) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (start == null) {
        // noinspection AssignmentTo ParameterJS, ConditionalExpressionJS
        start = backward ? this.buffer.byteLength : 0;
      }

      if (start > this.buffer.byteLength) {
        // noinspection AssignmentTo ParameterJS
        start = this.buffer.byteLength;
      }

      if (backward) {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }

        if (length > start) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }
      } else {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }

        if (length > this.buffer.byteLength - start) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }
      }

      var result = {
        left: {
          id: -1,
          position: start
        },
        right: {
          id: -1,
          position: 0
        },
        value: new ByteStream()
      };
      var currentLength = length; //endregion
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      while (currentLength > 0) {
        //region Search for nearest "pattern"
        // noinspection ConditionalExpressionJS
        result.right = this.findFirstIn(patterns, backward ? start - length + currentLength : start + length - currentLength, currentLength, backward); //endregion
        //region No pattern at all
        // noinspection EqualityComparisonWithCoercionJS

        if (result.right.id == -1) {
          // noinspection AssignmentTo ParameterJS
          length = currentLength;

          if (backward) {
            // noinspection AssignmentTo ParameterJS
            start -= length;
          } else {
            // noinspection AssignmentTo ParameterJS
            start = result.left.position;
          }

          result.value = new ByteStream();
          result.value._buffer = this._buffer.slice(start, start + length);
          result.value._view = new Uint8Array(result.value._buffer); // noinspection BreakStatementJS

          break;
        } //endregion
        //region Check distance between two patterns
        // noinspection ConditionalExpressionJS, EqualityComparisonWithCoercionJS


        if (result.right.position != (backward ? result.left.position - patterns[result.right.id].buffer.byteLength : result.left.position + patterns[result.right.id].buffer.byteLength)) {
          if (backward) {
            // noinspection AssignmentTo ParameterJS
            start = result.right.position + patterns[result.right.id].buffer.byteLength; // noinspection AssignmentTo ParameterJS

            length = result.left.position - result.right.position - patterns[result.right.id].buffer.byteLength;
          } else {
            // noinspection AssignmentTo ParameterJS
            start = result.left.position; // noinspection AssignmentTo ParameterJS

            length = result.right.position - result.left.position - patterns[result.right.id].buffer.byteLength;
          }

          result.value = new ByteStream();
          result.value._buffer = this._buffer.slice(start, start + length);
          result.value._view = new Uint8Array(result.value._buffer); // noinspection BreakStatementJS

          break;
        } //endregion
        //region Store information about previous pattern


        result.left = result.right; //endregion
        //region Change current length

        currentLength -= patterns[result.right.id]._buffer.byteLength; //endregion
      } //region Swap "patterns" in case of backward order


      if (backward) {
        var temp = result.right;
        result.right = result.left;
        result.left = temp;
      } //endregion


      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS

    /**
     * Find all positions of data, not included in patterns from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
     * @param {?number} [start] Start position to search from
     * @param {?number} [length] Length of byte block to search at
     * @returns {Array}
     */


    findAllNotIn(patterns) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      //region Initial variables
      var result = []; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (start == null) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      } // noinspection NonBlockStatementBodyJS


      if (start > this.buffer.byteLength - 1) return result; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (length == null) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      if (length > this.buffer.byteLength - start) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      var patternFound = {
        left: {
          id: -1,
          position: start
        },
        right: {
          id: -1,
          position: start
        },
        value: new ByteStream()
      }; //endregion
      //region Find all accurences of patterns
      // noinspection EqualityComparisonWithCoercionJS

      do {
        var position = patternFound.right.position;
        patternFound = this.findFirstNotIn(patterns, patternFound.right.position, length); // noinspection AssignmentTo ParameterJS

        length -= patternFound.right.position - position;
        result.push({
          left: {
            id: patternFound.left.id,
            position: patternFound.left.position
          },
          right: {
            id: patternFound.right.id,
            position: patternFound.right.position
          },
          value: patternFound.value
        });
      } while (patternFound.right.id != -1); //endregion


      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS, OverlyComplex JS

    /**
     * Find position of a sequence of any patterns from input array
     * @param {Array.<ByteStream>} patterns Array of pattern to look for
     * @param {?number} [start] Start position to search from
     * @param {?number} [length] Length of byte block to search at
     * @param {boolean} [backward=false] Flag to search in backward order
     * @returns {*}
     */


    findFirstSequence(patterns) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (start == null) {
        // noinspection AssignmentTo ParameterJS, ConditionalExpressionJS
        start = backward ? this.buffer.byteLength : 0;
      }

      if (start > this.buffer.byteLength) {
        // noinspection AssignmentTo ParameterJS
        start = this.buffer.byteLength;
      }

      if (backward) {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }

        if (length > start) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }
      } else {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }

        if (length > this.buffer.byteLength - start) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }
      } //endregion
      //region Find first byte from sequence


      var firstIn = this.skipNotPatterns(patterns, start, length, backward); // noinspection EqualityComparisonWithCoercionJS

      if (firstIn == -1) {
        return {
          position: -1,
          value: new ByteStream()
        };
      } //endregion
      //region Find first byte not in sequence
      // noinspection ConditionalExpressionJS


      var firstNotIn = this.skipPatterns(patterns, firstIn, length - (backward ? start - firstIn : firstIn - start), backward); //endregion
      //region Make output value

      if (backward) {
        // noinspection AssignmentTo ParameterJS
        start = firstNotIn; // noinspection AssignmentTo ParameterJS

        length = firstIn - firstNotIn;
      } else {
        // noinspection AssignmentTo ParameterJS
        start = firstIn; // noinspection AssignmentTo ParameterJS

        length = firstNotIn - firstIn;
      }

      var value = new ByteStream();
      value._buffer = this._buffer.slice(start, start + length);
      value._view = new Uint8Array(value._buffer); //endregion

      return {
        position: firstNotIn,
        value
      };
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS

    /**
     * Find all positions of a sequence of any patterns from input array
     * @param {Array.<ByteStream>} patterns Array of patterns to search for
     * @param {?number} [start] Start position to search from
     * @param {?number} [length] Length of byte block to search at
     * @returns {Array}
     */


    findAllSequences(patterns) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      //region Initial variables
      var result = []; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (start == null) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      } // noinspection NonBlockStatementBodyJS


      if (start > this.buffer.byteLength - 1) return result; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (length == null) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      if (length > this.buffer.byteLength - start) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      var patternFound = {
        position: start,
        value: new ByteStream()
      }; //endregion
      //region Find all accurences of patterns
      // noinspection EqualityComparisonWithCoercionJS

      do {
        var position = patternFound.position;
        patternFound = this.findFirstSequence(patterns, patternFound.position, length); // noinspection EqualityComparisonWithCoercionJS

        if (patternFound.position != -1) {
          // noinspection AssignmentTo ParameterJS
          length -= patternFound.position - position;
          result.push({
            position: patternFound.position,
            value: patternFound.value
          });
        }
      } while (patternFound.position != -1); //endregion


      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleLoopsJS,  WithMultipleReturnPointsJS, OverlyComplex JS,  TooLongJS

    /**
     * Find all paired patterns in the stream
     * @param {ByteStream} leftPattern Left pattern to search for
     * @param {ByteStream} rightPattern Right pattern to search for
     * @param {?number} [start=null] Start position to search from
     * @param {?number} [length=null] Length of byte block to search at
     * @returns {Array}
     */


    findPairedPatterns(leftPattern, rightPattern) {
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      //region Initial variables
      var result = []; // noinspection NonBlockStatementBodyJS

      if (leftPattern.isEqual(rightPattern)) return result; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (start == null) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      } // noinspection NonBlockStatementBodyJS


      if (start > this.buffer.byteLength - 1) return result; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (length == null) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      if (length > this.buffer.byteLength - start) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      var currentPositionLeft = 0; //endregion
      //region Find all "left patterns" as sorted array

      var leftPatterns = this.findAllPatternIn(leftPattern, start, length); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS

      if (leftPatterns.length == 0) return result; //endregion
      //region Find all "right patterns" as sorted array

      var rightPatterns = this.findAllPatternIn(rightPattern, start, length); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS

      if (rightPatterns.length == 0) return result; //endregion
      //region Combine patterns

      while (currentPositionLeft < leftPatterns.length) {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS
        if (rightPatterns.length == 0) {
          // noinspection BreakStatementJS
          break;
        } // noinspection EqualityComparisonWithCoercionJS


        if (leftPatterns[0] == rightPatterns[0]) {
          // Possible situation when one pattern is a part of another
          // For example "stream" and "endstream"
          // In case when we have only "endstream" in fact "stream" will be also found at the same position
          // (position of the pattern is an index AFTER the pattern)
          result.push({
            left: leftPatterns[0],
            right: rightPatterns[0]
          });
          leftPatterns.splice(0, 1);
          rightPatterns.splice(0, 1); // noinspection ContinueStatementJS

          continue;
        }

        if (leftPatterns[currentPositionLeft] > rightPatterns[0]) {
          // noinspection BreakStatementJS
          break;
        }

        while (leftPatterns[currentPositionLeft] < rightPatterns[0]) {
          currentPositionLeft++;

          if (currentPositionLeft >= leftPatterns.length) {
            // noinspection BreakStatementJS
            break;
          }
        }

        result.push({
          left: leftPatterns[currentPositionLeft - 1],
          right: rightPatterns[0]
        });
        leftPatterns.splice(currentPositionLeft - 1, 1);
        rightPatterns.splice(0, 1);
        currentPositionLeft = 0;
      } //endregion
      //region Sort result


      result.sort((a, b) => a.left - b.left); //endregion

      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleLoopsJS,  WithMultipleReturnPointsJS, OverlyComplex JS,  TooLongJS

    /**
     * Find all paired patterns in the stream
     * @param {Array.<ByteStream>} inputLeftPatterns Array of left patterns to search for
     * @param {Array.<ByteStream>} inputRightPatterns Array of right patterns to search for
     * @param {?number} [start=null] Start position to search from
     * @param {?number} [length=null] Length of byte block to search at
     * @returns {Array}
     */


    findPairedArrays(inputLeftPatterns, inputRightPatterns) {
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      //region Initial variables
      var result = []; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (start == null) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      } // noinspection NonBlockStatementBodyJS


      if (start > this.buffer.byteLength - 1) return result; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (length == null) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      if (length > this.buffer.byteLength - start) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      var currentPositionLeft = 0; //endregion
      //region Find all "left patterns" as sorted array

      var leftPatterns = this.findAllIn(inputLeftPatterns, start, length); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS

      if (leftPatterns.length == 0) return result; //endregion
      //region Find all "right patterns" as sorted array

      var rightPatterns = this.findAllIn(inputRightPatterns, start, length); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS

      if (rightPatterns.length == 0) return result; //endregion
      //region Combine patterns

      while (currentPositionLeft < leftPatterns.length) {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS
        if (rightPatterns.length == 0) {
          // noinspection BreakStatementJS
          break;
        } // noinspection EqualityComparisonWithCoercionJS


        if (leftPatterns[0].position == rightPatterns[0].position) {
          // Possible situation when one pattern is a part of another
          // For example "stream" and "endstream"
          // In case when we have only "endstream" in fact "stream" will be also found at the same position
          // (position of the pattern is an index AFTER the pattern)
          result.push({
            left: leftPatterns[0],
            right: rightPatterns[0]
          });
          leftPatterns.splice(0, 1);
          rightPatterns.splice(0, 1); // noinspection ContinueStatementJS

          continue;
        }

        if (leftPatterns[currentPositionLeft].position > rightPatterns[0].position) {
          // noinspection BreakStatementJS
          break;
        }

        while (leftPatterns[currentPositionLeft].position < rightPatterns[0].position) {
          currentPositionLeft++;

          if (currentPositionLeft >= leftPatterns.length) {
            // noinspection BreakStatementJS
            break;
          }
        }

        result.push({
          left: leftPatterns[currentPositionLeft - 1],
          right: rightPatterns[0]
        });
        leftPatterns.splice(currentPositionLeft - 1, 1);
        rightPatterns.splice(0, 1);
        currentPositionLeft = 0;
      } //endregion
      //region Sort result


      result.sort((a, b) => a.left.position - b.left.position); //endregion

      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS,  TooLongJS

    /**
     * Replace one patter with other
     * @param {ByteStream} searchPattern The pattern to search for
     * @param {ByteStream} replacePattern The pattern to replace initial pattern
     * @param {?number} [start=null] Start position to search from
     * @param {?number} [length=null] Length of byte block to search at
     * @param {Array|null} [findAllResult=null] Pre-calculated results of "findAllIn"
     * @returns {*}
     */


    replacePattern(searchPattern, replacePattern) {
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var findAllResult = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      //region Initial variables
      var result;
      var i;
      var output = {
        status: -1,
        searchPatternPositions: [],
        replacePatternPositions: []
      }; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (start == null) {
        // noinspection AssignmentTo ParameterJS
        start = 0;
      } // noinspection NonBlockStatementBodyJS


      if (start > this.buffer.byteLength - 1) return false; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS

      if (length == null) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      }

      if (length > this.buffer.byteLength - start) {
        // noinspection AssignmentTo ParameterJS
        length = this.buffer.byteLength - start;
      } //endregion
      //region Find a pattern to search for
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS


      if (findAllResult == null) {
        result = this.findAllIn([searchPattern], start, length); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS

        if (result.length == 0) return output;
      } else result = findAllResult; // noinspection Nested CallJS


      output.searchPatternPositions.push(...Array.from(result, element => element.position)); //endregion
      //region Variables for new buffer initialization

      var patternDifference = searchPattern.buffer.byteLength - replacePattern.buffer.byteLength;
      var changedBuffer = new ArrayBuffer(this.view.length - result.length * patternDifference);
      var changedView = new Uint8Array(changedBuffer); //endregion
      //region Copy data from 0 to start
      // noinspection Nested CallJS

      changedView.set(new Uint8Array(this.buffer, 0, start)); //endregion
      //region Replace pattern

      for (i = 0; i < result.length; i++) {
        //region Initial variables
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS
        var currentPosition = i == 0 ? start : result[i - 1].position; //endregion
        //region Copy bytes other then search pattern
        // noinspection Nested CallJS

        changedView.set(new Uint8Array(this.buffer, currentPosition, result[i].position - searchPattern.buffer.byteLength - currentPosition), currentPosition - i * patternDifference); //endregion
        //region Put replace pattern in a new buffer

        changedView.set(replacePattern.view, result[i].position - searchPattern.buffer.byteLength - i * patternDifference);
        output.replacePatternPositions.push(result[i].position - searchPattern.buffer.byteLength - i * patternDifference); //endregion
      } //endregion
      //region Copy data from the end of old buffer


      i--; // noinspection Nested CallJS

      changedView.set(new Uint8Array(this.buffer, result[i].position, this.buffer.byteLength - result[i].position), result[i].position - searchPattern.buffer.byteLength + replacePattern.buffer.byteLength - i * patternDifference); //endregion
      //region Re-initialize existing buffer

      this.buffer = changedBuffer;
      this.view = new Uint8Array(this.buffer); //endregion

      output.status = 1;
      return output;
    } //**********************************************************************************
    // noinspection  WithMultipleLoopsJS,  WithMultipleReturnPointsJS, OverlyComplex JS,  TooLongJS

    /**
     * Skip any pattern from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
     * @param {?number} [start=null] Start position to search from
     * @param {?number} [length=null] Length of byte block to search at
     * @param {boolean} [backward=false] Flag to search in backward order
     * @returns {*}
     */


    skipPatterns(patterns) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (start == null) {
        // noinspection AssignmentTo ParameterJS, ConditionalExpressionJS
        start = backward ? this.buffer.byteLength : 0;
      }

      if (start > this.buffer.byteLength) {
        // noinspection AssignmentTo ParameterJS
        start = this.buffer.byteLength;
      }

      if (backward) {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }

        if (length > start) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }
      } else {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }

        if (length > this.buffer.byteLength - start) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }
      }

      var result = start; //endregion
      //region Search for pattern

      for (var k = 0; k < patterns.length; k++) {
        var patternLength = patterns[k].buffer.byteLength; // noinspection ConditionalExpressionJS

        var equalStart = backward ? result - patternLength : result;
        var equal = true;

        for (var j = 0; j < patternLength; j++) {
          // noinspection EqualityComparisonWithCoercionJS
          if (this.view[j + equalStart] != patterns[k].view[j]) {
            equal = false; // noinspection BreakStatementJS

            break;
          }
        }

        if (equal) {
          k = -1;

          if (backward) {
            result -= patternLength; // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS

            if (result <= 0) return result;
          } else {
            result += patternLength; // noinspection NonBlockStatementBodyJS

            if (result >= start + length) return result;
          }
        }
      } //endregion


      return result;
    } //**********************************************************************************
    // noinspection  WithMultipleLoopsJS, OverlyComplex JS,  TooLongJS

    /**
     * Skip any pattern not from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should not be ommited
     * @param start
     * @param length
     * @param backward
     * @returns {number}
     */


    skipNotPatterns(patterns) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (start == null) {
        // noinspection AssignmentTo ParameterJS, ConditionalExpressionJS
        start = backward ? this.buffer.byteLength : 0;
      }

      if (start > this.buffer.byteLength) {
        // noinspection AssignmentTo ParameterJS
        start = this.buffer.byteLength;
      }

      if (backward) {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }

        if (length > start) {
          // noinspection AssignmentTo ParameterJS
          length = start;
        }
      } else {
        // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
        if (length == null) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }

        if (length > this.buffer.byteLength - start) {
          // noinspection AssignmentTo ParameterJS
          length = this.buffer.byteLength - start;
        }
      }

      var result = -1; //endregion
      //region Search for pattern

      for (var i = 0; i < length; i++) {
        for (var k = 0; k < patterns.length; k++) {
          var patternLength = patterns[k].buffer.byteLength; // noinspection ConditionalExpressionJS

          var equalStart = backward ? start - i - patternLength : start + i;
          var equal = true;

          for (var j = 0; j < patternLength; j++) {
            // noinspection EqualityComparisonWithCoercionJS
            if (this.view[j + equalStart] != patterns[k].view[j]) {
              equal = false; // noinspection BreakStatementJS

              break;
            }
          }

          if (equal) {
            // noinspection ConditionalExpressionJS
            result = backward ? start - i : start + i; // Exact position of pattern found
            // noinspection BreakStatementJS

            break;
          }
        } // noinspection EqualityComparisonWithCoercionJS


        if (result != -1) {
          // noinspection BreakStatementJS
          break;
        }
      } //endregion


      return result;
    } //**********************************************************************************


  } //**************************************************************************************


  class SeqStream {
    //**********************************************************************************

    /**
     * Constructor for "SeqStream" class
     * @param {{[stream]: ByteStream, [length]: number, [backward]: boolean, [start]: number, [appendBlock]: number}} parameters
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * Major stream
       * @type {ByteStream}
       */
      this.stream = new ByteStream();
      /**
       * Length of the major stream
       * @type {number}
       */

      this._length = 0;
      /**
       * Flag to search in backward direction
       * @type {boolean}
       */

      this.backward = false;
      /**
       * Start position to search
       * @type {number}
       */

      this._start = 0;
      /**
       * Length of a block when append information to major stream
       * @type {number}
       */

      this.appendBlock = 0;
      this.prevLength = 0;
      this.prevStart = 0;

      for (var _i32 = 0, _Object$keys10 = Object.keys(parameters); _i32 < _Object$keys10.length; _i32++) {
        var key = _Object$keys10[_i32];

        switch (key) {
          case "stream":
            this.stream = parameters.stream;
            break;

          case "backward":
            this.backward = parameters.backward; // noinspection JSUnusedGlobalSymbols

            this._start = this.stream.buffer.byteLength;
            break;

          case "length":
            // noinspection JSUnusedGlobalSymbols
            this._length = parameters.length;
            break;

          case "start":
            // noinspection JSUnusedGlobalSymbols
            this._start = parameters.start;
            break;

          case "appendBlock":
            this.appendBlock = parameters.appendBlock;
            break;

          case "view":
            this.stream = new ByteStream({
              view: parameters.view
            });
            break;

          case "buffer":
            this.stream = new ByteStream({
              buffer: parameters.buffer
            });
            break;

          case "string":
            this.stream = new ByteStream({
              string: parameters.string
            });
            break;

          case "hexstring":
            this.stream = new ByteStream({
              hexstring: parameters.hexstring
            });
            break;

          default:
        }
      }
    } //**********************************************************************************

    /**
     * Setter for "stream" property
     * @param {ByteStream} value
     */


    set stream(value) {
      this._stream = value;
      this.prevLength = this._length; // noinspection JSUnusedGlobalSymbols

      this._length = value._buffer.byteLength;
      this.prevStart = this._start; // noinspection JSUnusedGlobalSymbols

      this._start = 0;
    } //**********************************************************************************

    /**
     * Getter for "stream" property
     * @returns {ByteStream}
     */


    get stream() {
      return this._stream;
    } //**********************************************************************************

    /**
     * Setter for "length" property
     * @param {number} value
     */


    set length(value) {
      this.prevLength = this._length; // noinspection JSUnusedGlobalSymbols

      this._length = value;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS

    /**
     * Getter for "length" property
     * @returns {number}
     */


    get length() {
      // noinspection NonBlockStatementBodyJS
      if (this.appendBlock) return this.start;
      return this._length;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS

    /**
     * Setter for "start" property
     * @param {number} value
     */


    set start(value) {
      // noinspection NonBlockStatementBodyJS
      if (value > this.stream.buffer.byteLength) return; //region Initialization of "prev" internal variables

      this.prevStart = this._start;
      this.prevLength = this._length; //endregion
      // noinspection JSUnusedGlobalSymbols, ConditionalExpressionJS

      this._length -= this.backward ? this._start - value : value - this._start; // noinspection JSUnusedGlobalSymbols

      this._start = value;
    } //**********************************************************************************

    /**
     * Getter for "start" property
     * @returns {number}
     */


    get start() {
      return this._start;
    } //**********************************************************************************

    /**
     * Return ArrayBuffer with having value of existing SeqStream length
     * @return {ArrayBuffer}
     */


    get buffer() {
      return this._stream._buffer.slice(0, this._length);
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Reset current position of the "SeqStream"
     */


    resetPosition() {
      // noinspection JSUnusedGlobalSymbols
      this._start = this.prevStart; // noinspection JSUnusedGlobalSymbols

      this._length = this.prevLength;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Find any byte pattern in "ByteStream"
     * @param {ByteStream} pattern Stream having pattern value
     * @param {?number} [gap] Maximum gap between start position and position of nearest object
     * @returns {number}
     */


    findPattern(pattern) {
      var gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (gap == null || gap > this.length) {
        // noinspection AssignmentTo ParameterJS
        gap = this.length;
      } //endregion
      //region Find pattern


      var result = this.stream.findPattern(pattern, this.start, this.length, this.backward); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS

      if (result == -1) return result;

      if (this.backward) {
        // noinspection NonBlockStatementBodyJS
        if (result < this.start - pattern.buffer.byteLength - gap) return -1;
      } else {
        // noinspection NonBlockStatementBodyJS
        if (result > this.start + pattern.buffer.byteLength + gap) return -1;
      } //endregion
      //region Create new values


      this.start = result; //endregion ;

      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Find first position of any pattern from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be found
     * @param {?number} [gap] Maximum gap between start position and position of nearest object
     * @returns {{id: number, position: number}}
     */


    findFirstIn(patterns) {
      var gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (gap == null || gap > this.length) {
        // noinspection AssignmentTo ParameterJS
        gap = this.length;
      } //endregion
      //region Search for patterns


      var result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward); // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS

      if (result.id == -1) return result;

      if (this.backward) {
        if (result.position < this.start - patterns[result.id].buffer.byteLength - gap) {
          // noinspection ConditionalExpressionJS
          return {
            id: -1,
            position: this.backward ? 0 : this.start + this.length
          };
        }
      } else {
        if (result.position > this.start + patterns[result.id].buffer.byteLength + gap) {
          // noinspection ConditionalExpressionJS
          return {
            id: -1,
            position: this.backward ? 0 : this.start + this.length
          };
        }
      } //endregion
      //region Create new values


      this.start = result.position; //endregion ;

      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Find all positions of any pattern from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be found
     * @returns {Array}
     */


    findAllIn(patterns) {
      // In case of "backward order" the start position is at the end on stream.
      // In case of "normal order" the start position is at the begging of the stream.
      // But in fact for search for all patterns we need to have start position in "normal order".
      // noinspection ConditionalExpressionJS
      var start = this.backward ? this.start - this.length : this.start;
      return this.stream.findAllIn(patterns, start, this.length);
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS, OverlyComplex JS

    /**
     * Find first position of data, not included in patterns from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
     * @param {?number} gap Maximum gap between start position and position of nearest object
     * @returns {*}
     */


    findFirstNotIn(patterns) {
      var gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (gap == null || gap > this._length) {
        // noinspection AssignmentTo ParameterJS
        gap = this._length;
      } //endregion
      //region Search for patterns


      var result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward); // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS


      if (result.left.id == -1 && result.right.id == -1) return result;

      if (this.backward) {
        // noinspection EqualityComparisonWithCoercionJS
        if (result.right.id != -1) {
          if (result.right.position < this._start - patterns[result.right.id]._buffer.byteLength - gap) {
            return {
              left: {
                id: -1,
                position: this._start
              },
              right: {
                id: -1,
                position: 0
              },
              value: new ByteStream()
            };
          }
        }
      } else {
        // noinspection EqualityComparisonWithCoercionJS
        if (result.left.id != -1) {
          if (result.left.position > this._start + patterns[result.left.id]._buffer.byteLength + gap) {
            return {
              left: {
                id: -1,
                position: this._start
              },
              right: {
                id: -1,
                position: 0
              },
              value: new ByteStream()
            };
          }
        }
      } //endregion
      //region Create new values


      if (this.backward) {
        // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
        if (result.left.id == -1) this.start = 0;else this.start = result.left.position;
      } else {
        // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
        if (result.right.id == -1) this.start = this._start + this._length;else this.start = result.right.position;
      } //endregion ;


      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Find all positions of data, not included in patterns from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
     * @returns {Array}
     */


    findAllNotIn(patterns) {
      // In case of "backward order" the start position is at the end on stream.
      // In case of "normal order" the start position is at the begging of the stream.
      // But in fact for search for all patterns we need to have start position in "normal order".
      // noinspection ConditionalExpressionJS
      var start = this.backward ? this._start - this._length : this._start;
      return this._stream.findAllNotIn(patterns, start, this._length);
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Find position of a sequence of any patterns from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
     * @param {?number} [length] Length to search sequence for
     * @param {?number} [gap] Maximum gap between start position and position of nearest object
     * @returns {*}
     */


    findFirstSequence(patterns) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (length == null || length > this._length) {
        // noinspection AssignmentTo ParameterJS
        length = this._length;
      } // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS


      if (gap == null || gap > length) {
        // noinspection AssignmentTo ParameterJS
        gap = length;
      } //endregion
      //region Search for sequence


      var result = this._stream.findFirstSequence(patterns, this._start, length, this.backward); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS


      if (result.value.buffer.byteLength == 0) return result;

      if (this.backward) {
        if (result.position < this._start - result.value._buffer.byteLength - gap) {
          return {
            position: -1,
            value: new ByteStream()
          };
        }
      } else {
        if (result.position > this._start + result.value._buffer.byteLength + gap) {
          return {
            position: -1,
            value: new ByteStream()
          };
        }
      } //endregion
      //region Create new values


      this.start = result.position; //endregion ;

      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Find position of a sequence of any patterns from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be found
     * @returns {Array}
     */


    findAllSequences(patterns) {
      // In case of "backward order" the start position is at the end on stream.
      // In case of "normal order" the start position is at the begging of the stream.
      // But in fact for search for all patterns we need to have start position in "normal order".
      // noinspection ConditionalExpressionJS
      var start = this.backward ? this.start - this.length : this.start;
      return this.stream.findAllSequences(patterns, start, this.length);
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Find all paired patterns in the stream
     * @param {ByteStream} leftPattern Left pattern to search for
     * @param {ByteStream} rightPattern Right pattern to search for
     * @param {?number} [gap] Maximum gap between start position and position of nearest object
     * @returns {Array}
     */


    findPairedPatterns(leftPattern, rightPattern) {
      var gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (gap == null || gap > this.length) {
        // noinspection AssignmentTo ParameterJS
        gap = this.length;
      } //endregion
      // In case of "backward order" the start position is at the end on stream.
      // In case of "normal order" the start position is at the begging of the stream.
      // But in fact for search for all patterns we need to have start position in "normal order".
      // noinspection ConditionalExpressionJS


      var start = this.backward ? this.start - this.length : this.start; //region Search for patterns

      var result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);

      if (result.length) {
        if (this.backward) {
          // noinspection NonBlockStatementBodyJS
          if (result[0].right < this.start - rightPattern.buffer.byteLength - gap) return [];
        } else {
          // noinspection NonBlockStatementBodyJS
          if (result[0].left > this.start + leftPattern.buffer.byteLength + gap) return [];
        }
      } //endregion


      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Find all paired patterns in the stream
     * @param {Array.<ByteStream>} leftPatterns Array of left patterns to search for
     * @param {Array.<ByteStream>} rightPatterns Array of right patterns to search for
     * @param {?number} [gap] Maximum gap between start position and position of nearest object
     * @returns {Array}
     */


    findPairedArrays(leftPatterns, rightPatterns) {
      var gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      //region Initial variables
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
      if (gap == null || gap > this.length) {
        // noinspection AssignmentTo ParameterJS
        gap = this.length;
      } //endregion
      // In case of "backward order" the start position is at the end on stream.
      // In case of "normal order" the start position is at the begging of the stream.
      // But in fact for search for all patterns we need to have start position in "normal order".
      // noinspection ConditionalExpressionJS


      var start = this.backward ? this.start - this.length : this.start; //region Search for patterns

      var result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);

      if (result.length) {
        if (this.backward) {
          // noinspection NonBlockStatementBodyJS
          if (result[0].right.position < this.start - rightPatterns[result[0].right.id].buffer.byteLength - gap) return [];
        } else {
          // noinspection NonBlockStatementBodyJS
          if (result[0].left.position > this.start + leftPatterns[result[0].left.id].buffer.byteLength + gap) return [];
        }
      } //endregion


      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Replace one patter with other
     * @param {ByteStream} searchPattern The pattern to search for
     * @param {ByteStream} replacePattern The pattern to replace initial pattern
     * @returns {*}
     */


    replacePattern(searchPattern, replacePattern) {
      // In case of "backward order" the start position is at the end on stream.
      // In case of "normal order" the start position is at the begging of the stream.
      // But in fact for search for all patterns we need to have start position in "normal order".
      // noinspection ConditionalExpressionJS
      var start = this.backward ? this.start - this.length : this.start;
      return this.stream.replacePattern(searchPattern, replacePattern, start, this.length);
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Skip of any pattern from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
     * @returns {*}
     */


    skipPatterns(patterns) {
      var result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward); //region Create new values

      this.start = result; //endregion ;

      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS

    /**
     * Skip of any pattern from input array
     * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
     * @returns {number}
     */


    skipNotPatterns(patterns) {
      var result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward); // noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS

      if (result == -1) return -1; //region Create new values

      this.start = result; //endregion ;

      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Append a new "Stream" content to the current "Stream"
     * @param {ByteStream} stream A new "stream" to append to current "stream"
     */


    append(stream) {
      if (this._start + stream._buffer.byteLength > this._stream._buffer.byteLength) {
        if (stream._buffer.byteLength > this.appendBlock) {
          // noinspection MagicNumberJS
          this.appendBlock = stream._buffer.byteLength + 1000;
        }

        this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
      }

      this._stream._view.set(stream._view, this._start);

      this._length += stream._buffer.byteLength * 2;
      this.start = this._start + stream._buffer.byteLength;
      this.prevLength -= stream._buffer.byteLength * 2;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Append a "view" content to the current "Stream"
     * @param {Uint8Array} view A new "view" to append to current "stream"
     */


    appendView(view) {
      if (this._start + view.length > this._stream._buffer.byteLength) {
        if (view.length > this.appendBlock) {
          // noinspection MagicNumberJS
          this.appendBlock = view.length + 1000;
        }

        this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
      }

      this._stream._view.set(view, this._start);

      this._length += view.length * 2;
      this.start = this._start + view.length;
      this.prevLength -= view.length * 2;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols

    /**
     * Append a new char to the current "Stream"
     * @param {number} char A new char to append to current "stream"
     */


    appendChar(char) {
      if (this._start + 1 > this._stream._buffer.byteLength) {
        // noinspection ConstantOnLefSideOfComparisonJS
        if (1 > this.appendBlock) {
          // noinspection MagicNumberJS
          this.appendBlock = 1000;
        }

        this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
      }

      this._stream._view[this._start] = char;
      this._length += 2;
      this.start = this._start + 1;
      this.prevLength -= 2;
    } //**********************************************************************************
    // noinspection  NamingConventionJS

    /**
     * Append a new number to the current "Stream"
     * @param {number} number A new unsigned 16-bit integer to append to current "stream"
     */


    appendUint16(number) {
      if (this._start + 2 > this._stream._buffer.byteLength) {
        // noinspection ConstantOnLefSideOfComparisonJS
        if (2 > this.appendBlock) {
          // noinspection MagicNumberJS
          this.appendBlock = 1000;
        }

        this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
      }

      var value = new Uint16Array([number]);
      var view = new Uint8Array(value.buffer);
      this._stream._view[this._start] = view[1];
      this._stream._view[this._start + 1] = view[0];
      this._length += 4;
      this.start = this._start + 2;
      this.prevLength -= 4;
    } //**********************************************************************************
    // noinspection  NamingConventionJS

    /**
     * Append a new number to the current "Stream"
     * @param {number} number A new unsigned 24-bit integer to append to current "stream"
     */


    appendUint24(number) {
      if (this._start + 3 > this._stream._buffer.byteLength) {
        // noinspection ConstantOnLefSideOfComparisonJS
        if (3 > this.appendBlock) {
          // noinspection MagicNumberJS
          this.appendBlock = 1000;
        }

        this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
      }

      var value = new Uint32Array([number]);
      var view = new Uint8Array(value.buffer);
      this._stream._view[this._start] = view[2];
      this._stream._view[this._start + 1] = view[1];
      this._stream._view[this._start + 2] = view[0];
      this._length += 6;
      this.start = this._start + 3;
      this.prevLength -= 6;
    } //**********************************************************************************
    // noinspection  NamingConventionJS

    /**
     * Append a new number to the current "Stream"
     * @param {number} number A new unsigned 32-bit integer to append to current "stream"
     */


    appendUint32(number) {
      if (this._start + 4 > this._stream._buffer.byteLength) {
        // noinspection ConstantOnLefSideOfComparisonJS
        if (4 > this.appendBlock) {
          // noinspection MagicNumberJS
          this.appendBlock = 1000;
        }

        this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
      }

      var value = new Uint32Array([number]);
      var view = new Uint8Array(value.buffer);
      this._stream._view[this._start] = view[3];
      this._stream._view[this._start + 1] = view[2];
      this._stream._view[this._start + 2] = view[1];
      this._stream._view[this._start + 3] = view[0];
      this._length += 8;
      this.start = this._start + 4;
      this.prevLength -= 8;
    } //**********************************************************************************
    // noinspection  WithMultipleReturnPointsJS

    /**
     * Get a block of data
     * @param {number} size Size of the data block to get
     * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
     * @returns {Array}
     */


    getBlock(size) {
      var changeLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      //region Check input parameters
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
      if (this._length <= 0) return [];

      if (this._length < size) {
        // noinspection AssignmentTo ParameterJS
        size = this._length;
      } //endregion
      //region Initial variables


      var result; //endregion
      //region Getting result depends on "backward" flag

      if (this.backward) {
        var buffer = this._stream._buffer.slice(this._length - size, this._length);

        var view = new Uint8Array(buffer);
        result = new Array(size); // noinspection NonBlockStatementBodyJS

        for (var i = 0; i < size; i++) {
          result[size - 1 - i] = view[i];
        }
      } else {
        var _buffer2 = this._stream._buffer.slice(this._start, this._start + size); // noinspection Nested CallJS


        result = Array.from(new Uint8Array(_buffer2));
      } //endregion
      //region Change "length" value if needed


      if (changeLength) {
        // noinspection ConditionalExpressionJS
        this.start += this.backward ? -1 * size : size;
      } //endregion


      return result;
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS,  NamingConventionJS

    /**
     * Get 2-byte unsigned integer value
     * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
     * @returns {number}
     */


    getUint16() {
      var changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var block = this.getBlock(2, changeLength); //region Check posibility for convertion
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS

      if (block.length < 2) return 0; //endregion
      //region Convert byte array to "Uint32Array" value

      var value = new Uint16Array(1);
      var view = new Uint8Array(value.buffer);
      view[0] = block[1];
      view[1] = block[0]; //endregion

      return value[0];
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS,  NamingConventionJS

    /**
     * Get 3-byte unsigned integer value
     * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
     * @returns {number}
     */


    getUint24() {
      var changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var block = this.getBlock(3, changeLength); //region Check posibility for convertion
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS

      if (block.length < 3) return 0; //endregion
      //region Convert byte array to "Uint32Array" value

      var value = new Uint32Array(1);
      var view = new Uint8Array(value.buffer); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS

      for (var i = 3; i >= 1; i--) {
        view[3 - i] = block[i - 1];
      } //endregion


      return value[0];
    } //**********************************************************************************
    // noinspection JSUnusedGlobalSymbols,  WithMultipleReturnPointsJS,  NamingConventionJS

    /**
     * Get 4-byte unsigned integer value
     * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
     * @returns {number}
     */


    getUint32() {
      var changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var block = this.getBlock(4, changeLength); //region Check posibility for convertion
      // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS

      if (block.length < 4) return 0; //endregion
      //region Convert byte array to "Uint32Array" value

      var value = new Uint32Array(1);
      var view = new Uint8Array(value.buffer); // noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS

      for (var i = 3; i >= 0; i--) {
        view[3 - i] = block[i];
      } //endregion


      return value[0];
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************


  class SignedCertificateTimestamp {
    //**********************************************************************************

    /**
     * Constructor for SignedCertificateTimestamp class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", SignedCertificateTimestamp.defaultValues("version"));
      /**
       * @type {ArrayBuffer}
       * @desc logID
       */

      this.logID = getParametersValue(parameters, "logID", SignedCertificateTimestamp.defaultValues("logID"));
      /**
       * @type {Date}
       * @desc timestamp
       */

      this.timestamp = getParametersValue(parameters, "timestamp", SignedCertificateTimestamp.defaultValues("timestamp"));
      /**
       * @type {ArrayBuffer}
       * @desc extensions
       */

      this.extensions = getParametersValue(parameters, "extensions", SignedCertificateTimestamp.defaultValues("extensions"));
      /**
       * @type {string}
       * @desc hashAlgorithm
       */

      this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", SignedCertificateTimestamp.defaultValues("hashAlgorithm"));
      /**
       * @type {string}
       * @desc signatureAlgorithm
       */

      this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", SignedCertificateTimestamp.defaultValues("signatureAlgorithm"));
      /**
       * @type {Object}
       * @desc signature
       */

      this.signature = getParametersValue(parameters, "signature", SignedCertificateTimestamp.defaultValues("signature")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
      //region If input argument array contains "stream"

      if ("stream" in parameters) this.fromStream(parameters.stream); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 0;

        case "logID":
        case "extensions":
          return new ArrayBuffer(0);

        case "timestamp":
          return new Date(0);

        case "hashAlgorithm":
        case "signatureAlgorithm":
          return "";

        case "signature":
          return new Any();

        default:
          throw new Error("Invalid member name for SignedCertificateTimestamp class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      if (schema instanceof RawData === false) throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");
      var seqStream = new SeqStream({
        stream: new ByteStream({
          buffer: schema.data
        })
      });
      this.fromStream(seqStream);
    } //**********************************************************************************

    /**
     * Convert SeqStream data into current class
     * @param {!SeqStream} stream
     */


    fromStream(stream) {
      var blockLength = stream.getUint16();
      this.version = stream.getBlock(1)[0];

      if (this.version === 0) {
        this.logID = new Uint8Array(stream.getBlock(32)).buffer.slice(0);
        this.timestamp = new Date(utilFromBase(new Uint8Array(stream.getBlock(8)), 8)); //region Extensions

        var extensionsLength = stream.getUint16();
        this.extensions = new Uint8Array(stream.getBlock(extensionsLength)).buffer.slice(0); //endregion
        //region Hash algorithm

        switch (stream.getBlock(1)[0]) {
          case 0:
            this.hashAlgorithm = "none";
            break;

          case 1:
            this.hashAlgorithm = "md5";
            break;

          case 2:
            this.hashAlgorithm = "sha1";
            break;

          case 3:
            this.hashAlgorithm = "sha224";
            break;

          case 4:
            this.hashAlgorithm = "sha256";
            break;

          case 5:
            this.hashAlgorithm = "sha384";
            break;

          case 6:
            this.hashAlgorithm = "sha512";
            break;

          default:
            throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
        } //endregion
        //region Signature algorithm


        switch (stream.getBlock(1)[0]) {
          case 0:
            this.signatureAlgorithm = "anonymous";
            break;

          case 1:
            this.signatureAlgorithm = "rsa";
            break;

          case 2:
            this.signatureAlgorithm = "dsa";
            break;

          case 3:
            this.signatureAlgorithm = "ecdsa";
            break;

          default:
            throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
        } //endregion
        //region Signature


        var signatureLength = stream.getUint16();
        var signatureData = new Uint8Array(stream.getBlock(signatureLength)).buffer.slice(0);
        var asn1 = fromBER(signatureData);
        if (asn1.offset === -1) throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
        this.signature = asn1.result; //endregion

        if (blockLength !== 47 + extensionsLength + signatureLength) throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
      }
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var stream = this.toStream();
      return new RawData({
        data: stream.stream.buffer
      });
    } //**********************************************************************************

    /**
     * Convert current object to SeqStream data
     * @returns {SeqStream} SeqStream object
     */


    toStream() {
      var stream = new SeqStream();
      stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecode.byteLength);
      stream.appendChar(this.version);
      stream.appendView(new Uint8Array(this.logID));
      var timeBuffer = new ArrayBuffer(8);
      var timeView = new Uint8Array(timeBuffer);
      var baseArray = utilToBase(this.timestamp.valueOf(), 8);
      timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
      stream.appendView(timeView);
      stream.appendUint16(this.extensions.byteLength);
      if (this.extensions.byteLength) stream.appendView(new Uint8Array(this.extensions));

      var _hashAlgorithm;

      switch (this.hashAlgorithm.toLowerCase()) {
        case "none":
          _hashAlgorithm = 0;
          break;

        case "md5":
          _hashAlgorithm = 1;
          break;

        case "sha1":
          _hashAlgorithm = 2;
          break;

        case "sha224":
          _hashAlgorithm = 3;
          break;

        case "sha256":
          _hashAlgorithm = 4;
          break;

        case "sha384":
          _hashAlgorithm = 5;
          break;

        case "sha512":
          _hashAlgorithm = 6;
          break;

        default:
          throw new Error("Incorrect data for hashAlgorithm: ".concat(this.hashAlgorithm));
      }

      stream.appendChar(_hashAlgorithm);

      var _signatureAlgorithm;

      switch (this.signatureAlgorithm.toLowerCase()) {
        case "anonymous":
          _signatureAlgorithm = 0;
          break;

        case "rsa":
          _signatureAlgorithm = 1;
          break;

        case "dsa":
          _signatureAlgorithm = 2;
          break;

        case "ecdsa":
          _signatureAlgorithm = 3;
          break;

        default:
          throw new Error("Incorrect data for signatureAlgorithm: ".concat(this.signatureAlgorithm));
      }

      stream.appendChar(_signatureAlgorithm);

      var _signature = this.signature.toBER(false);

      stream.appendUint16(_signature.byteLength);
      stream.appendView(new Uint8Array(_signature));
      return stream;
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        version: this.version,
        logID: bufferToHexCodes(this.logID),
        timestamp: this.timestamp,
        extensions: bufferToHexCodes(this.extensions),
        hashAlgorithm: this.hashAlgorithm,
        signatureAlgorithm: this.signatureAlgorithm,
        signature: this.signature.toJSON()
      };
    } //**********************************************************************************

    /**
     * Verify SignedCertificateTimestamp for specific input data
     * @param {Object[]} logs Array of objects with information about each CT Log (like here: https://ct.grahamedgecombe.com/logs.json)
     * @param {String} logs.log_id Identifier of the CT Log encoded in BASE-64 format
     * @param {String} logs.key Public key of the CT Log encoded in BASE-64 format
     * @param {ArrayBuffer} data Data to verify signature against. Could be encoded Certificate or encoded PreCert
     * @param {Number} [dataType=0] Type = 0 (data is encoded Certificate), type = 1 (data is encoded PreCert)
     * @return {Promise<void>}
     */


    verify(logs, data) {
      var _this2 = this,
          _arguments = arguments;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(  _callee() {
        var dataType, logId, publicKeyBase64, publicKeyInfo, stream, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, log, asn1, timeBuffer, timeView, baseArray;

        return regeneratorRuntime.wrap(  _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                dataType = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : 0;
                //region Initial variables
                logId = toBase64(arrayBufferToString(_this2.logID));
                publicKeyBase64 = null;
                stream = new SeqStream(); //endregion
                //region Found and init public key

                _iteratorNormalCompletion6 = true;
                _didIteratorError6 = false;
                _iteratorError6 = undefined;
                _context.prev = 7;
                _iterator6 = logs[Symbol.iterator]();

              case 9:
                if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
                  _context.next = 17;
                  break;
                }

                log = _step6.value;

                if (!(log.log_id === logId)) {
                  _context.next = 14;
                  break;
                }

                publicKeyBase64 = log.key;
                return _context.abrupt("break", 17);

              case 14:
                _iteratorNormalCompletion6 = true;
                _context.next = 9;
                break;

              case 17:
                _context.next = 23;
                break;

              case 19:
                _context.prev = 19;
                _context.t0 = _context["catch"](7);
                _didIteratorError6 = true;
                _iteratorError6 = _context.t0;

              case 23:
                _context.prev = 23;
                _context.prev = 24;

                if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                  _iterator6.return();
                }

              case 26:
                _context.prev = 26;

                if (!_didIteratorError6) {
                  _context.next = 29;
                  break;
                }

                throw _iteratorError6;

              case 29:
                return _context.finish(26);

              case 30:
                return _context.finish(23);

              case 31:
                if (!(publicKeyBase64 === null)) {
                  _context.next = 33;
                  break;
                }

                throw new Error("Public key not found for CT with logId: ".concat(logId));

              case 33:
                asn1 = fromBER(stringToArrayBuffer(fromBase64(publicKeyBase64)));

                if (!(asn1.offset === -1)) {
                  _context.next = 36;
                  break;
                }

                throw new Error("Incorrect key value for CT Log with logId: ".concat(logId));

              case 36:
                publicKeyInfo = new PublicKeyInfo({
                  schema: asn1.result
                }); //endregion
                //region Initialize signed data block

                stream.appendChar(0x00); // sct_version

                stream.appendChar(0x00); // signature_type = certificate_timestamp

                timeBuffer = new ArrayBuffer(8);
                timeView = new Uint8Array(timeBuffer);
                baseArray = utilToBase(_this2.timestamp.valueOf(), 8);
                timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
                stream.appendView(timeView);
                stream.appendUint16(dataType);
                if (dataType === 0) stream.appendUint24(data.byteLength);
                stream.appendView(new Uint8Array(data));
                stream.appendUint16(_this2.extensions.byteLength);
                if (_this2.extensions.byteLength !== 0) stream.appendView(new Uint8Array(_this2.extensions)); //endregion
                //region Perform verification

                return _context.abrupt("return", getEngine().subtle.verifyWithPublicKey(stream._stream._buffer.slice(0, stream._length), {
                  valueBlock: {
                    valueHex: _this2.signature.toBER(false)
                  }
                }, publicKeyInfo, {
                  algorithmId: ""
                }, "SHA-256"));

              case 50:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[7, 19, 23, 31], [24,, 26, 30]]);
      }))();
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from RFC6962
   */


  class SignedCertificateTimestampList {
    //**********************************************************************************

    /**
     * Constructor for SignedCertificateTimestampList class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<SignedCertificateTimestamp>}
       * @desc timestamps
       */
      this.timestamps = getParametersValue(parameters, "timestamps", SignedCertificateTimestampList.defaultValues("timestamps")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "timestamps":
          return [];

        default:
          throw new Error("Invalid member name for SignedCertificateTimestampList class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "timestamps":
          return memberValue.length === 0;

        default:
          throw new Error("Invalid member name for SignedCertificateTimestampList class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * SignedCertificateTimestampList ::= OCTET STRING
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [optional]
       */
      var names = getParametersValue(parameters, "names", {});
      if ("optional" in names === false) names.optional = false;
      return new OctetString({
        name: names.blockName || "SignedCertificateTimestampList",
        optional: names.optional
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Check the schema is valid
      if (schema instanceof OctetString === false) throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList"); //endregion
      //region Get internal properties from parsed schema

      var seqStream = new SeqStream({
        stream: new ByteStream({
          buffer: schema.valueBlock.valueHex
        })
      });
      var dataLength = seqStream.getUint16();
      if (dataLength !== seqStream.length) throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");

      while (seqStream.length) {
        this.timestamps.push(new SignedCertificateTimestamp({
          stream: seqStream
        }));
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Initial variables
      var stream = new SeqStream();
      var overallLength = 0;
      var timestampsData = []; //endregion
      //region Get overall length

      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.timestamps[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var timestamp = _step7.value;
          var timestampStream = timestamp.toStream();
          timestampsData.push(timestampStream);
          overallLength += timestampStream.stream.buffer.byteLength;
        } //endregion

      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      stream.appendUint16(overallLength); //region Set data from all timestamps

      for (var _i33 = 0, _timestampsData = timestampsData; _i33 < _timestampsData.length; _i33++) {
        var _timestamp = _timestampsData[_i33];
        stream.appendView(_timestamp.stream.view);
      } //endregion


      return new OctetString({
        valueHex: stream.stream.buffer.slice(0)
      });
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        timestamps: Array.from(this.timestamps, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**********************************************************************************
  //**************************************************************************************

  /**
   * Class from "[MS-WCCE]: Windows Client Certificate Enrollment Protocol"
   */


  class CertificateTemplate {
    //**********************************************************************************

    /**
     * Constructor for CertificateTemplate class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc templateID
       */
      this.templateID = getParametersValue(parameters, "templateID", CertificateTemplate.defaultValues("templateID"));
      if ("templateMajorVersion" in parameters)
        /**
         * @type {number}
         * @desc templateMajorVersion
         */
        this.templateMajorVersion = getParametersValue(parameters, "templateMajorVersion", CertificateTemplate.defaultValues("templateMajorVersion"));
      if ("templateMinorVersion" in parameters)
        /**
         * @type {number}
         * @desc templateMinorVersion
         */
        this.templateMinorVersion = getParametersValue(parameters, "templateMinorVersion", CertificateTemplate.defaultValues("templateMinorVersion")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "templateID":
          return "";

        case "templateMajorVersion":
        case "templateMinorVersion":
          return 0;

        default:
          throw new Error("Invalid member name for CertificateTemplate class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * CertificateTemplateOID ::= SEQUENCE {
        *    templateID              OBJECT IDENTIFIER,
        *    templateMajorVersion    INTEGER (0..4294967295) OPTIONAL,
        *    templateMinorVersion    INTEGER (0..4294967295) OPTIONAL
        * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [templateID]
       * @property {string} [templateMajorVersion]
       * @property {string} [templateMinorVersion]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.templateID || ""
        }), new Integer({
          name: names.templateMajorVersion || "",
          optional: true
        }), new Integer({
          name: names.templateMinorVersion || "",
          optional: true
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["templateID", "templateMajorVersion", "templateMinorVersion"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, CertificateTemplate.schema({
        names: {
          templateID: "templateID",
          templateMajorVersion: "templateMajorVersion",
          templateMinorVersion: "templateMinorVersion"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertificateTemplate"); //endregion
      //region Get internal properties from parsed schema

      this.templateID = asn1.result.templateID.valueBlock.toString();
      if ("templateMajorVersion" in asn1.result) this.templateMajorVersion = asn1.result.templateMajorVersion.valueBlock.valueDec;
      if ("templateMinorVersion" in asn1.result) this.templateMinorVersion = asn1.result.templateMinorVersion.valueBlock.valueDec; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(new ObjectIdentifier({
        value: this.templateID
      }));
      if ("templateMajorVersion" in this) outputArray.push(new Integer({
        value: this.templateMajorVersion
      }));
      if ("templateMinorVersion" in this) outputArray.push(new Integer({
        value: this.templateMinorVersion
      })); //endregion
      //region Construct and return new ASN.1 schema for this object

      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        extnID: this.templateID
      };
      if ("templateMajorVersion" in this) object.templateMajorVersion = this.templateMajorVersion;
      if ("templateMinorVersion" in this) object.templateMinorVersion = this.templateMinorVersion;
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from https://docs.microsoft.com/en-us/windows/desktop/seccrypto/certification-authority-renewal
   */


  class CAVersion {
    //**********************************************************************************

    /**
     * Constructor for CAVersion class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc certificateIndex
       */
      this.certificateIndex = getParametersValue(parameters, "certificateIndex", CAVersion.defaultValues("certificateIndex"));
      /**
       * @type {number}
       * @desc keyIndex
       */

      this.keyIndex = getParametersValue(parameters, "keyIndex", CAVersion.defaultValues("keyIndex")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "certificateIndex":
        case "keyIndex":
          return 0;

        default:
          throw new Error("Invalid member name for CAVersion class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * CAVersion ::= INTEGER
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Integer();
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Check the schema is valid
      if (schema.constructor.blockName() !== Integer.blockName()) throw new Error("Object's schema was not verified against input data for CAVersion"); //endregion
      //region Check length of the input value and correct it if needed

      var value = schema.valueBlock.valueHex.slice(0);
      var valueView = new Uint8Array(value);

      switch (true) {
        case value.byteLength < 4:
          {
            var tempValue = new ArrayBuffer(4);
            var tempValueView = new Uint8Array(tempValue);
            tempValueView.set(valueView, 4 - value.byteLength);
            value = tempValue.slice(0);
          }
          break;

        case value.byteLength > 4:
          {
            var _tempValue = new ArrayBuffer(4);

            var _tempValueView = new Uint8Array(_tempValue);

            _tempValueView.set(valueView.slice(0, 4));

            value = _tempValue.slice(0);
          }
          break;

        default:
      } //endregion
      //region Get internal properties from parsed schema


      var keyIndexBuffer = value.slice(0, 2);
      var keyIndexView8 = new Uint8Array(keyIndexBuffer);
      var temp = keyIndexView8[0];
      keyIndexView8[0] = keyIndexView8[1];
      keyIndexView8[1] = temp;
      var keyIndexView16 = new Uint16Array(keyIndexBuffer);
      this.keyIndex = keyIndexView16[0];
      var certificateIndexBuffer = value.slice(2);
      var certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
      temp = certificateIndexView8[0];
      certificateIndexView8[0] = certificateIndexView8[1];
      certificateIndexView8[1] = temp;
      var certificateIndexView16 = new Uint16Array(certificateIndexBuffer);
      this.certificateIndex = certificateIndexView16[0]; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create raw values
      var certificateIndexBuffer = new ArrayBuffer(2);
      var certificateIndexView = new Uint16Array(certificateIndexBuffer);
      certificateIndexView[0] = this.certificateIndex;
      var certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
      var temp = certificateIndexView8[0];
      certificateIndexView8[0] = certificateIndexView8[1];
      certificateIndexView8[1] = temp;
      var keyIndexBuffer = new ArrayBuffer(2);
      var keyIndexView = new Uint16Array(keyIndexBuffer);
      keyIndexView[0] = this.keyIndex;
      var keyIndexView8 = new Uint8Array(keyIndexBuffer);
      temp = keyIndexView8[0];
      keyIndexView8[0] = keyIndexView8[1];
      keyIndexView8[1] = temp; //endregion
      //region Construct and return new ASN.1 schema for this object

      return new Integer({
        valueHex: utilConcatBuf(keyIndexBuffer, certificateIndexBuffer)
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        certificateIndex: this.certificateIndex,
        keyIndex: this.keyIndex
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC3739
   */


  class QCStatement {
    //**********************************************************************************

    /**
     * Constructor for QCStatement class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       */
      this.id = getParametersValue(parameters, "id", QCStatement.defaultValues("id"));

      if ("type" in parameters) {
        /**
         * @type {*} Any data described by "id"
         */
        this.type = getParametersValue(parameters, "type", QCStatement.defaultValues("type"));
      } //endregion
      //region If input argument array contains "schema" for this object


      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "id":
          return "";

        case "type":
          return new Null();

        default:
          throw new Error("Invalid member name for QCStatement class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "id":
          return memberValue === "";

        case "type":
          return memberValue instanceof Null;

        default:
          throw new Error("Invalid member name for QCStatement class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
    	 *	 QCStatement ::= SEQUENCE {
     *       statementId   QC-STATEMENT.&id({SupportedStatements}),
     *       statementInfo QC-STATEMENT.&Type({SupportedStatements}{@statementId}) OPTIONAL
     *   }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [id]
       * @property {string} [type]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.id || ""
        }), new Any({
          name: names.type || "",
          optional: true
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["id", "type"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, QCStatement.schema({
        names: {
          id: "id",
          type: "type"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for QCStatement"); //endregion
      //region Get internal properties from parsed schema

      this.id = asn1.result.id.valueBlock.toString();
      if ("type" in asn1.result) this.type = asn1.result.type; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var value = [new ObjectIdentifier({
        value: this.id
      })];
      if ("type" in this) value.push(this.type); //region Construct and return new ASN.1 schema for this object

      return new Sequence({
        value
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        id: this.id
      };
      if ("type" in this) object.type = this.type.toJSON();
      return object;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from RFC3739
   */


  class QCStatements {
    //**********************************************************************************

    /**
     * Constructor for QCStatements class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array<QCStatement>}
       */
      this.values = getParametersValue(parameters, "values", QCStatements.defaultValues("values")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "values":
          return [];

        default:
          throw new Error("Invalid member name for QCStatements class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "values":
          return memberValue.length === 0;

        default:
          throw new Error("Invalid member name for QCStatements class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * QCStatements ::= SEQUENCE OF QCStatement
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [values]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.values || "",
          value: QCStatement.schema(names.value || {})
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["values"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, QCStatements.schema({
        names: {
          values: "values"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for QCStatements"); //endregion
      //region Get internal properties from parsed schema

      this.values = Array.from(asn1.result.values, element => new QCStatement({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.values, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        extensions: Array.from(this.values, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class Extension {
    //**********************************************************************************

    /**
     * Constructor for Extension class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc extnID
       */
      this.extnID = getParametersValue(parameters, "extnID", Extension.defaultValues("extnID"));
      /**
       * @type {boolean}
       * @desc critical
       */

      this.critical = getParametersValue(parameters, "critical", Extension.defaultValues("critical"));
      /**
       * @type {OctetString}
       * @desc extnValue
       */

      if ("extnValue" in parameters) this.extnValue = new OctetString({
        valueHex: parameters.extnValue
      });else this.extnValue = Extension.defaultValues("extnValue");
      if ("parsedValue" in parameters)
        /**
         * @type {Object}
         * @desc parsedValue
         */
        this.parsedValue = getParametersValue(parameters, "parsedValue", Extension.defaultValues("parsedValue")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "extnID":
          return "";

        case "critical":
          return false;

        case "extnValue":
          return new OctetString();

        case "parsedValue":
          return {};

        default:
          throw new Error("Invalid member name for Extension class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * Extension  ::=  SEQUENCE  {
     *    extnID      OBJECT IDENTIFIER,
     *    critical    BOOLEAN DEFAULT FALSE,
     *    extnValue   OCTET STRING
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [extnID]
       * @property {string} [critical]
       * @property {string} [extnValue]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.extnID || ""
        }), new Boolean({
          name: names.critical || "",
          optional: true
        }), new OctetString({
          name: names.extnValue || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["extnID", "critical", "extnValue"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, Extension.schema({
        names: {
          extnID: "extnID",
          critical: "critical",
          extnValue: "extnValue"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Extension"); //endregion
      //region Get internal properties from parsed schema

      this.extnID = asn1.result.extnID.valueBlock.toString();
      if ("critical" in asn1.result) this.critical = asn1.result.critical.valueBlock.value;
      this.extnValue = asn1.result.extnValue; //region Get "parsedValue" for well-known extensions

      asn1 = fromBER(this.extnValue.valueBlock.valueHex);
      if (asn1.offset === -1) return;

      switch (this.extnID) {
        case "2.5.29.9":
          // SubjectDirectoryAttributes
          try {
            this.parsedValue = new SubjectDirectoryAttributes({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new SubjectDirectoryAttributes();
            this.parsedValue.parsingError = "Incorrectly formated SubjectDirectoryAttributes";
          }

          break;

        case "2.5.29.14":
          // SubjectKeyIdentifier
          this.parsedValue = asn1.result; // Should be just a simple OCTETSTRING

          break;

        case "2.5.29.15":
          // KeyUsage
          this.parsedValue = asn1.result; // Should be just a simple BITSTRING

          break;

        case "2.5.29.16":
          // PrivateKeyUsagePeriod
          try {
            this.parsedValue = new PrivateKeyUsagePeriod({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new PrivateKeyUsagePeriod();
            this.parsedValue.parsingError = "Incorrectly formated PrivateKeyUsagePeriod";
          }

          break;

        case "2.5.29.17": // SubjectAltName

        case "2.5.29.18":
          // IssuerAltName
          try {
            this.parsedValue = new AltName({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new AltName();
            this.parsedValue.parsingError = "Incorrectly formated AltName";
          }

          break;

        case "2.5.29.19":
          // BasicConstraints
          try {
            this.parsedValue = new BasicConstraints({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new BasicConstraints();
            this.parsedValue.parsingError = "Incorrectly formated BasicConstraints";
          }

          break;

        case "2.5.29.20": // CRLNumber

        case "2.5.29.27":
          // BaseCRLNumber (delta CRL indicator)
          this.parsedValue = asn1.result; // Should be just a simple INTEGER

          break;

        case "2.5.29.21":
          // CRLReason
          this.parsedValue = asn1.result; // Should be just a simple ENUMERATED

          break;

        case "2.5.29.24":
          // InvalidityDate
          this.parsedValue = asn1.result; // Should be just a simple GeneralizedTime

          break;

        case "2.5.29.28":
          // IssuingDistributionPoint
          try {
            this.parsedValue = new IssuingDistributionPoint({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new IssuingDistributionPoint();
            this.parsedValue.parsingError = "Incorrectly formated IssuingDistributionPoint";
          }

          break;

        case "2.5.29.29":
          // CertificateIssuer
          try {
            this.parsedValue = new GeneralNames({
              schema: asn1.result
            }); // Should be just a simple
          } catch (ex) {
            this.parsedValue = new GeneralNames();
            this.parsedValue.parsingError = "Incorrectly formated GeneralNames";
          }

          break;

        case "2.5.29.30":
          // NameConstraints
          try {
            this.parsedValue = new NameConstraints({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new NameConstraints();
            this.parsedValue.parsingError = "Incorrectly formated NameConstraints";
          }

          break;

        case "2.5.29.31": // CRLDistributionPoints

        case "2.5.29.46":
          // FreshestCRL
          try {
            this.parsedValue = new CRLDistributionPoints({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new CRLDistributionPoints();
            this.parsedValue.parsingError = "Incorrectly formated CRLDistributionPoints";
          }

          break;

        case "2.5.29.32": // CertificatePolicies

        case "1.3.6.1.4.1.311.21.10":
          // szOID_APPLICATION_CERT_POLICIES - Microsoft-specific OID
          try {
            this.parsedValue = new CertificatePolicies({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new CertificatePolicies();
            this.parsedValue.parsingError = "Incorrectly formated CertificatePolicies";
          }

          break;

        case "2.5.29.33":
          // PolicyMappings
          try {
            this.parsedValue = new PolicyMappings({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new PolicyMappings();
            this.parsedValue.parsingError = "Incorrectly formated CertificatePolicies";
          }

          break;

        case "2.5.29.35":
          // AuthorityKeyIdentifier
          try {
            this.parsedValue = new AuthorityKeyIdentifier({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new AuthorityKeyIdentifier();
            this.parsedValue.parsingError = "Incorrectly formated AuthorityKeyIdentifier";
          }

          break;

        case "2.5.29.36":
          // PolicyConstraints
          try {
            this.parsedValue = new PolicyConstraints({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new PolicyConstraints();
            this.parsedValue.parsingError = "Incorrectly formated PolicyConstraints";
          }

          break;

        case "2.5.29.37":
          // ExtKeyUsage
          try {
            this.parsedValue = new ExtKeyUsage({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new ExtKeyUsage();
            this.parsedValue.parsingError = "Incorrectly formated ExtKeyUsage";
          }

          break;

        case "2.5.29.54":
          // InhibitAnyPolicy
          this.parsedValue = asn1.result; // Should be just a simple INTEGER

          break;

        case "1.3.6.1.5.5.7.1.1": // AuthorityInfoAccess

        case "1.3.6.1.5.5.7.1.11":
          // SubjectInfoAccess
          try {
            this.parsedValue = new InfoAccess({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new InfoAccess();
            this.parsedValue.parsingError = "Incorrectly formated InfoAccess";
          }

          break;

        case "1.3.6.1.4.1.11129.2.4.2":
          // SignedCertificateTimestampList
          try {
            this.parsedValue = new SignedCertificateTimestampList({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new SignedCertificateTimestampList();
            this.parsedValue.parsingError = "Incorrectly formated SignedCertificateTimestampList";
          }

          break;

        case "1.3.6.1.4.1.311.20.2":
          // szOID_ENROLL_CERTTYPE_EXTENSION - Microsoft-specific extension
          this.parsedValue = asn1.result; // Used to be simple Unicode string

          break;

        case "1.3.6.1.4.1.311.21.2":
          // szOID_CERTSRV_PREVIOUS_CERT_HASH - Microsoft-specific extension
          this.parsedValue = asn1.result; // Used to be simple OctetString

          break;

        case "1.3.6.1.4.1.311.21.7":
          // szOID_CERTIFICATE_TEMPLATE - Microsoft-specific extension
          try {
            this.parsedValue = new CertificateTemplate({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new CertificateTemplate();
            this.parsedValue.parsingError = "Incorrectly formated CertificateTemplate";
          }

          break;

        case "1.3.6.1.4.1.311.21.1":
          // szOID_CERTSRV_CA_VERSION - Microsoft-specific extension
          try {
            this.parsedValue = new CAVersion({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new CAVersion();
            this.parsedValue.parsingError = "Incorrectly formated CAVersion";
          }

          break;

        case "1.3.6.1.5.5.7.1.3":
          // QCStatements
          try {
            this.parsedValue = new QCStatements({
              schema: asn1.result
            });
          } catch (ex) {
            this.parsedValue = new QCStatements();
            this.parsedValue.parsingError = "Incorrectly formated QCStatements";
          }

          break;

        default:
      } //endregion
      //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(new ObjectIdentifier({
        value: this.extnID
      }));
      if (this.critical !== Extension.defaultValues("critical")) outputArray.push(new Boolean({
        value: this.critical
      }));
      outputArray.push(this.extnValue); //endregion
      //region Construct and return new ASN.1 schema for this object

      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        extnID: this.extnID,
        extnValue: this.extnValue.toJSON()
      };
      if (this.critical !== Extension.defaultValues("critical")) object.critical = this.critical;

      if ("parsedValue" in this) {
        if ("toJSON" in this.parsedValue) object.parsedValue = this.parsedValue.toJSON();
      }

      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class Extensions {
    //**********************************************************************************

    /**
     * Constructor for Extensions class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<Extension>}
       * @desc type
       */
      this.extensions = getParametersValue(parameters, "extensions", Extensions.defaultValues("extensions")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "extensions":
          return [];

        default:
          throw new Error("Invalid member name for Extensions class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @param {boolean} optional Flag that current schema should be optional
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [extensions]
       * @property {string} [extension]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        optional,
        name: names.blockName || "",
        value: [new Repeated({
          name: names.extensions || "",
          value: Extension.schema(names.extension || {})
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["extensions"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, Extensions.schema({
        names: {
          extensions: "extensions"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Extensions"); //endregion
      //region Get internal properties from parsed schema

      this.extensions = Array.from(asn1.result.extensions, element => new Extension({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: Array.from(this.extensions, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        extensions: Array.from(this.extensions, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************


    tbsCertificate() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    //TBSCertificate  ::=  SEQUENCE  {
    //    version         [0]  EXPLICIT Version DEFAULT v1,
    //    serialNumber         CertificateSerialNumber,
    //    signature            AlgorithmIdentifier,
    //    issuer               Name,
    //    validity             Validity,
    //    subject              Name,
    //    subjectPublicKeyInfo SubjectPublicKeyInfo,
    //    issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
    //                         -- If present, version MUST be v2 or v3
    //    subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
    //                         -- If present, version MUST be v2 or v3
    //    extensions      [3]  EXPLICIT Extensions OPTIONAL
    //    -- If present, version MUST be v3
    //}

    /**
     * @type {Object}
     * @property {string} [blockName]
     * @property {string} [tbsCertificateVersion]
     * @property {string} [tbsCertificateSerialNumber]
     * @property {string} [signature]
     * @property {string} [issuer]
     * @property {string} [tbsCertificateValidity]
     * @property {string} [notBefore]
     * @property {string} [notAfter]
     * @property {string} [subject]
     * @property {string} [subjectPublicKeyInfo]
     * @property {string} [tbsCertificateIssuerUniqueID]
     * @property {string} [tbsCertificateSubjectUniqueID]
     * @property {string} [extensions]
     */
    var names = getParametersValue(parameters, "names", {});
    return new Sequence({
      name: names.blockName || "tbsCertificate",
      value: [new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 0 // [0]

        },
        value: [new Integer({
          name: names.tbsCertificateVersion || "tbsCertificate.version"
        }) // EXPLICIT integer value
        ]
      }), new Integer({
        name: names.tbsCertificateSerialNumber || "tbsCertificate.serialNumber"
      }), AlgorithmIdentifier.schema(names.signature || {
        names: {
          blockName: "tbsCertificate.signature"
        }
      }), RelativeDistinguishedNames.schema(names.issuer || {
        names: {
          blockName: "tbsCertificate.issuer"
        }
      }), new Sequence({
        name: names.tbsCertificateValidity || "tbsCertificate.validity",
        value: [Time.schema(names.notBefore || {
          names: {
            utcTimeName: "tbsCertificate.notBefore",
            generalTimeName: "tbsCertificate.notBefore"
          }
        }), Time.schema(names.notAfter || {
          names: {
            utcTimeName: "tbsCertificate.notAfter",
            generalTimeName: "tbsCertificate.notAfter"
          }
        })]
      }), RelativeDistinguishedNames.schema(names.subject || {
        names: {
          blockName: "tbsCertificate.subject"
        }
      }), PublicKeyInfo.schema(names.subjectPublicKeyInfo || {
        names: {
          blockName: "tbsCertificate.subjectPublicKeyInfo"
        }
      }), new Primitive({
        name: names.tbsCertificateIssuerUniqueID || "tbsCertificate.issuerUniqueID",
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 1 // [1]

        }
      }), // IMPLICIT bistring value
      new Primitive({
        name: names.tbsCertificateSubjectUniqueID || "tbsCertificate.subjectUniqueID",
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 2 // [2]

        }
      }), // IMPLICIT bistring value
      new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 3 // [3]

        },
        value: [Extensions.schema(names.extensions || {
          names: {
            blockName: "tbsCertificate.extensions"
          }
        })]
      }) // EXPLICIT SEQUENCE value
      ]
    });
  } //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class Certificate {
    //**********************************************************************************

    /**
     * Constructor for Certificate class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {ArrayBuffer}
       * @desc ToBeSigned (TBS) part of the certificate
       */
      this.tbs = getParametersValue(parameters, "tbs", Certificate.defaultValues("tbs"));
      /**
       * @type {number}
       * @desc Version number
       */

      this.version = getParametersValue(parameters, "version", Certificate.defaultValues("version"));
      /**
       * @type {Integer}
       * @desc Serial number of the certificate
       */

      this.serialNumber = getParametersValue(parameters, "serialNumber", Certificate.defaultValues("serialNumber"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc This field contains the algorithm identifier for the algorithm used by the CA to sign the certificate
       */

      this.signature = getParametersValue(parameters, "signature", Certificate.defaultValues("signature"));
      /**
       * @type {RelativeDistinguishedNames}
       * @desc The issuer field identifies the entity that has signed and issued the certificate
       */

      this.issuer = getParametersValue(parameters, "issuer", Certificate.defaultValues("issuer"));
      /**
       * @type {Time}
       * @desc The date on which the certificate validity period begins
       */

      this.notBefore = getParametersValue(parameters, "notBefore", Certificate.defaultValues("notBefore"));
      /**
       * @type {Time}
       * @desc The date on which the certificate validity period ends
       */

      this.notAfter = getParametersValue(parameters, "notAfter", Certificate.defaultValues("notAfter"));
      /**
       * @type {RelativeDistinguishedNames}
       * @desc The subject field identifies the entity associated with the public key stored in the subject public key field
       */

      this.subject = getParametersValue(parameters, "subject", Certificate.defaultValues("subject"));
      /**
       * @type {PublicKeyInfo}
       * @desc This field is used to carry the public key and identify the algorithm with which the key is used
       */

      this.subjectPublicKeyInfo = getParametersValue(parameters, "subjectPublicKeyInfo", Certificate.defaultValues("subjectPublicKeyInfo"));
      if ("issuerUniqueID" in parameters)
        /**
         * @type {ArrayBuffer}
         * @desc The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time
         */
        this.issuerUniqueID = getParametersValue(parameters, "issuerUniqueID", Certificate.defaultValues("issuerUniqueID"));
      if ("subjectUniqueID" in parameters)
        /**
         * @type {ArrayBuffer}
         * @desc The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time
         */
        this.subjectUniqueID = getParametersValue(parameters, "subjectUniqueID", Certificate.defaultValues("subjectUniqueID"));
      if ("extensions" in parameters)
        /**
         * @type {Array}
         * @desc If present, this field is a SEQUENCE of one or more certificate extensions
         */
        this.extensions = getParametersValue(parameters, "extensions", Certificate.defaultValues("extensions"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc The signatureAlgorithm field contains the identifier for the cryptographic algorithm used by the CA to sign this certificate
       */

      this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", Certificate.defaultValues("signatureAlgorithm"));
      /**
       * @type {BitString}
       * @desc The signatureValue field contains a digital signature computed upon the ASN.1 DER encoded tbsCertificate
       */

      this.signatureValue = getParametersValue(parameters, "signatureValue", Certificate.defaultValues("signatureValue")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "tbs":
          return new ArrayBuffer(0);

        case "version":
          return 0;

        case "serialNumber":
          return new Integer();

        case "signature":
          return new AlgorithmIdentifier();

        case "issuer":
          return new RelativeDistinguishedNames();

        case "notBefore":
          return new Time();

        case "notAfter":
          return new Time();

        case "subject":
          return new RelativeDistinguishedNames();

        case "subjectPublicKeyInfo":
          return new PublicKeyInfo();

        case "issuerUniqueID":
          return new ArrayBuffer(0);

        case "subjectUniqueID":
          return new ArrayBuffer(0);

        case "extensions":
          return [];

        case "signatureAlgorithm":
          return new AlgorithmIdentifier();

        case "signatureValue":
          return new BitString();

        default:
          throw new Error("Invalid member name for Certificate class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * Certificate  ::=  SEQUENCE  {
     *    tbsCertificate       TBSCertificate,
     *    signatureAlgorithm   AlgorithmIdentifier,
     *    signatureValue       BIT STRING  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [tbsCertificate]
       * @property {string} [signatureAlgorithm]
       * @property {string} [signatureValue]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [tbsCertificate(names.tbsCertificate), AlgorithmIdentifier.schema(names.signatureAlgorithm || {
          names: {
            blockName: "signatureAlgorithm"
          }
        }), new BitString({
          name: names.signatureValue || "signatureValue"
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["tbsCertificate", "tbsCertificate.extensions", "tbsCertificate.version", "tbsCertificate.serialNumber", "tbsCertificate.signature", "tbsCertificate.issuer", "tbsCertificate.notBefore", "tbsCertificate.notAfter", "tbsCertificate.subject", "tbsCertificate.subjectPublicKeyInfo", "tbsCertificate.issuerUniqueID", "tbsCertificate.subjectUniqueID", "signatureAlgorithm", "signatureValue"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, Certificate.schema({
        names: {
          tbsCertificate: {
            names: {
              extensions: {
                names: {
                  extensions: "tbsCertificate.extensions"
                }
              }
            }
          }
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Certificate"); //endregion
      //region Get internal properties from parsed schema

      this.tbs = asn1.result.tbsCertificate.valueBeforeDecode;
      if ("tbsCertificate.version" in asn1.result) this.version = asn1.result["tbsCertificate.version"].valueBlock.valueDec;
      this.serialNumber = asn1.result["tbsCertificate.serialNumber"];
      this.signature = new AlgorithmIdentifier({
        schema: asn1.result["tbsCertificate.signature"]
      });
      this.issuer = new RelativeDistinguishedNames({
        schema: asn1.result["tbsCertificate.issuer"]
      });
      this.notBefore = new Time({
        schema: asn1.result["tbsCertificate.notBefore"]
      });
      this.notAfter = new Time({
        schema: asn1.result["tbsCertificate.notAfter"]
      });
      this.subject = new RelativeDistinguishedNames({
        schema: asn1.result["tbsCertificate.subject"]
      });
      this.subjectPublicKeyInfo = new PublicKeyInfo({
        schema: asn1.result["tbsCertificate.subjectPublicKeyInfo"]
      });
      if ("tbsCertificate.issuerUniqueID" in asn1.result) this.issuerUniqueID = asn1.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex;
      if ("tbsCertificate.subjectUniqueID" in asn1.result) this.subjectUniqueID = asn1.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex;
      if ("tbsCertificate.extensions" in asn1.result) this.extensions = Array.from(asn1.result["tbsCertificate.extensions"], element => new Extension({
        schema: element
      }));
      this.signatureAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.signatureAlgorithm
      });
      this.signatureValue = asn1.result.signatureValue; //endregion
    } //**********************************************************************************

    /**
     * Create ASN.1 schema for existing values of TBS part for the certificate
     */


    encodeTBS() {
      //region Create array for output sequence
      var outputArray = [];

      if ("version" in this && this.version !== Certificate.defaultValues("version")) {
        outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Integer({
            value: this.version
          }) // EXPLICIT integer value
          ]
        }));
      }

      outputArray.push(this.serialNumber);
      outputArray.push(this.signature.toSchema());
      outputArray.push(this.issuer.toSchema());
      outputArray.push(new Sequence({
        value: [this.notBefore.toSchema(), this.notAfter.toSchema()]
      }));
      outputArray.push(this.subject.toSchema());
      outputArray.push(this.subjectPublicKeyInfo.toSchema());

      if ("issuerUniqueID" in this) {
        outputArray.push(new Primitive({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          valueHex: this.issuerUniqueID
        }));
      }

      if ("subjectUniqueID" in this) {
        outputArray.push(new Primitive({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 2 // [2]

          },
          valueHex: this.subjectUniqueID
        }));
      }

      if ("extensions" in this) {
        outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 3 // [3]

          },
          value: [new Sequence({
            value: Array.from(this.extensions, element => element.toSchema())
          })]
        }));
      } //endregion
      //region Create and return output sequence


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var tbsSchema = {}; //region Decode stored TBS value

      if (encodeFlag === false) {
        if (this.tbs.length === 0) // No stored certificate TBS part
          return Certificate.schema().value[0];
        tbsSchema = fromBER(this.tbs).result;
      } //endregion
      //region Create TBS schema via assembling from TBS parts
      else tbsSchema = this.encodeTBS(); //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        tbs: bufferToHexCodes(this.tbs, 0, this.tbs.byteLength),
        serialNumber: this.serialNumber.toJSON(),
        signature: this.signature.toJSON(),
        issuer: this.issuer.toJSON(),
        notBefore: this.notBefore.toJSON(),
        notAfter: this.notAfter.toJSON(),
        subject: this.subject.toJSON(),
        subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
        signatureAlgorithm: this.signatureAlgorithm.toJSON(),
        signatureValue: this.signatureValue.toJSON()
      };
      if ("version" in this && this.version !== Certificate.defaultValues("version")) object.version = this.version;
      if ("issuerUniqueID" in this) object.issuerUniqueID = bufferToHexCodes(this.issuerUniqueID, 0, this.issuerUniqueID.byteLength);
      if ("subjectUniqueID" in this) object.subjectUniqueID = bufferToHexCodes(this.subjectUniqueID, 0, this.subjectUniqueID.byteLength);
      if ("extensions" in this) object.extensions = Array.from(this.extensions, element => element.toJSON());
      return object;
    } //**********************************************************************************

    /**
     * Importing public key for current certificate
     */


    getPublicKey() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return getEngine().subtle.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
    } //**********************************************************************************

    /**
     * Get hash value for subject public key (default SHA-1)
     * @param {String} [hashAlgorithm=SHA-1] Hashing algorithm name
     */


    getKeyHash() {
      var hashAlgorithm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "SHA-1";
      //region Get a "crypto" extension
      var crypto = getCrypto();
      if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object"); //endregion

      return crypto.digest({
        name: hashAlgorithm
      }, new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex));
    } //**********************************************************************************

    /**
     * Make a signature for current value from TBS section
     * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
     * @param {string} [hashAlgorithm="SHA-1"] Hashing algorithm
     */


    sign(privateKey) {
      var hashAlgorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "SHA-1";
      //region Initial checking
      //region Check private key
      if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing"); //endregion
      //endregion
      //region Initial variables

      var sequence = Promise.resolve();
      var parameters;
      var engine = getEngine(); //endregion
      //region Get a "default parameters" for current algorithm and set correct signature algorithm

      sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
      sequence = sequence.then(result => {
        parameters = result.parameters;
        this.signature = result.signatureAlgorithm;
        this.signatureAlgorithm = result.signatureAlgorithm;
      }); //endregion
      //region Create TBS data for signing

      sequence = sequence.then(() => {
        this.tbs = this.encodeTBS().toBER(false);
      }); //endregion
      //region Signing TBS data on provided private key

      sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));
      sequence = sequence.then(result => {
        this.signatureValue = new BitString({
          valueHex: result
        });
      }); //endregion

      return sequence;
    } //**********************************************************************************


    verify() {
      var issuerCertificate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      //region Global variables
      var subjectPublicKeyInfo = {}; //endregion
      //region Set correct "subjectPublicKeyInfo" value

      if (issuerCertificate !== null) subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;else {
        if (this.issuer.isEqual(this.subject)) // Self-signed certificate
          subjectPublicKeyInfo = this.subjectPublicKeyInfo;
      }
      if (subjectPublicKeyInfo instanceof PublicKeyInfo === false) return Promise.reject("Please provide issuer certificate as a parameter"); //endregion

      return getEngine().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class RevokedCertificate {
    //**********************************************************************************

    /**
     * Constructor for RevokedCertificate class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Integer}
       * @desc userCertificate
       */
      this.userCertificate = getParametersValue(parameters, "userCertificate", RevokedCertificate.defaultValues("userCertificate"));
      /**
       * @type {Time}
       * @desc revocationDate
       */

      this.revocationDate = getParametersValue(parameters, "revocationDate", RevokedCertificate.defaultValues("revocationDate"));
      if ("crlEntryExtensions" in parameters)
        /**
         * @type {Extensions}
         * @desc crlEntryExtensions
         */
        this.crlEntryExtensions = getParametersValue(parameters, "crlEntryExtensions", RevokedCertificate.defaultValues("crlEntryExtensions")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "userCertificate":
          return new Integer();

        case "revocationDate":
          return new Time();

        case "crlEntryExtensions":
          return new Extensions();

        default:
          throw new Error("Invalid member name for RevokedCertificate class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * revokedCertificates     SEQUENCE OF SEQUENCE  {
        *        userCertificate         CertificateSerialNumber,
        *        revocationDate          Time,
        *        crlEntryExtensions      Extensions OPTIONAL
        *                                 -- if present, version MUST be v2
        *                             }  OPTIONAL,
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [userCertificate]
       * @property {string} [revocationDate]
       * @property {string} [crlEntryExtensions]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Integer({
          name: names.userCertificate || "userCertificate"
        }), Time.schema({
          names: {
            utcTimeName: names.revocationDate || "revocationDate",
            generalTimeName: names.revocationDate || "revocationDate"
          }
        }), Extensions.schema({
          names: {
            blockName: names.crlEntryExtensions || "crlEntryExtensions"
          }
        }, true)]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["userCertificate", "revocationDate", "crlEntryExtensions"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, RevokedCertificate.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RevokedCertificate"); //endregion
      //region Get internal properties from parsed schema

      this.userCertificate = asn1.result.userCertificate;
      this.revocationDate = new Time({
        schema: asn1.result.revocationDate
      });
      if ("crlEntryExtensions" in asn1.result) this.crlEntryExtensions = new Extensions({
        schema: asn1.result.crlEntryExtensions
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [this.userCertificate, this.revocationDate.toSchema()];
      if ("crlEntryExtensions" in this) outputArray.push(this.crlEntryExtensions.toSchema()); //endregion
      //region Construct and return new ASN.1 schema for this object

      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        userCertificate: this.userCertificate.toJSON(),
        revocationDate: this.revocationDate.toJSON
      };
      if ("crlEntryExtensions" in this) object.crlEntryExtensions = this.crlEntryExtensions.toJSON();
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************


    tbsCertList() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    //TBSCertList  ::=  SEQUENCE  {
    //    version                 Version OPTIONAL,
    //                                 -- if present, MUST be v2
    //    signature               AlgorithmIdentifier,
    //    issuer                  Name,
    //    thisUpdate              Time,
    //    nextUpdate              Time OPTIONAL,
    //    revokedCertificates     SEQUENCE OF SEQUENCE  {
    //        userCertificate         CertificateSerialNumber,
    //        revocationDate          Time,
    //        crlEntryExtensions      Extensions OPTIONAL
    //        -- if present, version MUST be v2
    //    }  OPTIONAL,
    //    crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
    //    -- if present, version MUST be v2
    //}

    /**
     * @type {Object}
     * @property {string} [blockName]
     * @property {string} [tbsCertListVersion]
     * @property {string} [signature]
     * @property {string} [issuer]
     * @property {string} [tbsCertListThisUpdate]
     * @property {string} [tbsCertListNextUpdate]
     * @property {string} [tbsCertListRevokedCertificates]
     * @property {string} [crlExtensions]
     */
    var names = getParametersValue(parameters, "names", {});
    return new Sequence({
      name: names.blockName || "tbsCertList",
      value: [new Integer({
        optional: true,
        name: names.tbsCertListVersion || "tbsCertList.version",
        value: 2
      }), // EXPLICIT integer value (v2)
      AlgorithmIdentifier.schema(names.signature || {
        names: {
          blockName: "tbsCertList.signature"
        }
      }), RelativeDistinguishedNames.schema(names.issuer || {
        names: {
          blockName: "tbsCertList.issuer"
        }
      }), Time.schema(names.tbsCertListThisUpdate || {
        names: {
          utcTimeName: "tbsCertList.thisUpdate",
          generalTimeName: "tbsCertList.thisUpdate"
        }
      }), Time.schema(names.tbsCertListNextUpdate || {
        names: {
          utcTimeName: "tbsCertList.nextUpdate",
          generalTimeName: "tbsCertList.nextUpdate"
        }
      }, true), new Sequence({
        optional: true,
        value: [new Repeated({
          name: names.tbsCertListRevokedCertificates || "tbsCertList.revokedCertificates",
          value: new Sequence({
            value: [new Integer(), Time.schema(), Extensions.schema({}, true)]
          })
        })]
      }), new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: 0 // [0]

        },
        value: [Extensions.schema(names.crlExtensions || {
          names: {
            blockName: "tbsCertList.extensions"
          }
        })]
      }) // EXPLICIT SEQUENCE value
      ]
    });
  } //**************************************************************************************

  /**
   * Class from RFC5280
   */


  class CertificateRevocationList {
    //**********************************************************************************

    /**
     * Constructor for Attribute class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {ArrayBuffer}
       * @desc tbs
       */
      this.tbs = getParametersValue(parameters, "tbs", CertificateRevocationList.defaultValues("tbs"));
      /**
       * @type {number}
       * @desc version
       */

      this.version = getParametersValue(parameters, "version", CertificateRevocationList.defaultValues("version"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc signature
       */

      this.signature = getParametersValue(parameters, "signature", CertificateRevocationList.defaultValues("signature"));
      /**
       * @type {RelativeDistinguishedNames}
       * @desc issuer
       */

      this.issuer = getParametersValue(parameters, "issuer", CertificateRevocationList.defaultValues("issuer"));
      /**
       * @type {Time}
       * @desc thisUpdate
       */

      this.thisUpdate = getParametersValue(parameters, "thisUpdate", CertificateRevocationList.defaultValues("thisUpdate"));
      if ("nextUpdate" in parameters)
        /**
         * @type {Time}
         * @desc nextUpdate
         */
        this.nextUpdate = getParametersValue(parameters, "nextUpdate", CertificateRevocationList.defaultValues("nextUpdate"));
      if ("revokedCertificates" in parameters)
        /**
         * @type {Array.<RevokedCertificate>}
         * @desc revokedCertificates
         */
        this.revokedCertificates = getParametersValue(parameters, "revokedCertificates", CertificateRevocationList.defaultValues("revokedCertificates"));
      if ("crlExtensions" in parameters)
        /**
         * @type {Extensions}
         * @desc crlExtensions
         */
        this.crlExtensions = getParametersValue(parameters, "crlExtensions", CertificateRevocationList.defaultValues("crlExtensions"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc signatureAlgorithm
       */

      this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", CertificateRevocationList.defaultValues("signatureAlgorithm"));
      /**
       * @type {BitString}
       * @desc signatureValue
       */

      this.signatureValue = getParametersValue(parameters, "signatureValue", CertificateRevocationList.defaultValues("signatureValue")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "tbs":
          return new ArrayBuffer(0);

        case "version":
          return 1;

        case "signature":
          return new AlgorithmIdentifier();

        case "issuer":
          return new RelativeDistinguishedNames();

        case "thisUpdate":
          return new Time();

        case "nextUpdate":
          return new Time();

        case "revokedCertificates":
          return [];

        case "crlExtensions":
          return new Extensions();

        case "signatureAlgorithm":
          return new AlgorithmIdentifier();

        case "signatureValue":
          return new BitString();

        default:
          throw new Error("Invalid member name for CertificateRevocationList class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * CertificateList  ::=  SEQUENCE  {
     *    tbsCertList          TBSCertList,
     *    signatureAlgorithm   AlgorithmIdentifier,
     *    signatureValue       BIT STRING  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [signatureAlgorithm]
       * @property {string} [signatureValue]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "CertificateList",
        value: [tbsCertList(parameters), AlgorithmIdentifier.schema(names.signatureAlgorithm || {
          names: {
            blockName: "signatureAlgorithm"
          }
        }), new BitString({
          name: names.signatureValue || "signatureValue"
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["tbsCertList", "tbsCertList.version", "tbsCertList.signature", "tbsCertList.issuer", "tbsCertList.thisUpdate", "tbsCertList.nextUpdate", "tbsCertList.revokedCertificates", "tbsCertList.extensions", "signatureAlgorithm", "signatureValue"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, CertificateRevocationList.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertificateRevocationList"); //endregion
      //region Get internal properties from parsed schema
      // noinspection JSUnresolvedVariable

      this.tbs = asn1.result.tbsCertList.valueBeforeDecode;
      if ("tbsCertList.version" in asn1.result) this.version = asn1.result["tbsCertList.version"].valueBlock.valueDec;
      this.signature = new AlgorithmIdentifier({
        schema: asn1.result["tbsCertList.signature"]
      });
      this.issuer = new RelativeDistinguishedNames({
        schema: asn1.result["tbsCertList.issuer"]
      });
      this.thisUpdate = new Time({
        schema: asn1.result["tbsCertList.thisUpdate"]
      });
      if ("tbsCertList.nextUpdate" in asn1.result) this.nextUpdate = new Time({
        schema: asn1.result["tbsCertList.nextUpdate"]
      });
      if ("tbsCertList.revokedCertificates" in asn1.result) this.revokedCertificates = Array.from(asn1.result["tbsCertList.revokedCertificates"], element => new RevokedCertificate({
        schema: element
      }));
      if ("tbsCertList.extensions" in asn1.result) this.crlExtensions = new Extensions({
        schema: asn1.result["tbsCertList.extensions"]
      });
      this.signatureAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.signatureAlgorithm
      });
      this.signatureValue = asn1.result.signatureValue; //endregion
    } //**********************************************************************************


    encodeTBS() {
      //region Create array for output sequence
      var outputArray = [];
      if (this.version !== CertificateRevocationList.defaultValues("version")) outputArray.push(new Integer({
        value: this.version
      }));
      outputArray.push(this.signature.toSchema());
      outputArray.push(this.issuer.toSchema());
      outputArray.push(this.thisUpdate.toSchema());
      if ("nextUpdate" in this) outputArray.push(this.nextUpdate.toSchema());

      if ("revokedCertificates" in this) {
        outputArray.push(new Sequence({
          value: Array.from(this.revokedCertificates, element => element.toSchema())
        }));
      }

      if ("crlExtensions" in this) {
        outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [this.crlExtensions.toSchema()]
        }));
      } //endregion


      return new Sequence({
        value: outputArray
      });
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //region Decode stored TBS value
      var tbsSchema;

      if (encodeFlag === false) {
        if (this.tbs.length === 0) // No stored TBS part
          return CertificateRevocationList.schema();
        tbsSchema = fromBER(this.tbs).result;
      } //endregion
      //region Create TBS schema via assembling from TBS parts
      else tbsSchema = this.encodeTBS(); //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        tbs: bufferToHexCodes(this.tbs, 0, this.tbs.byteLength),
        signature: this.signature.toJSON(),
        issuer: this.issuer.toJSON(),
        thisUpdate: this.thisUpdate.toJSON(),
        signatureAlgorithm: this.signatureAlgorithm.toJSON(),
        signatureValue: this.signatureValue.toJSON()
      };
      if (this.version !== CertificateRevocationList.defaultValues("version")) object.version = this.version;
      if ("nextUpdate" in this) object.nextUpdate = this.nextUpdate.toJSON();
      if ("revokedCertificates" in this) object.revokedCertificates = Array.from(this.revokedCertificates, element => element.toJSON());
      if ("crlExtensions" in this) object.crlExtensions = this.crlExtensions.toJSON();
      return object;
    } //**********************************************************************************


    isCertificateRevoked(certificate) {
      //region Check that issuer of the input certificate is the same with issuer of this CRL
      if (this.issuer.isEqual(certificate.issuer) === false) return false; //endregion
      //region Check that there are revoked certificates in this CRL

      if ("revokedCertificates" in this === false) return false; //endregion
      //region Search for input certificate in revoked certificates array

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.revokedCertificates[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var revokedCertificate = _step8.value;
          if (revokedCertificate.userCertificate.isEqual(certificate.serialNumber)) return true;
        } //endregion

      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return false;
    } //**********************************************************************************

    /**
     * Make a signature for existing CRL data
     * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
     * @param {string} [hashAlgorithm] Hashing algorithm. Default SHA-1
     */


    sign(privateKey) {
      var hashAlgorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "SHA-1";
      //region Initial checking
      //region Get a private key from   parameter
      if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing"); //endregion
      //endregion
      //region Initial variables

      var sequence = Promise.resolve();
      var parameters;
      var engine = getEngine(); //endregion
      //region Get a "default parameters" for current algorithm and set correct signature algorithm

      sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
      sequence = sequence.then(result => {
        parameters = result.parameters;
        this.signature = result.signatureAlgorithm;
        this.signatureAlgorithm = result.signatureAlgorithm;
      }); //endregion
      //region Create TBS data for signing

      sequence = sequence.then(() => {
        this.tbs = this.encodeTBS().toBER(false);
      }); //endregion
      //region Signing TBS data on provided private key

      sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));
      sequence = sequence.then(result => {
        this.signatureValue = new BitString({
          valueHex: result
        });
      }); //endregion

      return sequence;
    } //**********************************************************************************

    /**
     * Verify existing signature
     * @param {{[issuerCertificate]: Object, [publicKeyInfo]: Object}} parameters
     * @returns {*}
     */


    verify() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Global variables
      var sequence = Promise.resolve();
      var subjectPublicKeyInfo = -1;
      var engine = getEngine(); //endregion
      //region Get information about CRL issuer certificate

      if ("issuerCertificate" in parameters) // "issuerCertificate" must be of type "Certificate"
        {
          subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo; // The CRL issuer name and "issuerCertificate" subject name are not equal

          if (this.issuer.isEqual(parameters.issuerCertificate.subject) === false) return Promise.resolve(false);
        } //region In case if there is only public key during verification


      if ("publicKeyInfo" in parameters) subjectPublicKeyInfo = parameters.publicKeyInfo; // Must be of type "PublicKeyInfo"
      //endregion

      if ("subjectPublicKey" in subjectPublicKeyInfo === false) return Promise.reject("Issuer's certificate must be provided as an input parameter"); //endregion
      //region Check the CRL for unknown critical extensions

      if ("crlExtensions" in this) {
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = this.crlExtensions.extensions[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var extension = _step9.value;

            if (extension.critical) {
              // We can not be sure that unknown extension has no value for CRL signature
              if ("parsedValue" in extension === false) return Promise.resolve(false);
            }
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      } //endregion


      sequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm));
      return sequence;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class OtherRevocationInfoFormat {
    //**********************************************************************************

    /**
     * Constructor for OtherRevocationInfoFormat class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc otherRevInfoFormat
       */
      this.otherRevInfoFormat = getParametersValue(parameters, "otherRevInfoFormat", OtherRevocationInfoFormat.defaultValues("otherRevInfoFormat"));
      /**
       * @type {Any}
       * @desc otherRevInfo
       */

      this.otherRevInfo = getParametersValue(parameters, "otherRevInfo", OtherRevocationInfoFormat.defaultValues("otherRevInfo")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "otherRevInfoFormat":
          return "";

        case "otherRevInfo":
          return new Any();

        default:
          throw new Error("Invalid member name for OtherRevocationInfoFormat class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * OtherCertificateFormat ::= SEQUENCE {
     *    otherRevInfoFormat OBJECT IDENTIFIER,
     *    otherRevInfo ANY DEFINED BY otherCertFormat }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [otherRevInfoFormat]
       * @property {string} [otherRevInfo]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.otherRevInfoFormat || "otherRevInfoFormat"
        }), new Any({
          name: names.otherRevInfo || "otherRevInfo"
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["otherRevInfoFormat", "otherRevInfo"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, OtherRevocationInfoFormat.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OtherRevocationInfoFormat"); //endregion
      //region Get internal properties from parsed schema

      this.otherRevInfoFormat = asn1.result.otherRevInfoFormat.valueBlock.toString();
      this.otherRevInfo = asn1.result.otherRevInfo; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new ObjectIdentifier({
          value: this.otherRevInfoFormat
        }), this.otherRevInfo]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        otherRevInfoFormat: this.otherRevInfoFormat
      };
      if (!(this.otherRevInfo instanceof Any)) object.otherRevInfo = this.otherRevInfo.toJSON();
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class SignedAndUnsignedAttributes {
    //**********************************************************************************

    /**
     * Constructor for SignedAndUnsignedAttributes class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc type
       */
      this.type = getParametersValue(parameters, "type", SignedAndUnsignedAttributes.defaultValues("type"));
      /**
       * @type {Array}
       * @desc attributes
       */

      this.attributes = getParametersValue(parameters, "attributes", SignedAndUnsignedAttributes.defaultValues("attributes"));
      /**
       * @type {ArrayBuffer}
       * @desc encodedValue Need to have it in order to successfully process with signature verification
       */

      this.encodedValue = getParametersValue(parameters, "encodedValue", SignedAndUnsignedAttributes.defaultValues("encodedValue")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "type":
          return -1;

        case "attributes":
          return [];

        case "encodedValue":
          return new ArrayBuffer(0);

        default:
          throw new Error("Invalid member name for SignedAndUnsignedAttributes class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "type":
          return memberValue === SignedAndUnsignedAttributes.defaultValues("type");

        case "attributes":
          return memberValue.length === 0;

        case "encodedValue":
          return memberValue.byteLength === 0;

        default:
          throw new Error("Invalid member name for SignedAndUnsignedAttributes class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * SignedAttributes ::= SET SIZE (1..MAX) OF Attribute
     *
     * UnsignedAttributes ::= SET SIZE (1..MAX) OF Attribute
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {number} [tagNumber]
       * @property {string} [attributes]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Constructed({
        name: names.blockName || "",
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: names.tagNumber // "SignedAttributes" = 0, "UnsignedAttributes" = 1

        },
        value: [new Repeated({
          name: names.attributes || "",
          value: Attribute.schema()
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["attributes"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, SignedAndUnsignedAttributes.schema({
        names: {
          tagNumber: this.type,
          attributes: "attributes"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SignedAndUnsignedAttributes"); //endregion
      //region Get internal properties from parsed schema

      this.type = asn1.result.idBlock.tagNumber;
      this.encodedValue = asn1.result.valueBeforeDecode; //region Change type from "[0]" to "SET" accordingly to standard

      var encodedView = new Uint8Array(this.encodedValue);
      encodedView[0] = 0x31; //endregion

      if ("attributes" in asn1.result === false) {
        if (this.type === 0) throw new Error("Wrong structure of SignedUnsignedAttributes");else return; // Not so important in case of "UnsignedAttributes"
      }

      this.attributes = Array.from(asn1.result.attributes, element => new Attribute({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      if (SignedAndUnsignedAttributes.compareWithDefault("type", this.type) || SignedAndUnsignedAttributes.compareWithDefault("attributes", this.attributes)) throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class"); //region Construct and return new ASN.1 schema for this object

      return new Constructed({
        optional: true,
        idBlock: {
          tagClass: 3,
          // CONTEXT-SPECIFIC
          tagNumber: this.type // "SignedAttributes" = 0, "UnsignedAttributes" = 1

        },
        value: Array.from(this.attributes, element => element.toSchema())
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      if (SignedAndUnsignedAttributes.compareWithDefault("type", this.type) || SignedAndUnsignedAttributes.compareWithDefault("attributes", this.attributes)) throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
      return {
        type: this.type,
        attributes: Array.from(this.attributes, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class IssuerAndSerialNumber {
    //**********************************************************************************

    /**
     * Constructor for IssuerAndSerialNumber class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {RelativeDistinguishedNames}
       * @desc issuer
       */
      this.issuer = getParametersValue(parameters, "issuer", IssuerAndSerialNumber.defaultValues("issuer"));
      /**
       * @type {Integer}
       * @desc serialNumber
       */

      this.serialNumber = getParametersValue(parameters, "serialNumber", IssuerAndSerialNumber.defaultValues("serialNumber")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "issuer":
          return new RelativeDistinguishedNames();

        case "serialNumber":
          return new Integer();

        default:
          throw new Error("Invalid member name for IssuerAndSerialNumber class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * IssuerAndSerialNumber ::= SEQUENCE {
     *    issuer Name,
     *    serialNumber CertificateSerialNumber }
     *
     * CertificateSerialNumber ::= INTEGER
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [issuer]
       * @property {string} [serialNumber]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [RelativeDistinguishedNames.schema(names.issuer || {}), new Integer({
          name: names.serialNumber || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["issuer", "serialNumber"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, IssuerAndSerialNumber.schema({
        names: {
          issuer: {
            names: {
              blockName: "issuer"
            }
          },
          serialNumber: "serialNumber"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for IssuerAndSerialNumber"); //endregion
      //region Get internal properties from parsed schema

      this.issuer = new RelativeDistinguishedNames({
        schema: asn1.result.issuer
      });
      this.serialNumber = asn1.result.serialNumber; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [this.issuer.toSchema(), this.serialNumber]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        issuer: this.issuer.toJSON(),
        serialNumber: this.serialNumber.toJSON()
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class SignerInfo {
    //**********************************************************************************

    /**
     * Constructor for SignerInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", SignerInfo.defaultValues("version"));
      /**
       * @type {Object}
       * @desc sid
       */

      this.sid = getParametersValue(parameters, "sid", SignerInfo.defaultValues("sid"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc digestAlgorithm
       */

      this.digestAlgorithm = getParametersValue(parameters, "digestAlgorithm", SignerInfo.defaultValues("digestAlgorithm"));
      if ("signedAttrs" in parameters)
        /**
         * @type {SignedAndUnsignedAttributes}
         * @desc signedAttrs
         */
        this.signedAttrs = getParametersValue(parameters, "signedAttrs", SignerInfo.defaultValues("signedAttrs"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc digestAlgorithm
       */

      this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", SignerInfo.defaultValues("signatureAlgorithm"));
      /**
       * @type {OctetString}
       * @desc signature
       */

      this.signature = getParametersValue(parameters, "signature", SignerInfo.defaultValues("signature"));
      if ("unsignedAttrs" in parameters)
        /**
         * @type {SignedAndUnsignedAttributes}
         * @desc unsignedAttrs
         */
        this.unsignedAttrs = getParametersValue(parameters, "unsignedAttrs", SignerInfo.defaultValues("unsignedAttrs")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 0;

        case "sid":
          return new Any();

        case "digestAlgorithm":
          return new AlgorithmIdentifier();

        case "signedAttrs":
          return new SignedAndUnsignedAttributes({
            type: 0
          });

        case "signatureAlgorithm":
          return new AlgorithmIdentifier();

        case "signature":
          return new OctetString();

        case "unsignedAttrs":
          return new SignedAndUnsignedAttributes({
            type: 1
          });

        default:
          throw new Error("Invalid member name for SignerInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "version":
          return SignerInfo.defaultValues("version") === memberValue;

        case "sid":
          return memberValue instanceof Any;

        case "digestAlgorithm":
          if (memberValue instanceof AlgorithmIdentifier === false) return false;
          return memberValue.isEqual(SignerInfo.defaultValues("digestAlgorithm"));

        case "signedAttrs":
          return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);

        case "signatureAlgorithm":
          if (memberValue instanceof AlgorithmIdentifier === false) return false;
          return memberValue.isEqual(SignerInfo.defaultValues("signatureAlgorithm"));

        case "signature":
        case "unsignedAttrs":
          return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);

        default:
          throw new Error("Invalid member name for SignerInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * SignerInfo ::= SEQUENCE {
     *    version CMSVersion,
     *    sid SignerIdentifier,
     *    digestAlgorithm DigestAlgorithmIdentifier,
     *    signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
     *    signatureAlgorithm SignatureAlgorithmIdentifier,
     *    signature SignatureValue,
     *    unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }
     *
     * SignerIdentifier ::= CHOICE {
     *    issuerAndSerialNumber IssuerAndSerialNumber,
     *    subjectKeyIdentifier [0] SubjectKeyIdentifier }
     *
     * SubjectKeyIdentifier ::= OCTET STRING
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [version]
       * @property {string} [sid]
       * @property {string} [digestAlgorithm]
       * @property {string} [signedAttrs]
       * @property {string} [signatureAlgorithm]
       * @property {string} [signature]
       * @property {string} [unsignedAttrs]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: "SignerInfo",
        value: [new Integer({
          name: names.version || "SignerInfo.version"
        }), new Choice({
          value: [IssuerAndSerialNumber.schema(names.sid || {
            names: {
              blockName: "SignerInfo.sid"
            }
          }), new Constructed({
            optional: true,
            name: names.sid || "SignerInfo.sid",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            value: [new OctetString()]
          })]
        }), AlgorithmIdentifier.schema(names.digestAlgorithm || {
          names: {
            blockName: "SignerInfo.digestAlgorithm"
          }
        }), SignedAndUnsignedAttributes.schema(names.signedAttrs || {
          names: {
            blockName: "SignerInfo.signedAttrs",
            tagNumber: 0
          }
        }), AlgorithmIdentifier.schema(names.signatureAlgorithm || {
          names: {
            blockName: "SignerInfo.signatureAlgorithm"
          }
        }), new OctetString({
          name: names.signature || "SignerInfo.signature"
        }), SignedAndUnsignedAttributes.schema(names.unsignedAttrs || {
          names: {
            blockName: "SignerInfo.unsignedAttrs",
            tagNumber: 1
          }
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["SignerInfo.version", "SignerInfo.sid", "SignerInfo.digestAlgorithm", "SignerInfo.signedAttrs", "SignerInfo.signatureAlgorithm", "SignerInfo.signature", "SignerInfo.unsignedAttrs"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, SignerInfo.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SignerInfo"); //endregion
      //region Get internal properties from parsed schema

      this.version = asn1.result["SignerInfo.version"].valueBlock.valueDec;
      var currentSid = asn1.result["SignerInfo.sid"];
      if (currentSid.idBlock.tagClass === 1) this.sid = new IssuerAndSerialNumber({
        schema: currentSid
      });else this.sid = currentSid;
      this.digestAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result["SignerInfo.digestAlgorithm"]
      });
      if ("SignerInfo.signedAttrs" in asn1.result) this.signedAttrs = new SignedAndUnsignedAttributes({
        type: 0,
        schema: asn1.result["SignerInfo.signedAttrs"]
      });
      this.signatureAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result["SignerInfo.signatureAlgorithm"]
      });
      this.signature = asn1.result["SignerInfo.signature"];
      if ("SignerInfo.unsignedAttrs" in asn1.result) this.unsignedAttrs = new SignedAndUnsignedAttributes({
        type: 1,
        schema: asn1.result["SignerInfo.unsignedAttrs"]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      if (SignerInfo.compareWithDefault("sid", this.sid)) throw new Error("Incorrectly initialized \"SignerInfo\" class"); //region Create array for output sequence 

      var outputArray = [];
      outputArray.push(new Integer({
        value: this.version
      }));
      if (this.sid instanceof IssuerAndSerialNumber) outputArray.push(this.sid.toSchema());else outputArray.push(this.sid);
      outputArray.push(this.digestAlgorithm.toSchema());

      if ("signedAttrs" in this) {
        if (SignerInfo.compareWithDefault("signedAttrs", this.signedAttrs) === false) outputArray.push(this.signedAttrs.toSchema());
      }

      outputArray.push(this.signatureAlgorithm.toSchema());
      outputArray.push(this.signature);

      if ("unsignedAttrs" in this) {
        if (SignerInfo.compareWithDefault("unsignedAttrs", this.unsignedAttrs) === false) outputArray.push(this.unsignedAttrs.toSchema());
      } //endregion 
      //region Construct and return new ASN.1 schema for this object 


      return new Sequence({
        value: outputArray
      }); //endregion 
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      if (SignerInfo.compareWithDefault("sid", this.sid)) throw new Error("Incorrectly initialized \"SignerInfo\" class");
      var _object = {
        version: this.version
      };
      if (!(this.sid instanceof Any)) _object.sid = this.sid.toJSON();
      _object.digestAlgorithm = this.digestAlgorithm.toJSON();
      if (SignerInfo.compareWithDefault("signedAttrs", this.signedAttrs) === false) _object.signedAttrs = this.signedAttrs.toJSON();
      _object.signatureAlgorithm = this.signatureAlgorithm.toJSON();
      _object.signature = this.signature.toJSON();
      if (SignerInfo.compareWithDefault("unsignedAttrs", this.unsignedAttrs) === false) _object.unsignedAttrs = this.unsignedAttrs.toJSON();
      return _object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5755
   */


  class AttCertValidityPeriod {
    //**********************************************************************************

    /**
     * Constructor for AttCertValidityPeriod class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {GeneralizedTime}
       * @desc notBeforeTime
       */
      this.notBeforeTime = getParametersValue(parameters, "notBeforeTime", AttCertValidityPeriod.defaultValues("notBeforeTime"));
      /**
       * @type {GeneralizedTime}
       * @desc notAfterTime
       */

      this.notAfterTime = getParametersValue(parameters, "notAfterTime", AttCertValidityPeriod.defaultValues("notAfterTime")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "notBeforeTime":
        case "notAfterTime":
          return new Date(0, 0, 0);

        default:
          throw new Error("Invalid member name for AttCertValidityPeriod class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AttCertValidityPeriod  ::= SEQUENCE {
     *   notBeforeTime  GeneralizedTime,
     *   notAfterTime   GeneralizedTime
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [notBeforeTime]
       * @property {string} [notAfterTime]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new GeneralizedTime({
          name: names.notBeforeTime || ""
        }), new GeneralizedTime({
          name: names.notAfterTime || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["notBeforeTime", "notAfterTime"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AttCertValidityPeriod.schema({
        names: {
          notBeforeTime: "notBeforeTime",
          notAfterTime: "notAfterTime"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttCertValidityPeriod"); //endregion
      //region Get internal properties from parsed schema

      this.notBeforeTime = asn1.result.notBeforeTime.toDate();
      this.notAfterTime = asn1.result.notAfterTime.toDate(); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new GeneralizedTime({
          valueDate: this.notBeforeTime
        }), new GeneralizedTime({
          valueDate: this.notAfterTime
        })]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        notBeforeTime: this.notBeforeTime,
        notAfterTime: this.notAfterTime
      };
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from RFC5755
   */


  class IssuerSerial {
    //**********************************************************************************

    /**
     * Constructor for IssuerSerial class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {RelativeDistinguishedNames}
       * @desc issuer
       */
      this.issuer = getParametersValue(parameters, "issuer", IssuerSerial.defaultValues("issuer"));
      /**
       * @type {Integer}
       * @desc serialNumber
       */

      this.serialNumber = getParametersValue(parameters, "serialNumber", IssuerSerial.defaultValues("serialNumber"));
      if ("issuerUID" in parameters)
        /**
         * @type {BitString}
         * @desc issuerUID
         */
        this.issuerUID = getParametersValue(parameters, "issuerUID", IssuerSerial.defaultValues("issuerUID")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "issuer":
          return new GeneralNames();

        case "serialNumber":
          return new Integer();

        case "issuerUID":
          return new BitString();

        default:
          throw new Error("Invalid member name for IssuerSerial class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * IssuerSerial  ::=  SEQUENCE {
     *   	issuer         GeneralNames,
     * 		serial         CertificateSerialNumber,
     * 		issuerUID      UniqueIdentifier OPTIONAL
     * }
     *
     * CertificateSerialNumber ::= INTEGER
     * UniqueIdentifier  ::=  BIT STRING
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [issuer]
       * @property {string} [serialNumber]
       * @property {string} [issuerUID]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [GeneralNames.schema(names.issuer || {}), new Integer({
          name: names.serialNumber || ""
        }), new BitString({
          optional: true,
          name: names.issuerUID || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["issuer", "serialNumber", "issuerUID"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, IssuerSerial.schema({
        names: {
          issuer: {
            names: {
              blockName: "issuer"
            }
          },
          serialNumber: "serialNumber",
          issuerUID: "issuerUID"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for IssuerSerial"); //endregion
      //region Get internal properties from parsed schema

      this.issuer = new GeneralNames({
        schema: asn1.result.issuer
      });
      this.serialNumber = asn1.result.serialNumber;
      if ("issuerUID" in asn1.result) this.issuerUID = asn1.result.issuerUID; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var result = new Sequence({
        value: [this.issuer.toSchema(), this.serialNumber]
      });
      if ("issuerUID" in this) result.valueBlock.value.push(this.issuerUID); //region Construct and return new ASN.1 schema for this object

      return result; //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var result = {
        issuer: this.issuer.toJSON(),
        serialNumber: this.serialNumber.toJSON()
      };
      if ("issuerUID" in this) result.issuerUID = this.issuerUID.toJSON();
      return result;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from RFC5755
   */


  class AttributeCertificateInfoV1 {
    //**********************************************************************************

    /**
     * Constructor for AttributeCertificateInfoV1 class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Number}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", AttributeCertificateInfoV1.defaultValues("version"));
      if ("baseCertificateID" in parameters)
        /**
         * @type {IssuerSerial}
         * @desc baseCertificateID
         */
        this.baseCertificateID = getParametersValue(parameters, "baseCertificateID", AttributeCertificateInfoV1.defaultValues("baseCertificateID"));
      if ("subjectName" in parameters)
        /**
         * @type {GeneralNames}
         * @desc subjectName
         */
        this.subjectName = getParametersValue(parameters, "subjectName", AttributeCertificateInfoV1.defaultValues("subjectName"));
      /**
       * @type {GeneralNames}
       * @desc issuer
       */

      this.issuer = getParametersValue(parameters, "issuer", AttributeCertificateInfoV1.defaultValues("issuer"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc signature
       */

      this.signature = getParametersValue(parameters, "signature", AttributeCertificateInfoV1.defaultValues("signature"));
      /**
       * @type {Integer}
       * @desc serialNumber
       */

      this.serialNumber = getParametersValue(parameters, "serialNumber", AttributeCertificateInfoV1.defaultValues("serialNumber"));
      /**
       * @type {AttCertValidityPeriod}
       * @desc attrCertValidityPeriod
       */

      this.attrCertValidityPeriod = getParametersValue(parameters, "attrCertValidityPeriod", AttributeCertificateInfoV1.defaultValues("attrCertValidityPeriod"));
      /**
       * @type {Array.<Attribute>}
       * @desc attributes
       */

      this.attributes = getParametersValue(parameters, "attributes", AttributeCertificateInfoV1.defaultValues("attributes"));
      if ("issuerUniqueID" in parameters)
        /**
         * @type {BitString}
         * @desc issuerUniqueID
         */
        this.issuerUniqueID = getParametersValue(parameters, "issuerUniqueID", AttributeCertificateInfoV1.defaultValues("issuerUniqueID"));
      if ("extensions" in parameters)
        /**
         * @type {Extensions}
         * @desc extensions
         */
        this.extensions = getParametersValue(parameters, "extensions", AttributeCertificateInfoV1.defaultValues("extensions")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 0;

        case "baseCertificateID":
          return new IssuerSerial();

        case "subjectName":
          return new GeneralNames();

        case "issuer":
          return {};

        case "signature":
          return new AlgorithmIdentifier();

        case "serialNumber":
          return new Integer();

        case "attrCertValidityPeriod":
          return new AttCertValidityPeriod();

        case "attributes":
          return [];

        case "issuerUniqueID":
          return new BitString();

        case "extensions":
          return new Extensions();

        default:
          throw new Error("Invalid member name for AttributeCertificateInfoV1 class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AttributeCertificateInfo ::= SEQUENCE {
     * 	version Version DEFAULT v1,
     * 	subject CHOICE {
     * 		baseCertificateID [0] IssuerSerial, -- associated with a Public Key Certificate
     * 		subjectName [1] GeneralNames }, -- associated with a name
     * 	issuer GeneralNames, -- CA issuing the attribute certificate
     * 	signature AlgorithmIdentifier,
     * 	serialNumber CertificateSerialNumber,
     * 	attrCertValidityPeriod AttCertValidityPeriod,
     * 	attributes SEQUENCE OF Attribute,
     * 	issuerUniqueID UniqueIdentifier OPTIONAL,
     * 	extensions Extensions OPTIONAL
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [issuer]
       * @property {string} [serialNumber]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Integer({
          name: names.version || ""
        }), new Choice({
          value: [new Constructed({
            name: names.baseCertificateID || "",
            idBlock: {
              tagClass: 3,
              tagNumber: 0 // [0]

            },
            value: IssuerSerial.schema().valueBlock.value
          }), new Constructed({
            name: names.subjectName || "",
            idBlock: {
              tagClass: 3,
              tagNumber: 1 // [2]

            },
            value: GeneralNames.schema().valueBlock.value
          })]
        }), GeneralNames.schema({
          names: {
            blockName: names.issuer || ""
          }
        }), AlgorithmIdentifier.schema(names.signature || {}), new Integer({
          name: names.serialNumber || ""
        }), AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}), new Sequence({
          name: names.attributes || "",
          value: [new Repeated({
            value: Attribute.schema()
          })]
        }), new BitString({
          optional: true,
          name: names.issuerUniqueID || ""
        }), Extensions.schema(names.extensions || {}, true)]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["version", "baseCertificateID", "subjectName", "issuer", "signature", "serialNumber", "attrCertValidityPeriod", "attributes", "issuerUniqueID", "extensions"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AttributeCertificateInfoV1.schema({
        names: {
          version: "version",
          baseCertificateID: "baseCertificateID",
          subjectName: "subjectName",
          issuer: "issuer",
          signature: {
            names: {
              blockName: "signature"
            }
          },
          serialNumber: "serialNumber",
          attrCertValidityPeriod: {
            names: {
              blockName: "attrCertValidityPeriod"
            }
          },
          attributes: "attributes",
          issuerUniqueID: "issuerUniqueID",
          extensions: {
            names: {
              blockName: "extensions"
            }
          }
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeCertificateInfoV1"); //endregion
      //region Get internal properties from parsed schema

      this.version = asn1.result.version.valueBlock.valueDec;

      if ("baseCertificateID" in asn1.result) {
        this.baseCertificateID = new IssuerSerial({
          schema: new Sequence({
            value: asn1.result.baseCertificateID.valueBlock.value
          })
        });
      }

      if ("subjectName" in asn1.result) {
        this.subjectName = new GeneralNames({
          schema: new Sequence({
            value: asn1.result.subjectName.valueBlock.value
          })
        });
      }

      this.issuer = asn1.result.issuer;
      this.signature = new AlgorithmIdentifier({
        schema: asn1.result.signature
      });
      this.serialNumber = asn1.result.serialNumber;
      this.attrCertValidityPeriod = new AttCertValidityPeriod({
        schema: asn1.result.attrCertValidityPeriod
      });
      this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element => new Attribute({
        schema: element
      }));
      if ("issuerUniqueID" in asn1.result) this.issuerUniqueID = asn1.result.issuerUniqueID;
      if ("extensions" in asn1.result) this.extensions = new Extensions({
        schema: asn1.result.extensions
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var result = new Sequence({
        value: [new Integer({
          value: this.version
        })]
      });

      if ("baseCertificateID" in this) {
        result.valueBlock.value.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0 // [0]

          },
          value: this.baseCertificateID.toSchema().valueBlock.value
        }));
      }

      if ("subjectName" in this) {
        result.valueBlock.value.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1 // [1]

          },
          value: this.subjectName.toSchema().valueBlock.value
        }));
      }

      result.valueBlock.value.push(this.issuer.toSchema());
      result.valueBlock.value.push(this.signature.toSchema());
      result.valueBlock.value.push(this.serialNumber);
      result.valueBlock.value.push(this.attrCertValidityPeriod.toSchema());
      result.valueBlock.value.push(new Sequence({
        value: Array.from(this.attributes, element => element.toSchema())
      }));
      if ("issuerUniqueID" in this) result.valueBlock.value.push(this.issuerUniqueID);
      if ("extensions" in this) result.valueBlock.value.push(this.extensions.toSchema());
      return result;
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var result = {
        version: this.version
      };
      if ("baseCertificateID" in this) result.baseCertificateID = this.baseCertificateID.toJSON();
      if ("subjectName" in this) result.subjectName = this.subjectName.toJSON();
      result.issuer = this.issuer.toJSON();
      result.signature = this.signature.toJSON();
      result.serialNumber = this.serialNumber.toJSON();
      result.attrCertValidityPeriod = this.attrCertValidityPeriod.toJSON();
      result.attributes = Array.from(this.attributes, element => element.toJSON());
      if ("issuerUniqueID" in this) result.issuerUniqueID = this.issuerUniqueID.toJSON();
      if ("extensions" in this) result.extensions = this.extensions.toJSON();
      return result;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from X.509:1997
   */


  class AttributeCertificateV1 {
    //**********************************************************************************

    /**
     * Constructor for AttributeCertificateV1 class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {AttributeCertificateInfoV1}
       * @desc acinfo
       */
      this.acinfo = getParametersValue(parameters, "acinfo", AttributeCertificateV1.defaultValues("acinfo"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc signatureAlgorithm
       */

      this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", AttributeCertificateV1.defaultValues("signatureAlgorithm"));
      /**
       * @type {BitString}
       * @desc signatureValue
       */

      this.signatureValue = getParametersValue(parameters, "signatureValue", AttributeCertificateV1.defaultValues("signatureValue")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "acinfo":
          return new AttributeCertificateInfoV1();

        case "signatureAlgorithm":
          return new AlgorithmIdentifier();

        case "signatureValue":
          return new BitString();

        default:
          throw new Error("Invalid member name for AttributeCertificateV1 class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AttributeCertificate ::= SEQUENCE {
     *   acinfo               AttributeCertificateInfoV1,
     *   signatureAlgorithm   AlgorithmIdentifier,
     *   signatureValue       BIT STRING
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {Object} [acinfo]
       * @property {Object} [signatureAlgorithm]
       * @property {string} [signatureValue]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [AttributeCertificateInfoV1.schema(names.acinfo || {}), AlgorithmIdentifier.schema(names.signatureAlgorithm || {}), new BitString({
          name: names.signatureValue || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["acinfo", "signatureValue", "signatureAlgorithm"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AttributeCertificateV1.schema({
        names: {
          acinfo: {
            names: {
              blockName: "acinfo"
            }
          },
          signatureAlgorithm: {
            names: {
              blockName: "signatureAlgorithm"
            }
          },
          signatureValue: "signatureValue"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeCertificateV1"); //endregion
      //region Get internal properties from parsed schema

      this.acinfo = new AttributeCertificateInfoV1({
        schema: asn1.result.acinfo
      });
      this.signatureAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.signatureAlgorithm
      });
      this.signatureValue = asn1.result.signatureValue; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      return new Sequence({
        value: [this.acinfo.toSchema(), this.signatureAlgorithm.toSchema(), this.signatureValue]
      });
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        acinfo: this.acinfo.toJSON(),
        signatureAlgorithm: this.signatureAlgorithm.toJSON(),
        signatureValue: this.signatureValue.toJSON()
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5755
   */


  class ObjectDigestInfo {
    //**********************************************************************************

    /**
     * Constructor for ObjectDigestInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Enumerated}
       * @desc digestedObjectType
       */
      this.digestedObjectType = getParametersValue(parameters, "digestedObjectType", ObjectDigestInfo.defaultValues("digestedObjectType"));
      if ("otherObjectTypeID" in parameters)
        /**
         * @type {ObjectIdentifier}
         * @desc otherObjectTypeID
         */
        this.otherObjectTypeID = getParametersValue(parameters, "otherObjectTypeID", ObjectDigestInfo.defaultValues("otherObjectTypeID"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc digestAlgorithm
       */

      this.digestAlgorithm = getParametersValue(parameters, "digestAlgorithm", ObjectDigestInfo.defaultValues("digestAlgorithm"));
      /**
       * @type {BitString}
       * @desc objectDigest
       */

      this.objectDigest = getParametersValue(parameters, "objectDigest", ObjectDigestInfo.defaultValues("objectDigest")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "digestedObjectType":
          return new Enumerated();

        case "otherObjectTypeID":
          return new ObjectIdentifier();

        case "digestAlgorithm":
          return new AlgorithmIdentifier();

        case "objectDigest":
          return new BitString();

        default:
          throw new Error("Invalid member name for ObjectDigestInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * ObjectDigestInfo ::= SEQUENCE {
     *   digestedObjectType  ENUMERATED {
     *     publicKey            (0),
     *     publicKeyCert        (1),
     *     otherObjectTypes     (2) },
     *   -- otherObjectTypes MUST NOT
     *   -- be used in this profile
     *   otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
     *   digestAlgorithm     AlgorithmIdentifier,
     *   objectDigest        BIT STRING
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [digestedObjectType]
       * @property {string} [otherObjectTypeID]
       * @property {string} [digestAlgorithm]
       * @property {string} [objectDigest]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Enumerated({
          name: names.digestedObjectType || ""
        }), new ObjectIdentifier({
          optional: true,
          name: names.otherObjectTypeID || ""
        }), AlgorithmIdentifier.schema(names.digestAlgorithm || {}), new BitString({
          name: names.objectDigest || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["digestedObjectType", "otherObjectTypeID", "digestAlgorithm", "objectDigest"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, ObjectDigestInfo.schema({
        names: {
          digestedObjectType: "digestedObjectType",
          otherObjectTypeID: "otherObjectTypeID",
          digestAlgorithm: {
            names: {
              blockName: "digestAlgorithm"
            }
          },
          objectDigest: "objectDigest"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ObjectDigestInfo"); //endregion
      //region Get internal properties from parsed schema

      this.digestedObjectType = asn1.result.digestedObjectType;
      if ("otherObjectTypeID" in asn1.result) this.otherObjectTypeID = asn1.result.otherObjectTypeID;
      this.digestAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.digestAlgorithm
      });
      this.objectDigest = asn1.result.objectDigest; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var result = new Sequence({
        value: [this.digestedObjectType]
      });
      if ("otherObjectTypeID" in this) result.value.push(this.otherObjectTypeID);
      result.value.push(this.digestAlgorithm.toSchema());
      result.value.push(this.objectDigest);
      return result;
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var result = {
        digestedObjectType: this.digestedObjectType.toJSON()
      };
      if ("otherObjectTypeID" in this) result.otherObjectTypeID = this.otherObjectTypeID.toJSON();
      result.digestAlgorithm = this.digestAlgorithm.toJSON();
      result.objectDigest = this.objectDigest.toJSON();
      return result;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from RFC5755
   */


  class V2Form {
    //**********************************************************************************

    /**
     * Constructor for V2Form class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("issuerName" in parameters)
        /**
         * @type {GeneralNames}
         * @desc issuerName
         */
        this.issuerName = getParametersValue(parameters, "issuerName", V2Form.defaultValues("issuerName"));
      if ("baseCertificateID" in parameters)
        /**
         * @type {IssuerSerial}
         * @desc baseCertificateID
         */
        this.baseCertificateID = getParametersValue(parameters, "baseCertificateID", V2Form.defaultValues("baseCertificateID"));
      if ("objectDigestInfo" in parameters)
        /**
         * @type {ObjectDigestInfo}
         * @desc objectDigestInfo
         */
        this.objectDigestInfo = getParametersValue(parameters, "objectDigestInfo", V2Form.defaultValues("objectDigestInfo")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "issuerName":
          return new GeneralNames();

        case "baseCertificateID":
          return new IssuerSerial();

        case "objectDigestInfo":
          return new ObjectDigestInfo();

        default:
          throw new Error("Invalid member name for V2Form class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * V2Form ::= SEQUENCE {
     *   issuerName            GeneralNames  OPTIONAL,
     *   baseCertificateID     [0] IssuerSerial  OPTIONAL,
     *   objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
     *     -- issuerName MUST be present in this profile
     *     -- baseCertificateID and objectDigestInfo MUST NOT
     *     -- be present in this profile
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [issuerName]
       * @property {string} [baseCertificateID]
       * @property {string} [objectDigestInfo]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [GeneralNames.schema({
          names: {
            blockName: names.issuerName
          }
        }, true), new Constructed({
          optional: true,
          name: names.baseCertificateID || "",
          idBlock: {
            tagClass: 3,
            tagNumber: 0 // [0]

          },
          value: IssuerSerial.schema().valueBlock.value
        }), new Constructed({
          optional: true,
          name: names.objectDigestInfo || "",
          idBlock: {
            tagClass: 3,
            tagNumber: 1 // [1]

          },
          value: ObjectDigestInfo.schema().valueBlock.value
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["issuerName", "baseCertificateID", "objectDigestInfo"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, V2Form.schema({
        names: {
          issuerName: "issuerName",
          baseCertificateID: "baseCertificateID",
          objectDigestInfo: "objectDigestInfo"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for V2Form"); //endregion
      //region Get internal properties from parsed schema

      if ("issuerName" in asn1.result) this.issuerName = new GeneralNames({
        schema: asn1.result.issuerName
      });

      if ("baseCertificateID" in asn1.result) {
        this.baseCertificateID = new IssuerSerial({
          schema: new Sequence({
            value: asn1.result.baseCertificateID.valueBlock.value
          })
        });
      }

      if ("objectDigestInfo" in asn1.result) {
        this.objectDigestInfo = new ObjectDigestInfo({
          schema: new Sequence({
            value: asn1.result.objectDigestInfo.valueBlock.value
          })
        });
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var result = new Sequence();
      if ("issuerName" in this) result.valueBlock.value.push(this.issuerName.toSchema());

      if ("baseCertificateID" in this) {
        result.valueBlock.value.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0 // [0]

          },
          value: this.baseCertificateID.toSchema().valueBlock.value
        }));
      }

      if ("objectDigestInfo" in this) {
        result.valueBlock.value.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1 // [1]

          },
          value: this.objectDigestInfo.toSchema().valueBlock.value
        }));
      } //region Construct and return new ASN.1 schema for this object


      return result; //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var result = {};
      if ("issuerName" in this) result.issuerName = this.issuerName.toJSON();
      if ("baseCertificateID" in this) result.baseCertificateID = this.baseCertificateID.toJSON();
      if ("objectDigestInfo" in this) result.objectDigestInfo = this.objectDigestInfo.toJSON();
      return result;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from RFC5755
   */


  class Holder {
    //**********************************************************************************

    /**
     * Constructor for Holder class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("baseCertificateID" in parameters)
        /**
         * @type {IssuerSerial}
         * @desc baseCertificateID
         */
        this.baseCertificateID = getParametersValue(parameters, "baseCertificateID", Holder.defaultValues("baseCertificateID"));
      if ("entityName" in parameters)
        /**
         * @type {GeneralNames}
         * @desc entityName
         */
        this.entityName = getParametersValue(parameters, "entityName", Holder.defaultValues("entityName"));
      if ("objectDigestInfo" in parameters)
        /**
         * @type {ObjectDigestInfo}
         * @desc objectDigestInfo
         */
        this.objectDigestInfo = getParametersValue(parameters, "objectDigestInfo", Holder.defaultValues("objectDigestInfo")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "baseCertificateID":
          return new IssuerSerial();

        case "entityName":
          return new GeneralNames();

        case "objectDigestInfo":
          return new ObjectDigestInfo();

        default:
          throw new Error("Invalid member name for Holder class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * Holder ::= SEQUENCE {
     *   baseCertificateID   [0] IssuerSerial OPTIONAL,
     *       -- the issuer and serial number of
     *       -- the holder's Public Key Certificate
     *   entityName          [1] GeneralNames OPTIONAL,
     *       -- the name of the claimant or role
     *   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
     *       -- used to directly authenticate the holder,
     *       -- for example, an executable
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [baseCertificateID]
       * @property {string} [entityName]
       * @property {string} [objectDigestInfo]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Constructed({
          optional: true,
          name: names.baseCertificateID || "",
          idBlock: {
            tagClass: 3,
            tagNumber: 0 // [0]

          },
          value: IssuerSerial.schema().valueBlock.value
        }), new Constructed({
          optional: true,
          name: names.entityName || "",
          idBlock: {
            tagClass: 3,
            tagNumber: 1 // [2]

          },
          value: GeneralNames.schema().valueBlock.value
        }), new Constructed({
          optional: true,
          name: names.objectDigestInfo || "",
          idBlock: {
            tagClass: 3,
            tagNumber: 2 // [2]

          },
          value: ObjectDigestInfo.schema().valueBlock.value
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["baseCertificateID", "entityName", "objectDigestInfo"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, Holder.schema({
        names: {
          baseCertificateID: "baseCertificateID",
          entityName: "entityName",
          objectDigestInfo: "objectDigestInfo"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Holder"); //endregion
      //region Get internal properties from parsed schema

      if ("baseCertificateID" in asn1.result) {
        this.baseCertificateID = new IssuerSerial({
          schema: new Sequence({
            value: asn1.result.baseCertificateID.valueBlock.value
          })
        });
      }

      if ("entityName" in asn1.result) {
        this.entityName = new GeneralNames({
          schema: new Sequence({
            value: asn1.result.entityName.valueBlock.value
          })
        });
      }

      if ("objectDigestInfo" in asn1.result) {
        this.objectDigestInfo = new ObjectDigestInfo({
          schema: new Sequence({
            value: asn1.result.objectDigestInfo.valueBlock.value
          })
        });
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var result = new Sequence();

      if ("baseCertificateID" in this) {
        result.valueBlock.value.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0 // [0]

          },
          value: this.baseCertificateID.toSchema().valueBlock.value
        }));
      }

      if ("entityName" in this) {
        result.valueBlock.value.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 1 // [1]

          },
          value: this.entityName.toSchema().valueBlock.value
        }));
      }

      if ("objectDigestInfo" in this) {
        result.valueBlock.value.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 2 // [2]

          },
          value: this.objectDigestInfo.toSchema().valueBlock.value
        }));
      }

      return result;
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var result = {};
      if ("baseCertificateID" in this) result.baseCertificateID = this.baseCertificateID.toJSON();
      if ("entityName" in this) result.entityName = this.entityName.toJSON();
      if ("objectDigestInfo" in this) result.objectDigestInfo = this.objectDigestInfo.toJSON();
      return result;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from RFC5755
   */


  class AttributeCertificateInfoV2 {
    //**********************************************************************************

    /**
     * Constructor for AttributeCertificateInfoV2 class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Number}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", AttributeCertificateInfoV2.defaultValues("version"));
      /**
       * @type {Holder}
       * @desc holder
       */

      this.holder = getParametersValue(parameters, "holder", AttributeCertificateInfoV2.defaultValues("holder"));
      /**
       * @type {GeneralNames|V2Form}
       * @desc issuer
       */

      this.issuer = getParametersValue(parameters, "issuer", AttributeCertificateInfoV2.defaultValues("issuer"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc signature
       */

      this.signature = getParametersValue(parameters, "signature", AttributeCertificateInfoV2.defaultValues("signature"));
      /**
       * @type {Integer}
       * @desc serialNumber
       */

      this.serialNumber = getParametersValue(parameters, "serialNumber", AttributeCertificateInfoV2.defaultValues("serialNumber"));
      /**
       * @type {AttCertValidityPeriod}
       * @desc attrCertValidityPeriod
       */

      this.attrCertValidityPeriod = getParametersValue(parameters, "attrCertValidityPeriod", AttributeCertificateInfoV2.defaultValues("attrCertValidityPeriod"));
      /**
       * @type {Array.<Attribute>}
       * @desc attributes
       */

      this.attributes = getParametersValue(parameters, "attributes", AttributeCertificateInfoV2.defaultValues("attributes"));
      if ("issuerUniqueID" in parameters)
        /**
         * @type {BitString}
         * @desc issuerUniqueID
         */
        this.issuerUniqueID = getParametersValue(parameters, "issuerUniqueID", AttributeCertificateInfoV2.defaultValues("issuerUniqueID"));
      if ("extensions" in parameters)
        /**
         * @type {Extensions}
         * @desc extensions
         */
        this.extensions = getParametersValue(parameters, "extensions", AttributeCertificateInfoV2.defaultValues("extensions")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 1;

        case "holder":
          return new Holder();

        case "issuer":
          return {};

        case "signature":
          return new AlgorithmIdentifier();

        case "serialNumber":
          return new Integer();

        case "attrCertValidityPeriod":
          return new AttCertValidityPeriod();

        case "attributes":
          return [];

        case "issuerUniqueID":
          return new BitString();

        case "extensions":
          return new Extensions();

        default:
          throw new Error("Invalid member name for AttributeCertificateInfoV2 class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AttributeCertificateInfoV2 ::= SEQUENCE {
     *   version                 AttCertVersion, -- version is v2
     *   holder                  Holder,
     *   issuer                  AttCertIssuer,
     *   signature               AlgorithmIdentifier,
     *   serialNumber            CertificateSerialNumber,
     *   attrCertValidityPeriod  AttCertValidityPeriod,
     *   attributes              SEQUENCE OF Attribute,
     *   issuerUniqueID          UniqueIdentifier OPTIONAL,
     *   extensions              Extensions OPTIONAL
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [issuer]
       * @property {string} [serialNumber]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new Integer({
          name: names.version || ""
        }), Holder.schema(names.holder || {}), new Choice({
          value: [GeneralNames.schema({
            names: {
              blockName: names.issuer || ""
            }
          }), new Constructed({
            name: names.issuer || "",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            value: V2Form.schema().valueBlock.value
          })]
        }), AlgorithmIdentifier.schema(names.signature || {}), new Integer({
          name: names.serialNumber || ""
        }), AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}), new Sequence({
          name: names.attributes || "",
          value: [new Repeated({
            value: Attribute.schema()
          })]
        }), new BitString({
          optional: true,
          name: names.issuerUniqueID || ""
        }), Extensions.schema(names.extensions || {}, true)]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["version", "holder", "issuer", "signature", "serialNumber", "attrCertValidityPeriod", "attributes", "issuerUniqueID", "extensions"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AttributeCertificateInfoV2.schema({
        names: {
          version: "version",
          holder: {
            names: {
              blockName: "holder"
            }
          },
          issuer: "issuer",
          signature: {
            names: {
              blockName: "signature"
            }
          },
          serialNumber: "serialNumber",
          attrCertValidityPeriod: {
            names: {
              blockName: "attrCertValidityPeriod"
            }
          },
          attributes: "attributes",
          issuerUniqueID: "issuerUniqueID",
          extensions: {
            names: {
              blockName: "extensions"
            }
          }
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeCertificateInfoV2"); //endregion
      //region Get internal properties from parsed schema

      this.version = asn1.result.version.valueBlock.valueDec;
      this.holder = new Holder({
        schema: asn1.result.holder
      });

      switch (asn1.result.issuer.idBlock.tagClass) {
        case 3:
          // V2Form
          this.issuer = new V2Form({
            schema: new Sequence({
              value: asn1.result.issuer.valueBlock.value
            })
          });
          break;

        case 1: // GeneralNames (should not be used)

        default:
          throw new Error("Incorect value for 'issuer' in AttributeCertificateInfoV2");
      }

      this.signature = new AlgorithmIdentifier({
        schema: asn1.result.signature
      });
      this.serialNumber = asn1.result.serialNumber;
      this.attrCertValidityPeriod = new AttCertValidityPeriod({
        schema: asn1.result.attrCertValidityPeriod
      });
      this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element => new Attribute({
        schema: element
      }));
      if ("issuerUniqueID" in asn1.result) this.issuerUniqueID = asn1.result.issuerUniqueID;
      if ("extensions" in asn1.result) this.extensions = new Extensions({
        schema: asn1.result.extensions
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var result = new Sequence({
        value: [new Integer({
          value: this.version
        }), this.holder.toSchema(), new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: this.issuer.toSchema().valueBlock.value
        }), this.signature.toSchema(), this.serialNumber, this.attrCertValidityPeriod.toSchema(), new Sequence({
          value: Array.from(this.attributes, element => element.toSchema())
        })]
      });
      if ("issuerUniqueID" in this) result.valueBlock.value.push(this.issuerUniqueID);
      if ("extensions" in this) result.valueBlock.value.push(this.extensions.toSchema());
      return result;
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var result = {
        version: this.version,
        holder: this.holder.toJSON(),
        issuer: this.issuer.toJSON(),
        signature: this.signature.toJSON(),
        serialNumber: this.serialNumber.toJSON(),
        attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),
        attributes: Array.from(this.attributes, element => element.toJSON())
      };
      if ("issuerUniqueID" in this) result.issuerUniqueID = this.issuerUniqueID.toJSON();
      if ("extensions" in this) result.extensions = this.extensions.toJSON();
      return result;
    } //**********************************************************************************


  } //**************************************************************************************

  /**
   * Class from RFC5755
   */


  class AttributeCertificateV2 {
    //**********************************************************************************

    /**
     * Constructor for AttributeCertificateV2 class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {AttributeCertificateInfoV2}
       * @desc acinfo
       */
      this.acinfo = getParametersValue(parameters, "acinfo", AttributeCertificateV2.defaultValues("acinfo"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc signatureAlgorithm
       */

      this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", AttributeCertificateV2.defaultValues("signatureAlgorithm"));
      /**
       * @type {BitString}
       * @desc signatureValue
       */

      this.signatureValue = getParametersValue(parameters, "signatureValue", AttributeCertificateV2.defaultValues("signatureValue")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "acinfo":
          return new AttributeCertificateInfoV2();

        case "signatureAlgorithm":
          return new AlgorithmIdentifier();

        case "signatureValue":
          return new BitString();

        default:
          throw new Error("Invalid member name for AttributeCertificateV2 class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * AttributeCertificate ::= SEQUENCE {
     *   acinfo               AttributeCertificateInfoV2,
     *   signatureAlgorithm   AlgorithmIdentifier,
     *   signatureValue       BIT STRING
     * }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {Object} [acinfo]
       * @property {Object} [signatureAlgorithm]
       * @property {string} [signatureValue]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [AttributeCertificateInfoV2.schema(names.acinfo || {}), AlgorithmIdentifier.schema(names.signatureAlgorithm || {}), new BitString({
          name: names.signatureValue || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["acinfo", "signatureAlgorithm", "signatureValue"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, AttributeCertificateV2.schema({
        names: {
          acinfo: {
            names: {
              blockName: "acinfo"
            }
          },
          signatureAlgorithm: {
            names: {
              blockName: "signatureAlgorithm"
            }
          },
          signatureValue: "signatureValue"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeCertificateV2"); //endregion
      //region Get internal properties from parsed schema

      this.acinfo = new AttributeCertificateInfoV2({
        schema: asn1.result.acinfo
      });
      this.signatureAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.signatureAlgorithm
      });
      this.signatureValue = asn1.result.signatureValue; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      return new Sequence({
        value: [this.acinfo.toSchema(), this.signatureAlgorithm.toSchema(), this.signatureValue]
      });
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        acinfo: this.acinfo.toJSON(),
        signatureAlgorithm: this.signatureAlgorithm.toJSON(),
        signatureValue: this.signatureValue.toJSON()
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class OtherCertificateFormat {
    //**********************************************************************************

    /**
     * Constructor for OtherCertificateFormat class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {string}
       * @desc otherCertFormat
       */
      this.otherCertFormat = getParametersValue(parameters, "otherCertFormat", OtherCertificateFormat.defaultValues("otherCertFormat"));
      /**
       * @type {Any}
       * @desc otherCert
       */

      this.otherCert = getParametersValue(parameters, "otherCert", OtherCertificateFormat.defaultValues("otherCert")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "otherCertFormat":
          return "";

        case "otherCert":
          return new Any();

        default:
          throw new Error("Invalid member name for OtherCertificateFormat class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * OtherCertificateFormat ::= SEQUENCE {
     *    otherCertFormat OBJECT IDENTIFIER,
     *    otherCert ANY DEFINED BY otherCertFormat }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [otherCertFormat]
       * @property {string} [otherCert]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [new ObjectIdentifier({
          name: names.otherCertFormat || "otherCertFormat"
        }), new Any({
          name: names.otherCert || "otherCert"
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["otherCertFormat", "otherCert"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, OtherCertificateFormat.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OtherCertificateFormat"); //endregion
      //region Get internal properties from parsed schema

      this.otherCertFormat = asn1.result.otherCertFormat.valueBlock.toString();
      this.otherCert = asn1.result.otherCert; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [new ObjectIdentifier({
          value: this.otherCertFormat
        }), this.otherCert]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var object = {
        otherCertFormat: this.otherCertFormat
      };
      if (!(this.otherCert instanceof Any)) object.otherCert = this.otherCert.toJSON();
      return object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class CertificateSet {
    //**********************************************************************************

    /**
     * Constructor for CertificateSet class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array}
       * @desc certificates
       */
      this.certificates = getParametersValue(parameters, "certificates", CertificateSet.defaultValues("certificates")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "certificates":
          return [];

        default:
          throw new Error("Invalid member name for Attribute class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * CertificateSet ::= SET OF CertificateChoices
     *
     * CertificateChoices ::= CHOICE {
     *    certificate Certificate,
     *    extendedCertificate [0] IMPLICIT ExtendedCertificate,  -- Obsolete
     *    v1AttrCert [1] IMPLICIT AttributeCertificateV1,        -- Obsolete
     *    v2AttrCert [2] IMPLICIT AttributeCertificateV2,
     *    other [3] IMPLICIT OtherCertificateFormat }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Set({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.certificates || "certificates",
          value: new Choice({
            value: [Certificate.schema(), new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 0 // [0]

              },
              value: [new Any()]
            }), // JUST A STUB
            new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 1 // [1]

              },
              value: AttributeCertificateV1.schema().valueBlock.value
            }), new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 2 // [2]

              },
              value: AttributeCertificateV2.schema().valueBlock.value
            }), new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 3 // [3]

              },
              value: OtherCertificateFormat.schema().valueBlock.value
            })]
          })
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["certificates"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, CertificateSet.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertificateSet"); //endregion
      //region Get internal properties from parsed schema

      this.certificates = Array.from(asn1.result.certificates || [], element => {
        var initialTagNumber = element.idBlock.tagNumber;
        if (element.idBlock.tagClass === 1) return new Certificate({
          schema: element
        }); //region Making "Sequence" from "Constructed" value

        var elementSequence = new Sequence({
          value: element.valueBlock.value
        }); //endregion

        switch (initialTagNumber) {
          case 1:
            return new AttributeCertificateV1({
              schema: elementSequence
            });

          case 2:
            return new AttributeCertificateV2({
              schema: elementSequence
            });

          case 3:
            return new OtherCertificateFormat({
              schema: elementSequence
            });

          case 0:
          default:
        }

        return element;
      }); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Set({
        value: Array.from(this.certificates, element => {
          switch (true) {
            case element instanceof Certificate:
              return element.toSchema();

            case element instanceof AttributeCertificateV1:
              return new Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 1 // [1]

                },
                value: element.toSchema().valueBlock.value
              });

            case element instanceof AttributeCertificateV2:
              return new Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 2 // [2]

                },
                value: element.toSchema().valueBlock.value
              });

            case element instanceof OtherCertificateFormat:
              return new Constructed({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 3 // [3]

                },
                value: element.toSchema().valueBlock.value
              });

            default:
          }

          return element;
        })
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        certificates: Array.from(this.certificates, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class RevocationInfoChoices {
    //**********************************************************************************

    /**
     * Constructor for RevocationInfoChoices class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<CertificateRevocationList>}
       * @desc crls
       */
      this.crls = getParametersValue(parameters, "crls", RevocationInfoChoices.defaultValues("crls"));
      /**
       * @type {Array.<OtherRevocationInfoFormat>}
       * @desc otherRevocationInfos
       */

      this.otherRevocationInfos = getParametersValue(parameters, "otherRevocationInfos", RevocationInfoChoices.defaultValues("otherRevocationInfos")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "crls":
          return [];

        case "otherRevocationInfos":
          return [];

        default:
          throw new Error("Invalid member name for RevocationInfoChoices class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * RevocationInfoChoices ::= SET OF RevocationInfoChoice
     *
     * RevocationInfoChoice ::= CHOICE {
     *    crl CertificateList,
     *    other [1] IMPLICIT OtherRevocationInfoFormat }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [crls]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Set({
        name: names.blockName || "",
        value: [new Repeated({
          name: names.crls || "",
          value: new Choice({
            value: [CertificateRevocationList.schema(), new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 1 // [1]

              },
              value: [new ObjectIdentifier(), new Any()]
            })]
          })
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["crls"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, RevocationInfoChoices.schema({
        names: {
          crls: "crls"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RevocationInfoChoices"); //endregion
      //region Get internal properties from parsed schema

      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = asn1.result.crls[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var element = _step10.value;
          if (element.idBlock.tagClass === 1) this.crls.push(new CertificateRevocationList({
            schema: element
          }));else this.otherRevocationInfos.push(new OtherRevocationInfoFormat({
            schema: element
          }));
        } //endregion

      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
            _iterator10.return();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output set
      var outputArray = [];
      outputArray.push(...Array.from(this.crls, element => element.toSchema()));
      outputArray.push(...Array.from(this.otherRevocationInfos, element => {
        var schema = element.toSchema();
        schema.idBlock.tagClass = 3;
        schema.idBlock.tagNumber = 1;
        return schema;
      })); //endregion
      //region Construct and return new ASN.1 schema for this object

      return new Set({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        crls: Array.from(this.crls, element => element.toJSON()),
        otherRevocationInfos: Array.from(this.otherRevocationInfos, element => element.toJSON())
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC3161
   */


  class MessageImprint {
    //**********************************************************************************

    /**
     * Constructor for MessageImprint class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {AlgorithmIdentifier}
       * @desc hashAlgorithm
       */
      this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", MessageImprint.defaultValues("hashAlgorithm"));
      /**
       * @type {OctetString}
       * @desc hashedMessage
       */

      this.hashedMessage = getParametersValue(parameters, "hashedMessage", MessageImprint.defaultValues("hashedMessage")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "hashAlgorithm":
          return new AlgorithmIdentifier();

        case "hashedMessage":
          return new OctetString();

        default:
          throw new Error("Invalid member name for MessageImprint class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "hashAlgorithm":
          return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;

        case "hashedMessage":
          return memberValue.isEqual(MessageImprint.defaultValues(memberName)) === 0;

        default:
          throw new Error("Invalid member name for MessageImprint class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * MessageImprint ::= SEQUENCE  {
     *    hashAlgorithm                AlgorithmIdentifier,
     *    hashedMessage                OCTET STRING  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [hashAlgorithm]
       * @property {string} [hashedMessage]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {}), new OctetString({
          name: names.hashedMessage || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["hashAlgorithm", "hashedMessage"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, MessageImprint.schema({
        names: {
          hashAlgorithm: {
            names: {
              blockName: "hashAlgorithm"
            }
          },
          hashedMessage: "hashedMessage"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for MessageImprint"); //endregion
      //region Get internal properties from parsed schema

      this.hashAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.hashAlgorithm
      });
      this.hashedMessage = asn1.result.hashedMessage; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [this.hashAlgorithm.toSchema(), this.hashedMessage]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        hashAlgorithm: this.hashAlgorithm.toJSON(),
        hashedMessage: this.hashedMessage.toJSON()
      };
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC3161. Accuracy represents the time deviation around the UTC time contained in GeneralizedTime.
   */


  class Accuracy {
    //**********************************************************************************

    /**
     * Constructor for Accuracy class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object
      if ("seconds" in parameters)
        /**
         * @type {number}
         * @desc seconds
         */
        this.seconds = getParametersValue(parameters, "seconds", Accuracy.defaultValues("seconds"));
      if ("millis" in parameters)
        /**
         * @type {number}
         * @desc millis
         */
        this.millis = getParametersValue(parameters, "millis", Accuracy.defaultValues("millis"));
      if ("micros" in parameters)
        /**
         * @type {number}
         * @desc micros
         */
        this.micros = getParametersValue(parameters, "micros", Accuracy.defaultValues("micros")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "seconds":
        case "millis":
        case "micros":
          return 0;

        default:
          throw new Error("Invalid member name for Accuracy class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "seconds":
        case "millis":
        case "micros":
          return memberValue === Accuracy.defaultValues(memberName);

        default:
          throw new Error("Invalid member name for Accuracy class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * Accuracy ::= SEQUENCE {
     *    seconds        INTEGER              OPTIONAL,
     *    millis     [0] INTEGER  (1..999)    OPTIONAL,
     *    micros     [1] INTEGER  (1..999)    OPTIONAL  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [seconds]
       * @property {string} [millis]
       * @property {string} [micros]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        optional: true,
        value: [new Integer({
          optional: true,
          name: names.seconds || ""
        }), new Primitive({
          name: names.millis || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          }
        }), new Primitive({
          name: names.micros || "",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          }
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["seconds", "millis", "micros"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, Accuracy.schema({
        names: {
          seconds: "seconds",
          millis: "millis",
          micros: "micros"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Accuracy"); //endregion
      //region Get internal properties from parsed schema

      if ("seconds" in asn1.result) this.seconds = asn1.result.seconds.valueBlock.valueDec;

      if ("millis" in asn1.result) {
        var intMillis = new Integer({
          valueHex: asn1.result.millis.valueBlock.valueHex
        });
        this.millis = intMillis.valueBlock.valueDec;
      }

      if ("micros" in asn1.result) {
        var intMicros = new Integer({
          valueHex: asn1.result.micros.valueBlock.valueHex
        });
        this.micros = intMicros.valueBlock.valueDec;
      } //endregion

    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array of output sequence
      var outputArray = [];
      if ("seconds" in this) outputArray.push(new Integer({
        value: this.seconds
      }));

      if ("millis" in this) {
        var intMillis = new Integer({
          value: this.millis
        });
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          valueHex: intMillis.valueBlock.valueHex
        }));
      }

      if ("micros" in this) {
        var intMicros = new Integer({
          value: this.micros
        });
        outputArray.push(new Primitive({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          valueHex: intMicros.valueBlock.valueHex
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {};
      if ("seconds" in this) _object.seconds = this.seconds;
      if ("millis" in this) _object.millis = this.millis;
      if ("micros" in this) _object.micros = this.micros;
      return _object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC3161
   */


  class TSTInfo {
    //**********************************************************************************

    /**
     * Constructor for TSTInfo class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", TSTInfo.defaultValues("version"));
      /**
       * @type {string}
       * @desc policy
       */

      this.policy = getParametersValue(parameters, "policy", TSTInfo.defaultValues("policy"));
      /**
       * @type {MessageImprint}
       * @desc messageImprint
       */

      this.messageImprint = getParametersValue(parameters, "messageImprint", TSTInfo.defaultValues("messageImprint"));
      /**
       * @type {Integer}
       * @desc serialNumber
       */

      this.serialNumber = getParametersValue(parameters, "serialNumber", TSTInfo.defaultValues("serialNumber"));
      /**
       * @type {Date}
       * @desc genTime
       */

      this.genTime = getParametersValue(parameters, "genTime", TSTInfo.defaultValues("genTime"));
      if ("accuracy" in parameters)
        /**
         * @type {Accuracy}
         * @desc accuracy
         */
        this.accuracy = getParametersValue(parameters, "accuracy", TSTInfo.defaultValues("accuracy"));
      if ("ordering" in parameters)
        /**
         * @type {boolean}
         * @desc ordering
         */
        this.ordering = getParametersValue(parameters, "ordering", TSTInfo.defaultValues("ordering"));
      if ("nonce" in parameters)
        /**
         * @type {Integer}
         * @desc nonce
         */
        this.nonce = getParametersValue(parameters, "nonce", TSTInfo.defaultValues("nonce"));
      if ("tsa" in parameters)
        /**
         * @type {GeneralName}
         * @desc tsa
         */
        this.tsa = getParametersValue(parameters, "tsa", TSTInfo.defaultValues("tsa"));
      if ("extensions" in parameters)
        /**
         * @type {Array.<Extension>}
         * @desc extensions
         */
        this.extensions = getParametersValue(parameters, "extensions", TSTInfo.defaultValues("extensions")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 0;

        case "policy":
          return "";

        case "messageImprint":
          return new MessageImprint();

        case "serialNumber":
          return new Integer();

        case "genTime":
          return new Date(0, 0, 0);

        case "accuracy":
          return new Accuracy();

        case "ordering":
          return false;

        case "nonce":
          return new Integer();

        case "tsa":
          return new GeneralName();

        case "extensions":
          return [];

        default:
          throw new Error("Invalid member name for TSTInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "version":
        case "policy":
        case "genTime":
        case "ordering":
          return memberValue === TSTInfo.defaultValues(memberName);

        case "messageImprint":
          return MessageImprint.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && MessageImprint.compareWithDefault("hashedMessage", memberValue.hashedMessage);

        case "serialNumber":
        case "nonce":
          return memberValue.isEqual(TSTInfo.defaultValues(memberName));

        case "accuracy":
          return Accuracy.compareWithDefault("seconds", memberValue.seconds) && Accuracy.compareWithDefault("millis", memberValue.millis) && Accuracy.compareWithDefault("micros", memberValue.micros);

        case "tsa":
          return GeneralName.compareWithDefault("type", memberValue.type) && GeneralName.compareWithDefault("value", memberValue.value);

        case "extensions":
          return memberValue.length === 0;

        default:
          throw new Error("Invalid member name for TSTInfo class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * TSTInfo ::= SEQUENCE  {
     *   version                      INTEGER  { v1(1) },
     *   policy                       TSAPolicyId,
     *   messageImprint               MessageImprint,
     *   serialNumber                 INTEGER,
     *   genTime                      GeneralizedTime,
     *   accuracy                     Accuracy                 OPTIONAL,
     *   ordering                     BOOLEAN             DEFAULT FALSE,
     *   nonce                        INTEGER                  OPTIONAL,
     *   tsa                          [0] GeneralName          OPTIONAL,
     *   extensions                   [1] IMPLICIT Extensions  OPTIONAL  }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [version]
       * @property {string} [policy]
       * @property {string} [messageImprint]
       * @property {string} [serialNumber]
       * @property {string} [genTime]
       * @property {string} [accuracy]
       * @property {string} [ordering]
       * @property {string} [nonce]
       * @property {string} [tsa]
       * @property {string} [extensions]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "TSTInfo",
        value: [new Integer({
          name: names.version || "TSTInfo.version"
        }), new ObjectIdentifier({
          name: names.policy || "TSTInfo.policy"
        }), MessageImprint.schema(names.messageImprint || {
          names: {
            blockName: "TSTInfo.messageImprint"
          }
        }), new Integer({
          name: names.serialNumber || "TSTInfo.serialNumber"
        }), new GeneralizedTime({
          name: names.genTime || "TSTInfo.genTime"
        }), Accuracy.schema(names.accuracy || {
          names: {
            blockName: "TSTInfo.accuracy"
          }
        }), new Boolean({
          name: names.ordering || "TSTInfo.ordering",
          optional: true
        }), new Integer({
          name: names.nonce || "TSTInfo.nonce",
          optional: true
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [GeneralName.schema(names.tsa || {
            names: {
              blockName: "TSTInfo.tsa"
            }
          })]
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [new Repeated({
            name: names.extensions || "TSTInfo.extensions",
            value: Extension.schema(names.extension || {})
          })]
        }) // IMPLICIT Extensions
        ]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["TSTInfo.version", "TSTInfo.policy", "TSTInfo.messageImprint", "TSTInfo.serialNumber", "TSTInfo.genTime", "TSTInfo.accuracy", "TSTInfo.ordering", "TSTInfo.nonce", "TSTInfo.tsa", "TSTInfo.extensions"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, TSTInfo.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for TSTInfo"); //endregion
      //region Get internal properties from parsed schema

      this.version = asn1.result["TSTInfo.version"].valueBlock.valueDec;
      this.policy = asn1.result["TSTInfo.policy"].valueBlock.toString();
      this.messageImprint = new MessageImprint({
        schema: asn1.result["TSTInfo.messageImprint"]
      });
      this.serialNumber = asn1.result["TSTInfo.serialNumber"];
      this.genTime = asn1.result["TSTInfo.genTime"].toDate();
      if ("TSTInfo.accuracy" in asn1.result) this.accuracy = new Accuracy({
        schema: asn1.result["TSTInfo.accuracy"]
      });
      if ("TSTInfo.ordering" in asn1.result) this.ordering = asn1.result["TSTInfo.ordering"].valueBlock.value;
      if ("TSTInfo.nonce" in asn1.result) this.nonce = asn1.result["TSTInfo.nonce"];
      if ("TSTInfo.tsa" in asn1.result) this.tsa = new GeneralName({
        schema: asn1.result["TSTInfo.tsa"]
      });
      if ("TSTInfo.extensions" in asn1.result) this.extensions = Array.from(asn1.result["TSTInfo.extensions"], element => new Extension({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(new Integer({
        value: this.version
      }));
      outputArray.push(new ObjectIdentifier({
        value: this.policy
      }));
      outputArray.push(this.messageImprint.toSchema());
      outputArray.push(this.serialNumber);
      outputArray.push(new GeneralizedTime({
        valueDate: this.genTime
      }));
      if ("accuracy" in this) outputArray.push(this.accuracy.toSchema());
      if ("ordering" in this) outputArray.push(new Boolean({
        value: this.ordering
      }));
      if ("nonce" in this) outputArray.push(this.nonce);

      if ("tsa" in this) {
        outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [this.tsa.toSchema()]
        }));
      } //region Create array of extensions


      if ("extensions" in this) {
        outputArray.push(new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: Array.from(this.extensions, element => element.toSchema())
        }));
      } //endregion
      //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        version: this.version,
        policy: this.policy,
        messageImprint: this.messageImprint.toJSON(),
        serialNumber: this.serialNumber.toJSON(),
        genTime: this.genTime
      };
      if ("accuracy" in this) _object.accuracy = this.accuracy.toJSON();
      if ("ordering" in this) _object.ordering = this.ordering;
      if ("nonce" in this) _object.nonce = this.nonce.toJSON();
      if ("tsa" in this) _object.tsa = this.tsa.toJSON();
      if ("extensions" in this) _object.extensions = Array.from(this.extensions, element => element.toJSON());
      return _object;
    } //**********************************************************************************

    /**
     * Verify current TST Info value
     * @param {{data: ArrayBuffer, notBefore: Date, notAfter: Date}} parameters Input parameters
     * @returns {Promise}
     */


    verify() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Initial variables
      var sequence = Promise.resolve();
      var data;
      var notBefore = null;
      var notAfter = null; //endregion
      //region Get a "crypto" extension

      var crypto = getCrypto();
      if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object"); //endregion
      //region Get initial parameters

      if ("data" in parameters) data = parameters.data;else return Promise.reject("\"data\" is a mandatory attribute for TST_INFO verification");
      if ("notBefore" in parameters) notBefore = parameters.notBefore;
      if ("notAfter" in parameters) notAfter = parameters.notAfter; //endregion
      //region Check date

      if (notBefore !== null) {
        if (this.genTime < notBefore) return Promise.reject("Generation time for TSTInfo object is less than notBefore value");
      }

      if (notAfter !== null) {
        if (this.genTime > notAfter) return Promise.reject("Generation time for TSTInfo object is more than notAfter value");
      } //endregion
      //region Find hashing algorithm


      var shaAlgorithm = getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId);
      if ("name" in shaAlgorithm === false) return Promise.reject("Unsupported signature algorithm: ".concat(this.messageImprint.hashAlgorithm.algorithmId)); //endregion
      //region Calculate message digest for input "data" buffer
      // noinspection JSCheck Signatures

      sequence = sequence.then(() => crypto.digest(shaAlgorithm.name, new Uint8Array(data))).then(result => isEqualBuffer(result, this.messageImprint.hashedMessage.valueBlock.valueHex)); //endregion

      return sequence;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************


  class CertificateChainValidationEngine {
    //**********************************************************************************

    /**
     * Constructor for CertificateChainValidationEngine class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {Array.<Certificate>}
       * @desc Array of pre-defined trusted (by user) certificates
       */
      this.trustedCerts = getParametersValue(parameters, "trustedCerts", this.defaultValues("trustedCerts"));
      /**
       * @type {Array.<Certificate>}
       * @desc Array with certificate chain. Could be only one end-user certificate in there!
       */

      this.certs = getParametersValue(parameters, "certs", this.defaultValues("certs"));
      /**
       * @type {Array.<CertificateRevocationList>}
       * @desc Array of all CRLs for all certificates from certificate chain
       */

      this.crls = getParametersValue(parameters, "crls", this.defaultValues("crls"));
      /**
       * @type {Array}
       * @desc Array of all OCSP responses
       */

      this.ocsps = getParametersValue(parameters, "ocsps", this.defaultValues("ocsps"));
      /**
       * @type {Date}
       * @desc The date at which the check would be
       */

      this.checkDate = getParametersValue(parameters, "checkDate", this.defaultValues("checkDate"));
      /**
       * @type { }
       * @desc The date at which the check would be
       */

      this.findOrigin = getParametersValue(parameters, "findOrigin", this.defaultValues("findOrigin"));
      /**
       * @type { }
       * @desc The date at which the check would be
       */

      this.findIssuer = getParametersValue(parameters, "findIssuer", this.defaultValues("findIssuer")); //endregion
    } //**********************************************************************************


    static defaultFindOrigin(certificate, validationEngine) {
      //region Firstly encode TBS for certificate
      if (certificate.tbs.byteLength === 0) certificate.tbs = certificate.encodeTBS(); //endregion
      //region Search in Intermediate Certificates

      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = validationEngine.certs[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var localCert = _step11.value;
          //region Firstly encode TBS for certificate
          if (localCert.tbs.byteLength === 0) localCert.tbs = localCert.encodeTBS(); //endregion

          if (isEqualBuffer(certificate.tbs, localCert.tbs)) return "Intermediate Certificates";
        } //endregion
        //region Search in Trusted Certificates

      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
            _iterator11.return();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = validationEngine.trustedCerts[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var trustedCert = _step12.value;
          //region Firstly encode TBS for certificate
          if (trustedCert.tbs.byteLength === 0) trustedCert.tbs = trustedCert.encodeTBS(); //endregion

          if (isEqualBuffer(certificate.tbs, trustedCert.tbs)) return "Trusted Certificates";
        } //endregion

      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      return "Unknown";
    } //**********************************************************************************


    defaultFindIssuer(certificate, validationEngine) {
      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(  _callee2() {
        var result, keyIdentifier, authorityCertIssuer, authorityCertSerialNumber, verificationResult, _iteratorNormalCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, extension, checkCertificate, _iteratorNormalCompletion15, _didIteratorError15, _iteratorError15, _iterator15, _step15, trustedCert, _iteratorNormalCompletion16, _didIteratorError16, _iteratorError16, _iterator16, _step16, intermediateCert, i, _verificationResult;

        return regeneratorRuntime.wrap(  _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                checkCertificate =   _ref(possibleIssuer) {
                  //region Firstly search for appropriate extensions
                  if (keyIdentifier !== null) {
                    if ("extensions" in possibleIssuer) {
                      var extensionFound = false;
                      var _iteratorNormalCompletion14 = true;
                      var _didIteratorError14 = false;
                      var _iteratorError14 = undefined;

                      try {
                        for (var _iterator14 = possibleIssuer.extensions[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                          var _extension = _step14.value;

                          if (_extension.extnID === "2.5.29.14") // SubjectKeyIdentifier
                            {
                              extensionFound = true;
                              if (isEqualBuffer(_extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHex)) result.push(possibleIssuer);
                              break;
                            }
                        }
                      } catch (err) {
                        _didIteratorError14 = true;
                        _iteratorError14 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
                            _iterator14.return();
                          }
                        } finally {
                          if (_didIteratorError14) {
                            throw _iteratorError14;
                          }
                        }
                      }

                      if (extensionFound) return;
                    }
                  } //endregion
                  //region Now search for authorityCertSerialNumber


                  var authorityCertSerialNumberEqual = false;
                  if (authorityCertSerialNumber !== null) authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber); //endregion
                  //region And at least search for Issuer data

                  if (authorityCertIssuer !== null) {
                    if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {
                      if (authorityCertSerialNumberEqual) result.push(possibleIssuer);
                    }
                  } else {
                    if (certificate.issuer.isEqual(possibleIssuer.subject)) result.push(possibleIssuer);
                  } //endregion

                };

                //region Initial variables
                result = [];
                keyIdentifier = null;
                authorityCertIssuer = null;
                authorityCertSerialNumber = null; //endregion
                //region Speed-up searching in case of self-signed certificates

                if (!certificate.subject.isEqual(certificate.issuer)) {
                  _context2.next = 16;
                  break;
                }

                _context2.prev = 6;
                _context2.next = 9;
                return certificate.verify();

              case 9:
                verificationResult = _context2.sent;

                if (!(verificationResult === true)) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", [certificate]);

              case 12:
                _context2.next = 16;
                break;

              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](6);

              case 16:
                if (!("extensions" in certificate)) {
                  _context2.next = 44;
                  break;
                }

                _iteratorNormalCompletion13 = true;
                _didIteratorError13 = false;
                _iteratorError13 = undefined;
                _context2.prev = 20;
                _iterator13 = certificate.extensions[Symbol.iterator]();

              case 22:
                if (_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done) {
                  _context2.next = 30;
                  break;
                }

                extension = _step13.value;

                if (!(extension.extnID === "2.5.29.35")) {
                  _context2.next = 27;
                  break;
                }

                if ("keyIdentifier" in extension.parsedValue) keyIdentifier = extension.parsedValue.keyIdentifier;else {
                  if ("authorityCertIssuer" in extension.parsedValue) authorityCertIssuer = extension.parsedValue.authorityCertIssuer;
                  if ("authorityCertSerialNumber" in extension.parsedValue) authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
                }
                return _context2.abrupt("break", 30);

              case 27:
                _iteratorNormalCompletion13 = true;
                _context2.next = 22;
                break;

              case 30:
                _context2.next = 36;
                break;

              case 32:
                _context2.prev = 32;
                _context2.t1 = _context2["catch"](20);
                _didIteratorError13 = true;
                _iteratorError13 = _context2.t1;

              case 36:
                _context2.prev = 36;
                _context2.prev = 37;

                if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
                  _iterator13.return();
                }

              case 39:
                _context2.prev = 39;

                if (!_didIteratorError13) {
                  _context2.next = 42;
                  break;
                }

                throw _iteratorError13;

              case 42:
                return _context2.finish(39);

              case 43:
                return _context2.finish(36);

              case 44:
                //endregion
                //region Search in Trusted Certificates
                _iteratorNormalCompletion15 = true;
                _didIteratorError15 = false;
                _iteratorError15 = undefined;
                _context2.prev = 47;

                for (_iterator15 = validationEngine.trustedCerts[Symbol.iterator](); !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                  trustedCert = _step15.value;
                  checkCertificate(trustedCert);
                } //endregion
                //region Search in Intermediate Certificates


                _context2.next = 55;
                break;

              case 51:
                _context2.prev = 51;
                _context2.t2 = _context2["catch"](47);
                _didIteratorError15 = true;
                _iteratorError15 = _context2.t2;

              case 55:
                _context2.prev = 55;
                _context2.prev = 56;

                if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
                  _iterator15.return();
                }

              case 58:
                _context2.prev = 58;

                if (!_didIteratorError15) {
                  _context2.next = 61;
                  break;
                }

                throw _iteratorError15;

              case 61:
                return _context2.finish(58);

              case 62:
                return _context2.finish(55);

              case 63:
                _iteratorNormalCompletion16 = true;
                _didIteratorError16 = false;
                _iteratorError16 = undefined;
                _context2.prev = 66;

                for (_iterator16 = validationEngine.certs[Symbol.iterator](); !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                  intermediateCert = _step16.value;
                  checkCertificate(intermediateCert);
                } //endregion
                //region Now perform certificate verification checking


                _context2.next = 74;
                break;

              case 70:
                _context2.prev = 70;
                _context2.t3 = _context2["catch"](66);
                _didIteratorError16 = true;
                _iteratorError16 = _context2.t3;

              case 74:
                _context2.prev = 74;
                _context2.prev = 75;

                if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
                  _iterator16.return();
                }

              case 77:
                _context2.prev = 77;

                if (!_didIteratorError16) {
                  _context2.next = 80;
                  break;
                }

                throw _iteratorError16;

              case 80:
                return _context2.finish(77);

              case 81:
                return _context2.finish(74);

              case 82:
                i = 0;

              case 83:
                if (!(i < result.length)) {
                  _context2.next = 97;
                  break;
                }

                _context2.prev = 84;
                _context2.next = 87;
                return certificate.verify(result[i]);

              case 87:
                _verificationResult = _context2.sent;
                if (_verificationResult === false) result.splice(i, 1);
                _context2.next = 94;
                break;

              case 91:
                _context2.prev = 91;
                _context2.t4 = _context2["catch"](84);
                result.splice(i, 1); // Something wrong, remove the certificate

              case 94:
                i++;
                _context2.next = 83;
                break;

              case 97:
                return _context2.abrupt("return", result);

              case 98:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[6, 14], [20, 32, 36, 44], [37,, 39, 43], [47, 51, 55, 63], [56,, 58, 62], [66, 70, 74, 82], [75,, 77, 81], [84, 91]]);
      }))();
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    defaultValues(memberName) {
      switch (memberName) {
        case "trustedCerts":
          return [];

        case "certs":
          return [];

        case "crls":
          return [];

        case "ocsps":
          return [];

        case "checkDate":
          return new Date();

        case "findOrigin":
          return CertificateChainValidationEngine.defaultFindOrigin;

        case "findIssuer":
          return this.defaultFindIssuer;

        default:
          throw new Error("Invalid member name for CertificateChainValidationEngine class: ".concat(memberName));
      }
    } //**********************************************************************************


    sort() {
      var _this3 = this,
          _arguments2 = arguments;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(  _callee8() {
        var passedWhenNotRevValues, localCerts, _this, buildPath, _buildPath, findCRL, _findCRL, findOCSP, _findOCSP, checkForCA, _checkForCA, basicCheck, _basicCheck, i, j, result, certificatePath, _i34, found, _j3, certificate, k, shortestLength, shortestIndex, _i35, _i36;

        return regeneratorRuntime.wrap(  _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _basicCheck =   _ref12() {
                  _basicCheck = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(  _callee7(path, checkDate) {
                    var _i41, _i42, _i43, ocspResult, crlResult, _j8, isCertificateRevoked, isCertificateCA, issuerCertificate, extensionFound, _iteratorNormalCompletion17, _didIteratorError17, _iteratorError17, _iterator17, _step17, extension, _i44, _result8;

                    return regeneratorRuntime.wrap(  _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            _i41 = 0;

                          case 1:
                            if (!(_i41 < path.length)) {
                              _context7.next = 7;
                              break;
                            }

                            if (!(path[_i41].notBefore.value > checkDate || path[_i41].notAfter.value < checkDate)) {
                              _context7.next = 4;
                              break;
                            }

                            return _context7.abrupt("return", {
                              result: false,
                              resultCode: 8,
                              resultMessage: "The certificate is either not yet valid or expired"
                            });

                          case 4:
                            _i41++;
                            _context7.next = 1;
                            break;

                          case 7:
                            if (!(path.length < 2)) {
                              _context7.next = 9;
                              break;
                            }

                            return _context7.abrupt("return", {
                              result: false,
                              resultCode: 9,
                              resultMessage: "Too short certificate path"
                            });

                          case 9:
                            _i42 = path.length - 2;

                          case 10:
                            if (!(_i42 >= 0)) {
                              _context7.next = 17;
                              break;
                            }

                            if (!(path[_i42].issuer.isEqual(path[_i42].subject) === false)) {
                              _context7.next = 14;
                              break;
                            }

                            if (!(path[_i42].issuer.isEqual(path[_i42 + 1].subject) === false)) {
                              _context7.next = 14;
                              break;
                            }

                            return _context7.abrupt("return", {
                              result: false,
                              resultCode: 10,
                              resultMessage: "Incorrect name chaining"
                            });

                          case 14:
                            _i42--;
                            _context7.next = 10;
                            break;

                          case 17:
                            if (!(_this.crls.length !== 0 || _this.ocsps.length !== 0)) {
                              _context7.next = 96;
                              break;
                            }

                            _i43 = 0;

                          case 19:
                            if (!(_i43 < path.length - 1)) {
                              _context7.next = 96;
                              break;
                            }

                            //region Initial variables
                            ocspResult = 2;
                            crlResult = {
                              status: 0,
                              statusMessage: ""
                            }; //endregion
                            //region Check OCSPs first

                            if (!(_this.ocsps.length !== 0)) {
                              _context7.next = 32;
                              break;
                            }

                            _context7.next = 25;
                            return findOCSP(path[_i43], path[_i43 + 1]);

                          case 25:
                            ocspResult = _context7.sent;
                            _context7.t0 = ocspResult;
                            _context7.next = _context7.t0 === 0 ? 29 : _context7.t0 === 1 ? 30 : _context7.t0 === 2 ? 31 : 32;
                            break;

                          case 29:
                            return _context7.abrupt("continue", 93);

                          case 30:
                            return _context7.abrupt("return", {
                              result: false,
                              resultCode: 12,
                              resultMessage: "One of certificates was revoked via OCSP response"
                            });

                          case 31:
                            return _context7.abrupt("break", 32);

                          case 32:
                            if (!(_this.crls.length !== 0)) {
                              _context7.next = 56;
                              break;
                            }

                            _context7.next = 35;
                            return findCRL(path[_i43]);

                          case 35:
                            crlResult = _context7.sent;

                            if (!(crlResult.status === 0)) {
                              _context7.next = 52;
                              break;
                            }

                            _j8 = 0;

                          case 38:
                            if (!(_j8 < crlResult.result.length)) {
                              _context7.next = 50;
                              break;
                            }

                            //region Check that the CRL issuer certificate have not been revoked
                            isCertificateRevoked = crlResult.result[_j8].crl.isCertificateRevoked(path[_i43]);

                            if (!isCertificateRevoked) {
                              _context7.next = 42;
                              break;
                            }

                            return _context7.abrupt("return", {
                              result: false,
                              resultCode: 12,
                              resultMessage: "One of certificates had been revoked"
                            });

                          case 42:
                            _context7.next = 44;
                            return checkForCA(crlResult.result[_j8].certificate, true);

                          case 44:
                            isCertificateCA = _context7.sent;

                            if (!(isCertificateCA.result === false)) {
                              _context7.next = 47;
                              break;
                            }

                            return _context7.abrupt("return", {
                              result: false,
                              resultCode: 13,
                              resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
                            });

                          case 47:
                            _j8++;
                            _context7.next = 38;
                            break;

                          case 50:
                            _context7.next = 54;
                            break;

                          case 52:
                            if (!(passedWhenNotRevValues === false)) {
                              _context7.next = 54;
                              break;
                            }

                            throw {
                              result: false,
                              resultCode: 11,
                              resultMessage: "No revocation values found for one of certificates: ".concat(crlResult.statusMessage)
                            };

                          case 54:
                            _context7.next = 58;
                            break;

                          case 56:
                            if (!(ocspResult === 2)) {
                              _context7.next = 58;
                              break;
                            }

                            return _context7.abrupt("return", {
                              result: false,
                              resultCode: 11,
                              resultMessage: "No revocation values found for one of certificates"
                            });

                          case 58:
                            if (!(ocspResult === 2 && crlResult.status === 2 && passedWhenNotRevValues)) {
                              _context7.next = 93;
                              break;
                            }

                            issuerCertificate = path[_i43 + 1];
                            extensionFound = false;

                            if (!("extensions" in issuerCertificate)) {
                              _context7.next = 91;
                              break;
                            }

                            _iteratorNormalCompletion17 = true;
                            _didIteratorError17 = false;
                            _iteratorError17 = undefined;
                            _context7.prev = 65;
                            _iterator17 = issuerCertificate.extensions[Symbol.iterator]();

                          case 67:
                            if (_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done) {
                              _context7.next = 77;
                              break;
                            }

                            extension = _step17.value;
                            _context7.t1 = extension.extnID;
                            _context7.next = _context7.t1 === "2.5.29.31" ? 72 : _context7.t1 === "2.5.29.46" ? 72 : _context7.t1 === "1.3.6.1.5.5.7.1.1" ? 72 : 74;
                            break;

                          case 72:
                            // AuthorityInfoAccess
                            extensionFound = true;
                            return _context7.abrupt("break", 74);

                          case 74:
                            _iteratorNormalCompletion17 = true;
                            _context7.next = 67;
                            break;

                          case 77:
                            _context7.next = 83;
                            break;

                          case 79:
                            _context7.prev = 79;
                            _context7.t2 = _context7["catch"](65);
                            _didIteratorError17 = true;
                            _iteratorError17 = _context7.t2;

                          case 83:
                            _context7.prev = 83;
                            _context7.prev = 84;

                            if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
                              _iterator17.return();
                            }

                          case 86:
                            _context7.prev = 86;

                            if (!_didIteratorError17) {
                              _context7.next = 89;
                              break;
                            }

                            throw _iteratorError17;

                          case 89:
                            return _context7.finish(86);

                          case 90:
                            return _context7.finish(83);

                          case 91:
                            if (!extensionFound) {
                              _context7.next = 93;
                              break;
                            }

                            throw {
                              result: false,
                              resultCode: 11,
                              resultMessage: "No revocation values found for one of certificates: ".concat(crlResult.statusMessage)
                            };

                          case 93:
                            _i43++;
                            _context7.next = 19;
                            break;

                          case 96:
                            _i44 = 1;

                          case 97:
                            if (!(_i44 < path.length)) {
                              _context7.next = 106;
                              break;
                            }

                            _context7.next = 100;
                            return checkForCA(path[_i44]);

                          case 100:
                            _result8 = _context7.sent;

                            if (!(_result8.result === false)) {
                              _context7.next = 103;
                              break;
                            }

                            return _context7.abrupt("return", {
                              result: false,
                              resultCode: 14,
                              resultMessage: "One of intermediate certificates is not a CA certificate"
                            });

                          case 103:
                            _i44++;
                            _context7.next = 97;
                            break;

                          case 106:
                            return _context7.abrupt("return", {
                              result: true
                            });

                          case 107:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7, null, [[65, 79, 83, 91], [84,, 86, 90]]);
                  }));
                  return _basicCheck.apply(this, arguments);
                };

                basicCheck =   _ref11(_x6, _x7) {
                  return _basicCheck.apply(this, arguments);
                };

                _checkForCA =   _ref10() {
                  _checkForCA = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(  _callee6(certificate) {
                    var needToCheckCRL,
                        isCA,
                        mustBeCA,
                        keyUsagePresent,
                        cRLSign,
                        _j7,
                        view,
                        _args6 = arguments;

                    return regeneratorRuntime.wrap(  _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            needToCheckCRL = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : false;
                            //region Initial variables
                            isCA = false;
                            mustBeCA = false;
                            keyUsagePresent = false;
                            cRLSign = false; //endregion

                            if (!("extensions" in certificate)) {
                              _context6.next = 21;
                              break;
                            }

                            _j7 = 0;

                          case 7:
                            if (!(_j7 < certificate.extensions.length)) {
                              _context6.next = 15;
                              break;
                            }

                            if (!(certificate.extensions[_j7].critical === true && "parsedValue" in certificate.extensions[_j7] === false)) {
                              _context6.next = 10;
                              break;
                            }

                            return _context6.abrupt("return", {
                              result: false,
                              resultCode: 6,
                              resultMessage: "Unable to parse critical certificate extension: ".concat(certificate.extensions[_j7].extnID)
                            });

                          case 10:
                            if (certificate.extensions[_j7].extnID === "2.5.29.15") // KeyUsage
                              {
                                keyUsagePresent = true;
                                view = new Uint8Array(certificate.extensions[_j7].parsedValue.valueBlock.valueHex);
                                if ((view[0] & 0x04) === 0x04) // Set flag "keyCertSign"
                                  mustBeCA = true;
                                if ((view[0] & 0x02) === 0x02) // Set flag "cRLSign"
                                  cRLSign = true;
                              }

                            if (certificate.extensions[_j7].extnID === "2.5.29.19") // BasicConstraints
                              {
                                if ("cA" in certificate.extensions[_j7].parsedValue) {
                                  if (certificate.extensions[_j7].parsedValue.cA === true) isCA = true;
                                }
                              }

                          case 12:
                            _j7++;
                            _context6.next = 7;
                            break;

                          case 15:
                            if (!(mustBeCA === true && isCA === false)) {
                              _context6.next = 17;
                              break;
                            }

                            return _context6.abrupt("return", {
                              result: false,
                              resultCode: 3,
                              resultMessage: "Unable to build certificate chain - using \"keyCertSign\" flag set without BasicConstaints"
                            });

                          case 17:
                            if (!(keyUsagePresent === true && isCA === true && mustBeCA === false)) {
                              _context6.next = 19;
                              break;
                            }

                            return _context6.abrupt("return", {
                              result: false,
                              resultCode: 4,
                              resultMessage: "Unable to build certificate chain - \"keyCertSign\" flag was not set"
                            });

                          case 19:
                            if (!(isCA === true && keyUsagePresent === true && needToCheckCRL && cRLSign === false)) {
                              _context6.next = 21;
                              break;
                            }

                            return _context6.abrupt("return", {
                              result: false,
                              resultCode: 5,
                              resultMessage: "Unable to build certificate chain - intermediate certificate must have \"cRLSign\" key usage flag"
                            });

                          case 21:
                            if (!(isCA === false)) {
                              _context6.next = 23;
                              break;
                            }

                            return _context6.abrupt("return", {
                              result: false,
                              resultCode: 7,
                              resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
                            });

                          case 23:
                            return _context6.abrupt("return", {
                              result: true,
                              resultCode: 0,
                              resultMessage: ""
                            });

                          case 24:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));
                  return _checkForCA.apply(this, arguments);
                };

                checkForCA =   _ref9(_x5) {
                  return _checkForCA.apply(this, arguments);
                };

                _findOCSP =   _ref8() {
                  _findOCSP = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(  _callee5(certificate, issuerCertificate) {
                    var hashAlgorithm, _i40, _result7;

                    return regeneratorRuntime.wrap(  _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            //region Get hash algorithm from certificate
                            hashAlgorithm = getAlgorithmByOID(certificate.signatureAlgorithm.algorithmId);

                            if (!("name" in hashAlgorithm === false)) {
                              _context5.next = 3;
                              break;
                            }

                            return _context5.abrupt("return", 1);

                          case 3:
                            if (!("hash" in hashAlgorithm === false)) {
                              _context5.next = 5;
                              break;
                            }

                            return _context5.abrupt("return", 1);

                          case 5:
                            _i40 = 0;

                          case 6:
                            if (!(_i40 < _this.ocsps.length)) {
                              _context5.next = 17;
                              break;
                            }

                            _context5.next = 9;
                            return _this.ocsps[_i40].getCertificateStatus(certificate, issuerCertificate);

                          case 9:
                            _result7 = _context5.sent;

                            if (!_result7.isForCertificate) {
                              _context5.next = 14;
                              break;
                            }

                            if (!(_result7.status === 0)) {
                              _context5.next = 13;
                              break;
                            }

                            return _context5.abrupt("return", 0);

                          case 13:
                            return _context5.abrupt("return", 1);

                          case 14:
                            _i40++;
                            _context5.next = 6;
                            break;

                          case 17:
                            return _context5.abrupt("return", 2);

                          case 18:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));
                  return _findOCSP.apply(this, arguments);
                };

                findOCSP =   _ref7(_x3, _x4) {
                  return _findOCSP.apply(this, arguments);
                };

                _findCRL =   _ref6() {
                  _findCRL = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(  _callee4(certificate) {
                    var issuerCertificates, crls, crlsAndCertificates, _i39, _j6, _result6;

                    return regeneratorRuntime.wrap(  _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            //region Initial variables
                            issuerCertificates = [];
                            crls = [];
                            crlsAndCertificates = []; //endregion
                            //region Find all possible CRL issuers

                            issuerCertificates.push(...localCerts.filter(element => certificate.issuer.isEqual(element.subject)));

                            if (!(issuerCertificates.length === 0)) {
                              _context4.next = 6;
                              break;
                            }

                            return _context4.abrupt("return", {
                              status: 1,
                              statusMessage: "No certificate's issuers"
                            });

                          case 6:
                            //endregion
                            //region Find all CRLs for certificate's issuer
                            crls.push(..._this.crls.filter(element => element.issuer.isEqual(certificate.issuer)));

                            if (!(crls.length === 0)) {
                              _context4.next = 9;
                              break;
                            }

                            return _context4.abrupt("return", {
                              status: 2,
                              statusMessage: "No CRLs for specific certificate issuer"
                            });

                          case 9:
                            _i39 = 0;

                          case 10:
                            if (!(_i39 < crls.length)) {
                              _context4.next = 32;
                              break;
                            }

                            if (!(crls[_i39].nextUpdate.value < _this.checkDate)) {
                              _context4.next = 13;
                              break;
                            }

                            return _context4.abrupt("continue", 29);

                          case 13:
                            _j6 = 0;

                          case 14:
                            if (!(_j6 < issuerCertificates.length)) {
                              _context4.next = 29;
                              break;
                            }

                            _context4.prev = 15;
                            _context4.next = 18;
                            return crls[_i39].verify({
                              issuerCertificate: issuerCertificates[_j6]
                            });

                          case 18:
                            _result6 = _context4.sent;

                            if (!_result6) {
                              _context4.next = 22;
                              break;
                            }

                            crlsAndCertificates.push({
                              crl: crls[_i39],
                              certificate: issuerCertificates[_j6]
                            });
                            return _context4.abrupt("break", 29);

                          case 22:
                            _context4.next = 26;
                            break;

                          case 24:
                            _context4.prev = 24;
                            _context4.t0 = _context4["catch"](15);

                          case 26:
                            _j6++;
                            _context4.next = 14;
                            break;

                          case 29:
                            _i39++;
                            _context4.next = 10;
                            break;

                          case 32:
                            if (!crlsAndCertificates.length) {
                              _context4.next = 34;
                              break;
                            }

                            return _context4.abrupt("return", {
                              status: 0,
                              statusMessage: "",
                              result: crlsAndCertificates
                            });

                          case 34:
                            return _context4.abrupt("return", {
                              status: 3,
                              statusMessage: "No valid CRLs found"
                            });

                          case 35:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, null, [[15, 24]]);
                  }));
                  return _findCRL.apply(this, arguments);
                };

                findCRL =   _ref5(_x2) {
                  return _findCRL.apply(this, arguments);
                };

                _buildPath =   _ref4() {
                  _buildPath = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(  _callee3(certificate) {
                    var result, checkUnique, findIssuerResult, _i38, buildPathResult, _j5, copy;

                    return regeneratorRuntime.wrap(  _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            checkUnique =   _ref2(array) {
                              var unique = true;

                              for (var _i37 = 0; _i37 < array.length; _i37++) {
                                for (var _j4 = 0; _j4 < array.length; _j4++) {
                                  if (_j4 === _i37) continue;

                                  if (array[_i37] === array[_j4]) {
                                    unique = false;
                                    break;
                                  }
                                }

                                if (!unique) break;
                              }

                              return unique;
                            };

                            result = []; //region Aux   checking array for unique elements

                            _context3.next = 4;
                            return _this.findIssuer(certificate, _this);

                          case 4:
                            findIssuerResult = _context3.sent;

                            if (!(findIssuerResult.length === 0)) {
                              _context3.next = 7;
                              break;
                            }

                            throw new Error("No valid certificate paths found");

                          case 7:
                            _i38 = 0;

                          case 8:
                            if (!(_i38 < findIssuerResult.length)) {
                              _context3.next = 19;
                              break;
                            }

                            if (!isEqualBuffer(findIssuerResult[_i38].tbs, certificate.tbs)) {
                              _context3.next = 12;
                              break;
                            }

                            result.push([findIssuerResult[_i38]]);
                            return _context3.abrupt("continue", 16);

                          case 12:
                            _context3.next = 14;
                            return buildPath(findIssuerResult[_i38]);

                          case 14:
                            buildPathResult = _context3.sent;

                            for (_j5 = 0; _j5 < buildPathResult.length; _j5++) {
                              copy = buildPathResult[_j5].slice();
                              copy.splice(0, 0, findIssuerResult[_i38]);
                              if (checkUnique(copy)) result.push(copy);else result.push(buildPathResult[_j5]);
                            }

                          case 16:
                            _i38++;
                            _context3.next = 8;
                            break;

                          case 19:
                            return _context3.abrupt("return", result);

                          case 20:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));
                  return _buildPath.apply(this, arguments);
                };

                buildPath =   _ref3(_x) {
                  return _buildPath.apply(this, arguments);
                };

                passedWhenNotRevValues = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : false;
                //region Initial variables
                localCerts = [];
                _this = _this3; //endregion
                //region Building certificate path

                //endregion
                //region Do main work
                //region Initialize "localCerts" by value of "_this.certs" + "_this.trustedCerts" arrays
                localCerts.push(..._this.trustedCerts);
                localCerts.push(..._this.certs); //endregion
                //region Check all certificates for been unique

                i = 0;

              case 16:
                if (!(i < localCerts.length)) {
                  _context8.next = 31;
                  break;
                }

                j = 0;

              case 18:
                if (!(j < localCerts.length)) {
                  _context8.next = 28;
                  break;
                }

                if (!(i === j)) {
                  _context8.next = 21;
                  break;
                }

                return _context8.abrupt("continue", 25);

              case 21:
                if (!isEqualBuffer(localCerts[i].tbs, localCerts[j].tbs)) {
                  _context8.next = 25;
                  break;
                }

                localCerts.splice(j, 1);
                i = 0;
                return _context8.abrupt("break", 28);

              case 25:
                j++;
                _context8.next = 18;
                break;

              case 28:
                i++;
                _context8.next = 16;
                break;

              case 31:
                certificatePath = [localCerts[localCerts.length - 1]]; // The "end entity" certificate must be the least in "certs" array
                //endregion
                //region Build path for "end entity" certificate

                _context8.next = 34;
                return buildPath(localCerts[localCerts.length - 1]);

              case 34:
                result = _context8.sent;

                if (!(result.length === 0)) {
                  _context8.next = 37;
                  break;
                }

                return _context8.abrupt("return", {
                  result: false,
                  resultCode: 60,
                  resultMessage: "Unable to find certificate path"
                });

              case 37:
                _i34 = 0;

              case 38:
                if (!(_i34 < result.length)) {
                  _context8.next = 60;
                  break;
                }

                found = false;
                _j3 = 0;

              case 41:
                if (!(_j3 < result[_i34].length)) {
                  _context8.next = 56;
                  break;
                }

                certificate = result[_i34][_j3];
                k = 0;

              case 44:
                if (!(k < _this.trustedCerts.length)) {
                  _context8.next = 51;
                  break;
                }

                if (!isEqualBuffer(certificate.tbs, _this.trustedCerts[k].tbs)) {
                  _context8.next = 48;
                  break;
                }

                found = true;
                return _context8.abrupt("break", 51);

              case 48:
                k++;
                _context8.next = 44;
                break;

              case 51:
                if (!found) {
                  _context8.next = 53;
                  break;
                }

                return _context8.abrupt("break", 56);

              case 53:
                _j3++;
                _context8.next = 41;
                break;

              case 56:
                if (!found) {
                  result.splice(_i34, 1);
                  _i34 = 0;
                }

              case 57:
                _i34++;
                _context8.next = 38;
                break;

              case 60:
                if (!(result.length === 0)) {
                  _context8.next = 62;
                  break;
                }

                throw {
                  result: false,
                  resultCode: 97,
                  resultMessage: "No valid certificate paths found"
                };

              case 62:
                //endregion
                //region Find shortest certificate path (for the moment it is the only criteria)
                shortestLength = result[0].length;
                shortestIndex = 0;

                for (_i35 = 0; _i35 < result.length; _i35++) {
                  if (result[_i35].length < shortestLength) {
                    shortestLength = result[_i35].length;
                    shortestIndex = _i35;
                  }
                } //endregion
                //region Create certificate path for basic check


                for (_i36 = 0; _i36 < result[shortestIndex].length; _i36++) {
                  certificatePath.push(result[shortestIndex][_i36]);
                } //endregion
                //region Perform basic checking for all certificates in the path


                _context8.next = 68;
                return basicCheck(certificatePath, _this.checkDate);

              case 68:
                result = _context8.sent;

                if (!(result.result === false)) {
                  _context8.next = 71;
                  break;
                }

                throw result;

              case 71:
                return _context8.abrupt("return", certificatePath);

              case 72:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }))();
    } //**********************************************************************************

    /**
     * Major verification   for certificate chain.
     * @param {{initialPolicySet, initialExplicitPolicy, initialPolicyMappingInhibit, initialInhibitPolicy, initialPermittedSubtreesSet, initialExcludedSubtreesSet, initialRequiredNameForms}} [parameters]
     * @returns {Promise}
     */


    verify() {
      var _this4 = this,
          _arguments3 = arguments;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(  _callee9() {
        var parameters, compareDNSName, compareRFC822Name, compareUniformResourceIdentifier, compareIPAddress, compareDirectoryName, passedWhenNotRevValues, initialPolicySet, initialExplicitPolicy, initialPolicyMappingInhibit, initialInhibitPolicy, initialPermittedSubtreesSet, initialExcludedSubtreesSet, initialRequiredNameForms, explicitPolicyIndicator, policyMappingInhibitIndicator, inhibitAnyPolicyIndicator, pendingConstraints, explicitPolicyPending, policyMappingInhibitPending, inhibitAnyPolicyPending, permittedSubtrees, excludedSubtrees, requiredNameForms, pathDepth, allPolicies, policiesAndCerts, anyPolicyArray, ii, policyMappings, certPolicies, explicitPolicyStart, i, j, s, k, policyIndex, _s2, certArray, _policyIndex, searchAnyPolicy, _i48, _k, issuerDomainPolicyIndex, subjectDomainPolicyIndex, n, _j9, m, _i49, _j10, authConstrPolicies, _i50, found, _j11, anyPolicyFound, _k2, userConstrPolicies, _i51, _j12, policyResult, _i52, subjectAltNames, certPermittedSubtrees, certExcludedSubtrees, _j13, formFound, _j14, _k3, constrGroups, _j15, p, groupPermitted, valueExists, group, _j16, _k4, _k5, _k6, _k7, _k8, excluded, _j17, _k9, _k10, _k11, _k12, _k13;

        return regeneratorRuntime.wrap(  _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                compareDirectoryName =   _ref17(name, constraint) {
                  /// <summary>Compare two directoryName values</summary>
                  /// <param name="name" type="in_window.org.pkijs.simpl.RDN">directoryName from name</param>
                  /// <param name="constraint" type="in_window.org.pkijs.simpl.RDN">Constraint for directoryName from name</param>
                  /// <param name="any" type="Boolean">Boolean flag - should be comparision interrupted after first match or we need to match all "constraints" parts</param>
                  /// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
                  //region Initial check
                  if (name.typesAndValues.length === 0 || constraint.typesAndValues.length === 0) return true;
                  if (name.typesAndValues.length < constraint.typesAndValues.length) return false; //endregion
                  //region Initial variables

                  var result = true;
                  var nameStart = 0; //endregion

                  for (var i = 0; i < constraint.typesAndValues.length; i++) {
                    var localResult = false;

                    for (var j = nameStart; j < name.typesAndValues.length; j++) {
                      localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i]);
                      if (name.typesAndValues[j].type === constraint.typesAndValues[i].type) result = result && localResult;

                      if (localResult === true) {
                        if (nameStart === 0 || nameStart === j) {
                          nameStart = j + 1;
                          break;
                        } else // Structure of "name" must be the same with "constraint"
                          return false;
                      }
                    }

                    if (localResult === false) return false;
                  }

                  return nameStart === 0 ? false : result;
                };

                compareIPAddress =   _ref16(name, constraint) {
                  /// <summary>Compare two iPAddress values</summary>
                  /// <param name="name" type="in_window.org.pkijs.asn1.OCTETSTRING">iPAddress from name</param>
                  /// <param name="constraint" type="in_window.org.pkijs.asn1.OCTETSTRING">Constraint for iPAddress from name</param>
                  /// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
                  //region Common variables
                  var nameView = new Uint8Array(name.valueBlock.valueHex);
                  var constraintView = new Uint8Array(constraint.valueBlock.valueHex); //endregion
                  //region Work with IPv4 addresses

                  if (nameView.length === 4 && constraintView.length === 8) {
                    for (var i = 0; i < 4; i++) {
                      if ((nameView[i] ^ constraintView[i]) & constraintView[i + 4]) return false;
                    }

                    return true;
                  } //endregion
                  //region Work with IPv6 addresses


                  if (nameView.length === 16 && constraintView.length === 32) {
                    for (var _i47 = 0; _i47 < 16; _i47++) {
                      if ((nameView[_i47] ^ constraintView[_i47]) & constraintView[_i47 + 16]) return false;
                    }

                    return true;
                  } //endregion


                  return false;
                };

                compareUniformResourceIdentifier =   _ref15(name, constraint) {
                  /// <summary>Compare two uniformResourceIdentifier values</summary>
                  /// <param name="name" type="String">uniformResourceIdentifier from name</param>
                  /// <param name="constraint" type="String">Constraint for uniformResourceIdentifier from name</param>
                  /// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
                  //region Make a "string preparation" for both name and constrain
                  var namePrepared = stringPrep(name);
                  var constraintPrepared = stringPrep(constraint); //endregion
                  //region Find out a major URI part to compare with

                  var ns = namePrepared.split("/");
                  var cs = constraintPrepared.split("/");
                  if (cs.length > 1) // Malformed constraint
                    return false;

                  if (ns.length > 1) // Full URI string
                    {
                      for (var i = 0; i < ns.length; i++) {
                        if (ns[i].length > 0 && ns[i].charAt(ns[i].length - 1) !== ":") {
                          var nsPort = ns[i].split(":");
                          namePrepared = nsPort[0];
                          break;
                        }
                      }
                    } //endregion


                  var result = compareDNSName(namePrepared, constraintPrepared);

                  if (result) {
                    //region Make a "splitted" versions of "constraint" and "name"
                    var nameSplitted = namePrepared.split(".");
                    var constraintSplitted = constraintPrepared.split("."); //endregion

                    if (constraintSplitted[0].length === 0) return true;
                    return nameSplitted.length === constraintSplitted.length;
                  }

                  return false;
                };

                compareRFC822Name =   _ref14(name, constraint) {
                  /// <summary>Compare two rfc822Name values</summary>
                  /// <param name="name" type="String">E-mail address from name</param>
                  /// <param name="constraint" type="String">Constraint for e-mail address from name</param>
                  /// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
                  //region Make a "string preparation" for both name and constrain
                  var namePrepared = stringPrep(name);
                  var constraintPrepared = stringPrep(constraint); //endregion
                  //region Make a "splitted" versions of "constraint" and "name"

                  var nameSplitted = namePrepared.split("@");
                  var constraintSplitted = constraintPrepared.split("@"); //endregion
                  //region Splitted array length checking

                  if (nameSplitted.length === 0 || constraintSplitted.length === 0 || nameSplitted.length < constraintSplitted.length) return false; //endregion

                  if (constraintSplitted.length === 1) {
                    var result = compareDNSName(nameSplitted[1], constraintSplitted[0]);

                    if (result) {
                      //region Make a "splitted" versions of domain name from "constraint" and "name"
                      var ns = nameSplitted[1].split(".");
                      var cs = constraintSplitted[0].split("."); //endregion

                      if (cs[0].length === 0) return true;
                      return ns.length === cs.length;
                    }

                    return false;
                  }

                  return namePrepared.localeCompare(constraintPrepared) === 0;
                };

                compareDNSName =   _ref13(name, constraint) {
                  /// <summary>Compare two dNSName values</summary>
                  /// <param name="name" type="String">DNS from name</param>
                  /// <param name="constraint" type="String">Constraint for DNS from name</param>
                  /// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
                  //region Make a "string preparation" for both name and constrain
                  var namePrepared = stringPrep(name);
                  var constraintPrepared = stringPrep(constraint); //endregion
                  //region Make a "splitted" versions of "constraint" and "name"

                  var nameSplitted = namePrepared.split(".");
                  var constraintSplitted = constraintPrepared.split("."); //endregion
                  //region Length calculation and additional check

                  var nameLen = nameSplitted.length;
                  var constrLen = constraintSplitted.length;
                  if (nameLen === 0 || constrLen === 0 || nameLen < constrLen) return false; //endregion
                  //region Check that no part of "name" has zero length

                  for (var i = 0; i < nameLen; i++) {
                    if (nameSplitted[i].length === 0) return false;
                  } //endregion
                  //region Check that no part of "constraint" has zero length


                  for (var _i45 = 0; _i45 < constrLen; _i45++) {
                    if (constraintSplitted[_i45].length === 0) {
                      if (_i45 === 0) {
                        if (constrLen === 1) return false;
                        continue;
                      }

                      return false;
                    }
                  } //endregion
                  //region Check that "name" has a tail as "constraint"


                  for (var _i46 = 0; _i46 < constrLen; _i46++) {
                    if (constraintSplitted[constrLen - 1 - _i46].length === 0) continue;
                    if (nameSplitted[nameLen - 1 - _i46].localeCompare(constraintSplitted[constrLen - 1 - _i46]) !== 0) return false;
                  } //endregion


                  return true;
                };

                parameters = _arguments3.length > 0 && _arguments3[0] !== undefined ? _arguments3[0] : {};
                _context9.prev = 6;

                if (!(_this4.certs.length === 0)) {
                  _context9.next = 9;
                  break;
                }

                throw "Empty certificate array";

              case 9:
                //endregion
                //region Get input variables
                passedWhenNotRevValues = false;
                if ("passedWhenNotRevValues" in parameters) passedWhenNotRevValues = parameters.passedWhenNotRevValues;
                initialPolicySet = [];
                initialPolicySet.push("2.5.29.32.0"); // "anyPolicy"

                initialExplicitPolicy = false;
                initialPolicyMappingInhibit = false;
                initialInhibitPolicy = false;
                initialPermittedSubtreesSet = []; // Array of "simpl.x509.GeneralSubtree"

                initialExcludedSubtreesSet = []; // Array of "simpl.x509.GeneralSubtree"

                initialRequiredNameForms = []; // Array of "simpl.x509.GeneralSubtree"

                if ("initialPolicySet" in parameters) initialPolicySet = parameters.initialPolicySet;
                if ("initialExplicitPolicy" in parameters) initialExplicitPolicy = parameters.initialExplicitPolicy;
                if ("initialPolicyMappingInhibit" in parameters) initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit;
                if ("initialInhibitPolicy" in parameters) initialInhibitPolicy = parameters.initialInhibitPolicy;
                if ("initialPermittedSubtreesSet" in parameters) initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet;
                if ("initialExcludedSubtreesSet" in parameters) initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet;
                if ("initialRequiredNameForms" in parameters) initialRequiredNameForms = parameters.initialRequiredNameForms;
                explicitPolicyIndicator = initialExplicitPolicy;
                policyMappingInhibitIndicator = initialPolicyMappingInhibit;
                inhibitAnyPolicyIndicator = initialInhibitPolicy;
                pendingConstraints = new Array(3);
                pendingConstraints[0] = false; // For "explicitPolicyPending"

                pendingConstraints[1] = false; // For "policyMappingInhibitPending"

                pendingConstraints[2] = false; // For "inhibitAnyPolicyPending"

                explicitPolicyPending = 0;
                policyMappingInhibitPending = 0;
                inhibitAnyPolicyPending = 0;
                permittedSubtrees = initialPermittedSubtreesSet;
                excludedSubtrees = initialExcludedSubtreesSet;
                requiredNameForms = initialRequiredNameForms;
                pathDepth = 1; //endregion
                //region Sorting certificates in the chain array

                _context9.next = 42;
                return _this4.sort(passedWhenNotRevValues);

              case 42:
                _this4.certs = _context9.sent;
                //endregion
                //region Work with policies
                //region Support variables
                allPolicies = []; // Array of all policies (string values)

                allPolicies.push("2.5.29.32.0"); // Put "anyPolicy" at first place

                policiesAndCerts = []; // In fact "array of array" where rows are for each specific policy, column for each certificate and value is "true/false"

                anyPolicyArray = new Array(_this4.certs.length - 1); // Minus "trusted anchor"

                for (ii = 0; ii < _this4.certs.length - 1; ii++) {
                  anyPolicyArray[ii] = true;
                }

                policiesAndCerts.push(anyPolicyArray);
                policyMappings = new Array(_this4.certs.length - 1); // Array of "PolicyMappings" for each certificate

                certPolicies = new Array(_this4.certs.length - 1); // Array of "CertificatePolicies" for each certificate

                explicitPolicyStart = explicitPolicyIndicator ? _this4.certs.length - 1 : -1; //endregion
                //region Gather all neccessary information from certificate chain

                i = _this4.certs.length - 2;

              case 53:
                if (!(i >= 0)) {
                  _context9.next = 108;
                  break;
                }

                if (!("extensions" in _this4.certs[i])) {
                  _context9.next = 105;
                  break;
                }

                j = 0;

              case 56:
                if (!(j < _this4.certs[i].extensions.length)) {
                  _context9.next = 91;
                  break;
                }

                if (!(_this4.certs[i].extensions[j].extnID === "2.5.29.32")) {
                  _context9.next = 82;
                  break;
                }

                certPolicies[i] = _this4.certs[i].extensions[j].parsedValue; //region Remove entry from "anyPolicies" for the certificate

                s = 0;

              case 60:
                if (!(s < allPolicies.length)) {
                  _context9.next = 67;
                  break;
                }

                if (!(allPolicies[s] === "2.5.29.32.0")) {
                  _context9.next = 64;
                  break;
                }

                delete policiesAndCerts[s][i];
                return _context9.abrupt("break", 67);

              case 64:
                s++;
                _context9.next = 60;
                break;

              case 67:
                k = 0;

              case 68:
                if (!(k < _this4.certs[i].extensions[j].parsedValue.certificatePolicies.length)) {
                  _context9.next = 82;
                  break;
                }

                policyIndex = -1; //region Try to find extension in "allPolicies" array

                _s2 = 0;

              case 71:
                if (!(_s2 < allPolicies.length)) {
                  _context9.next = 78;
                  break;
                }

                if (!(_this4.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier === allPolicies[_s2])) {
                  _context9.next = 75;
                  break;
                }

                policyIndex = _s2;
                return _context9.abrupt("break", 78);

              case 75:
                _s2++;
                _context9.next = 71;
                break;

              case 78:
                //endregion
                if (policyIndex === -1) {
                  allPolicies.push(_this4.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier);
                  certArray = new Array(_this4.certs.length - 1);
                  certArray[i] = true;
                  policiesAndCerts.push(certArray);
                } else policiesAndCerts[policyIndex][i] = true;

              case 79:
                k++;
                _context9.next = 68;
                break;

              case 82:
                if (!(_this4.certs[i].extensions[j].extnID === "2.5.29.33")) {
                  _context9.next = 86;
                  break;
                }

                if (!policyMappingInhibitIndicator) {
                  _context9.next = 85;
                  break;
                }

                return _context9.abrupt("return", {
                  result: false,
                  resultCode: 98,
                  resultMessage: "Policy mapping prohibited"
                });

              case 85:
                policyMappings[i] = _this4.certs[i].extensions[j].parsedValue;

              case 86:
                //endregion
                //region PolicyConstraints
                if (_this4.certs[i].extensions[j].extnID === "2.5.29.36") {
                  if (explicitPolicyIndicator === false) {
                    //region requireExplicitPolicy
                    if (_this4.certs[i].extensions[j].parsedValue.requireExplicitPolicy === 0) {
                      explicitPolicyIndicator = true;
                      explicitPolicyStart = i;
                    } else {
                      if (pendingConstraints[0] === false) {
                        pendingConstraints[0] = true;
                        explicitPolicyPending = _this4.certs[i].extensions[j].parsedValue.requireExplicitPolicy;
                      } else explicitPolicyPending = explicitPolicyPending > _this4.certs[i].extensions[j].parsedValue.requireExplicitPolicy ? _this4.certs[i].extensions[j].parsedValue.requireExplicitPolicy : explicitPolicyPending;
                    } //endregion
                    //region inhibitPolicyMapping


                    if (_this4.certs[i].extensions[j].parsedValue.inhibitPolicyMapping === 0) policyMappingInhibitIndicator = true;else {
                      if (pendingConstraints[1] === false) {
                        pendingConstraints[1] = true;
                        policyMappingInhibitPending = _this4.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1;
                      } else policyMappingInhibitPending = policyMappingInhibitPending > _this4.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1 ? _this4.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1 : policyMappingInhibitPending;
                    } //endregion
                  }
                } //endregion
                //region InhibitAnyPolicy


                if (_this4.certs[i].extensions[j].extnID === "2.5.29.54") {
                  if (inhibitAnyPolicyIndicator === false) {
                    if (_this4.certs[i].extensions[j].parsedValue.valueBlock.valueDec === 0) inhibitAnyPolicyIndicator = true;else {
                      if (pendingConstraints[2] === false) {
                        pendingConstraints[2] = true;
                        inhibitAnyPolicyPending = _this4.certs[i].extensions[j].parsedValue.valueBlock.valueDec;
                      } else inhibitAnyPolicyPending = inhibitAnyPolicyPending > _this4.certs[i].extensions[j].parsedValue.valueBlock.valueDec ? _this4.certs[i].extensions[j].parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
                    }
                  }
                } //endregion


              case 88:
                j++;
                _context9.next = 56;
                break;

              case 91:
                if (!(inhibitAnyPolicyIndicator === true)) {
                  _context9.next = 102;
                  break;
                }

                _policyIndex = -1; //region Find "anyPolicy" index

                searchAnyPolicy = 0;

              case 94:
                if (!(searchAnyPolicy < allPolicies.length)) {
                  _context9.next = 101;
                  break;
                }

                if (!(allPolicies[searchAnyPolicy] === "2.5.29.32.0")) {
                  _context9.next = 98;
                  break;
                }

                _policyIndex = searchAnyPolicy;
                return _context9.abrupt("break", 101);

              case 98:
                searchAnyPolicy++;
                _context9.next = 94;
                break;

              case 101:
                //endregion
                if (_policyIndex !== -1) delete policiesAndCerts[0][i]; // Unset value to "undefined" for "anyPolicies" value for current certificate

              case 102:
                //endregion
                //region Process with "pending constraints"
                if (explicitPolicyIndicator === false) {
                  if (pendingConstraints[0] === true) {
                    explicitPolicyPending--;

                    if (explicitPolicyPending === 0) {
                      explicitPolicyIndicator = true;
                      explicitPolicyStart = i;
                      pendingConstraints[0] = false;
                    }
                  }
                }

                if (policyMappingInhibitIndicator === false) {
                  if (pendingConstraints[1] === true) {
                    policyMappingInhibitPending--;

                    if (policyMappingInhibitPending === 0) {
                      policyMappingInhibitIndicator = true;
                      pendingConstraints[1] = false;
                    }
                  }
                }

                if (inhibitAnyPolicyIndicator === false) {
                  if (pendingConstraints[2] === true) {
                    inhibitAnyPolicyPending--;

                    if (inhibitAnyPolicyPending === 0) {
                      inhibitAnyPolicyIndicator = true;
                      pendingConstraints[2] = false;
                    }
                  }
                } //endregion


              case 105:
                i--, pathDepth++;
                _context9.next = 53;
                break;

              case 108:
                _i48 = 0;

              case 109:
                if (!(_i48 < _this4.certs.length - 1)) {
                  _context9.next = 126;
                  break;
                }

                if (!(_i48 < _this4.certs.length - 2 && typeof policyMappings[_i48 + 1] !== "undefined")) {
                  _context9.next = 123;
                  break;
                }

                _k = 0;

              case 112:
                if (!(_k < policyMappings[_i48 + 1].mappings.length)) {
                  _context9.next = 123;
                  break;
                }

                if (!(policyMappings[_i48 + 1].mappings[_k].issuerDomainPolicy === "2.5.29.32.0" || policyMappings[_i48 + 1].mappings[_k].subjectDomainPolicy === "2.5.29.32.0")) {
                  _context9.next = 115;
                  break;
                }

                return _context9.abrupt("return", {
                  result: false,
                  resultCode: 99,
                  resultMessage: "The \"anyPolicy\" should not be a part of policy mapping scheme"
                });

              case 115:
                //endregion
                //region Initial variables
                issuerDomainPolicyIndex = -1;
                subjectDomainPolicyIndex = -1; //endregion
                //region Search for index of policies indedes

                for (n = 0; n < allPolicies.length; n++) {
                  if (allPolicies[n] === policyMappings[_i48 + 1].mappings[_k].issuerDomainPolicy) issuerDomainPolicyIndex = n;
                  if (allPolicies[n] === policyMappings[_i48 + 1].mappings[_k].subjectDomainPolicy) subjectDomainPolicyIndex = n;
                } //endregion
                //region Delete existing "issuerDomainPolicy" because on the level we mapped the policy to another one


                if (typeof policiesAndCerts[issuerDomainPolicyIndex][_i48] !== "undefined") delete policiesAndCerts[issuerDomainPolicyIndex][_i48]; //endregion
                //region Check all policies for the certificate

                for (_j9 = 0; _j9 < certPolicies[_i48].certificatePolicies.length; _j9++) {
                  if (policyMappings[_i48 + 1].mappings[_k].subjectDomainPolicy === certPolicies[_i48].certificatePolicies[_j9].policyIdentifier) {
                    //region Set mapped policy for current certificate
                    if (issuerDomainPolicyIndex !== -1 && subjectDomainPolicyIndex !== -1) {
                      for (m = 0; m <= _i48; m++) {
                        if (typeof policiesAndCerts[subjectDomainPolicyIndex][m] !== "undefined") {
                          policiesAndCerts[issuerDomainPolicyIndex][m] = true;
                          delete policiesAndCerts[subjectDomainPolicyIndex][m];
                        }
                      }
                    } //endregion

                  }
                } //endregion


              case 120:
                _k++;
                _context9.next = 112;
                break;

              case 123:
                _i48++;
                _context9.next = 109;
                break;

              case 126:
                //endregion
                //region Working with "explicitPolicyIndicator" and "anyPolicy"
                for (_i49 = 0; _i49 < allPolicies.length; _i49++) {
                  if (allPolicies[_i49] === "2.5.29.32.0") {
                    for (_j10 = 0; _j10 < explicitPolicyStart; _j10++) {
                      delete policiesAndCerts[_i49][_j10];
                    }
                  }
                } //endregion
                //region Create "set of authorities-constrained policies"


                authConstrPolicies = [];
                _i50 = 0;

              case 129:
                if (!(_i50 < policiesAndCerts.length)) {
                  _context9.next = 157;
                  break;
                }

                found = true;
                _j11 = 0;

              case 132:
                if (!(_j11 < _this4.certs.length - 1)) {
                  _context9.next = 153;
                  break;
                }

                anyPolicyFound = false;

                if (!(_j11 < explicitPolicyStart && allPolicies[_i50] === "2.5.29.32.0" && allPolicies.length > 1)) {
                  _context9.next = 137;
                  break;
                }

                found = false;
                return _context9.abrupt("break", 153);

              case 137:
                if (!(typeof policiesAndCerts[_i50][_j11] === "undefined")) {
                  _context9.next = 150;
                  break;
                }

                if (!(_j11 >= explicitPolicyStart)) {
                  _context9.next = 147;
                  break;
                }

                _k2 = 0;

              case 140:
                if (!(_k2 < allPolicies.length)) {
                  _context9.next = 147;
                  break;
                }

                if (!(allPolicies[_k2] === "2.5.29.32.0")) {
                  _context9.next = 144;
                  break;
                }

                if (policiesAndCerts[_k2][_j11] === true) anyPolicyFound = true;
                return _context9.abrupt("break", 147);

              case 144:
                _k2++;
                _context9.next = 140;
                break;

              case 147:
                if (anyPolicyFound) {
                  _context9.next = 150;
                  break;
                }

                found = false;
                return _context9.abrupt("break", 153);

              case 150:
                _j11++;
                _context9.next = 132;
                break;

              case 153:
                if (found === true) authConstrPolicies.push(allPolicies[_i50]);

              case 154:
                _i50++;
                _context9.next = 129;
                break;

              case 157:
                //endregion
                //region Create "set of user-constrained policies"
                userConstrPolicies = [];

                if (!(initialPolicySet.length === 1 && initialPolicySet[0] === "2.5.29.32.0" && explicitPolicyIndicator === false)) {
                  _context9.next = 162;
                  break;
                }

                userConstrPolicies = initialPolicySet;
                _context9.next = 179;
                break;

              case 162:
                if (!(authConstrPolicies.length === 1 && authConstrPolicies[0] === "2.5.29.32.0")) {
                  _context9.next = 166;
                  break;
                }

                userConstrPolicies = initialPolicySet;
                _context9.next = 179;
                break;

              case 166:
                _i51 = 0;

              case 167:
                if (!(_i51 < authConstrPolicies.length)) {
                  _context9.next = 179;
                  break;
                }

                _j12 = 0;

              case 169:
                if (!(_j12 < initialPolicySet.length)) {
                  _context9.next = 176;
                  break;
                }

                if (!(initialPolicySet[_j12] === authConstrPolicies[_i51] || initialPolicySet[_j12] === "2.5.29.32.0")) {
                  _context9.next = 173;
                  break;
                }

                userConstrPolicies.push(authConstrPolicies[_i51]);
                return _context9.abrupt("break", 176);

              case 173:
                _j12++;
                _context9.next = 169;
                break;

              case 176:
                _i51++;
                _context9.next = 167;
                break;

              case 179:
                //endregion
                //region Combine output object
                policyResult = {
                  result: userConstrPolicies.length > 0,
                  resultCode: 0,
                  resultMessage: userConstrPolicies.length > 0 ? "" : "Zero \"userConstrPolicies\" array, no intersections with \"authConstrPolicies\"",
                  authConstrPolicies,
                  userConstrPolicies,
                  explicitPolicyIndicator,
                  policyMappings,
                  certificatePath: _this4.certs
                };

                if (!(userConstrPolicies.length === 0)) {
                  _context9.next = 182;
                  break;
                }

                return _context9.abrupt("return", policyResult);

              case 182:
                if (!(policyResult.result === false)) {
                  _context9.next = 184;
                  break;
                }

                return _context9.abrupt("return", policyResult);

              case 184:
                //endregion
                //region Check all certificates, excluding "trust anchor"
                pathDepth = 1;
                _i52 = _this4.certs.length - 2;

              case 186:
                if (!(_i52 >= 0)) {
                  _context9.next = 308;
                  break;
                }

                //region Support variables
                subjectAltNames = [];
                certPermittedSubtrees = [];
                certExcludedSubtrees = []; //endregion

                if ("extensions" in _this4.certs[_i52]) {
                  for (_j13 = 0; _j13 < _this4.certs[_i52].extensions.length; _j13++) {
                    //region NameConstraints
                    if (_this4.certs[_i52].extensions[_j13].extnID === "2.5.29.30") {
                      if ("permittedSubtrees" in _this4.certs[_i52].extensions[_j13].parsedValue) certPermittedSubtrees = certPermittedSubtrees.concat(_this4.certs[_i52].extensions[_j13].parsedValue.permittedSubtrees);
                      if ("excludedSubtrees" in _this4.certs[_i52].extensions[_j13].parsedValue) certExcludedSubtrees = certExcludedSubtrees.concat(_this4.certs[_i52].extensions[_j13].parsedValue.excludedSubtrees);
                    } //endregion
                    //region SubjectAltName


                    if (_this4.certs[_i52].extensions[_j13].extnID === "2.5.29.17") subjectAltNames = subjectAltNames.concat(_this4.certs[_i52].extensions[_j13].parsedValue.altNames); //endregion
                  }
                } //region Checking for "required name forms"


                formFound = requiredNameForms.length <= 0;
                _j14 = 0;

              case 193:
                if (!(_j14 < requiredNameForms.length)) {
                  _context9.next = 214;
                  break;
                }

                _context9.t0 = requiredNameForms[_j14].base.type;
                _context9.next = _context9.t0 === 4 ? 197 : 211;
                break;

              case 197:
                if (!(requiredNameForms[_j14].base.value.typesAndValues.length !== _this4.certs[_i52].subject.typesAndValues.length)) {
                  _context9.next = 199;
                  break;
                }

                return _context9.abrupt("continue", 211);

              case 199:
                formFound = true;
                _k3 = 0;

              case 201:
                if (!(_k3 < _this4.certs[_i52].subject.typesAndValues.length)) {
                  _context9.next = 208;
                  break;
                }

                if (!(_this4.certs[_i52].subject.typesAndValues[_k3].type !== requiredNameForms[_j14].base.value.typesAndValues[_k3].type)) {
                  _context9.next = 205;
                  break;
                }

                formFound = false;
                return _context9.abrupt("break", 208);

              case 205:
                _k3++;
                _context9.next = 201;
                break;

              case 208:
                if (!(formFound === true)) {
                  _context9.next = 210;
                  break;
                }

                return _context9.abrupt("break", 211);

              case 210:
                return _context9.abrupt("break", 211);

              case 211:
                _j14++;
                _context9.next = 193;
                break;

              case 214:
                if (!(formFound === false)) {
                  _context9.next = 219;
                  break;
                }

                policyResult.result = false;
                policyResult.resultCode = 21;
                policyResult.resultMessage = "No neccessary name form found";
                throw policyResult;

              case 219:
                //endregion
                //region Checking for "permited sub-trees"
                //region Make groups for all types of constraints
                constrGroups = []; // Array of array for groupped constraints

                constrGroups[0] = []; // rfc822Name

                constrGroups[1] = []; // dNSName

                constrGroups[2] = []; // directoryName

                constrGroups[3] = []; // uniformResourceIdentifier

                constrGroups[4] = []; // iPAddress

                _j15 = 0;

              case 226:
                if (!(_j15 < permittedSubtrees.length)) {
                  _context9.next = 243;
                  break;
                }

                _context9.t1 = permittedSubtrees[_j15].base.type;
                _context9.next = _context9.t1 === 1 ? 230 : _context9.t1 === 2 ? 232 : _context9.t1 === 4 ? 234 : _context9.t1 === 6 ? 236 : _context9.t1 === 7 ? 238 : 240;
                break;

              case 230:
                constrGroups[0].push(permittedSubtrees[_j15]);
                return _context9.abrupt("break", 240);

              case 232:
                constrGroups[1].push(permittedSubtrees[_j15]);
                return _context9.abrupt("break", 240);

              case 234:
                constrGroups[2].push(permittedSubtrees[_j15]);
                return _context9.abrupt("break", 240);

              case 236:
                constrGroups[3].push(permittedSubtrees[_j15]);
                return _context9.abrupt("break", 240);

              case 238:
                constrGroups[4].push(permittedSubtrees[_j15]);
                return _context9.abrupt("break", 240);

              case 240:
                _j15++;
                _context9.next = 226;
                break;

              case 243:
                p = 0;

              case 244:
                if (!(p < 5)) {
                  _context9.next = 277;
                  break;
                }

                groupPermitted = false;
                valueExists = false;
                group = constrGroups[p];
                _j16 = 0;

              case 249:
                if (!(_j16 < group.length)) {
                  _context9.next = 269;
                  break;
                }

                _context9.t2 = p;
                _context9.next = _context9.t2 === 0 ? 253 : _context9.t2 === 1 ? 255 : _context9.t2 === 2 ? 257 : _context9.t2 === 3 ? 260 : _context9.t2 === 4 ? 262 : 264;
                break;

              case 253:
                if (subjectAltNames.length > 0) {
                  for (_k4 = 0; _k4 < subjectAltNames.length; _k4++) {
                    if (subjectAltNames[_k4].type === 1) // rfc822Name
                      {
                        valueExists = true;
                        groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[_k4].value, group[_j16].base.value);
                      }
                  }
                } else // Try to find out "emailAddress" inside "subject"
                  {
                    for (_k5 = 0; _k5 < _this4.certs[_i52].subject.typesAndValues.length; _k5++) {
                      if (_this4.certs[_i52].subject.typesAndValues[_k5].type === "1.2.840.113549.1.9.1" || // PKCS#9 e-mail address
                      _this4.certs[_i52].subject.typesAndValues[_k5].type === "0.9.2342.19200300.100.1.3") // RFC1274 "rfc822Mailbox" e-mail address
                        {
                          valueExists = true;
                          groupPermitted = groupPermitted || compareRFC822Name(_this4.certs[_i52].subject.typesAndValues[_k5].value.valueBlock.value, group[_j16].base.value);
                        }
                    }
                  }

                return _context9.abrupt("break", 264);

              case 255:
                if (subjectAltNames.length > 0) {
                  for (_k6 = 0; _k6 < subjectAltNames.length; _k6++) {
                    if (subjectAltNames[_k6].type === 2) // dNSName
                      {
                        valueExists = true;
                        groupPermitted = groupPermitted || compareDNSName(subjectAltNames[_k6].value, group[_j16].base.value);
                      }
                  }
                }

                return _context9.abrupt("break", 264);

              case 257:
                valueExists = true;
                groupPermitted = compareDirectoryName(_this4.certs[_i52].subject, group[_j16].base.value);
                return _context9.abrupt("break", 264);

              case 260:
                if (subjectAltNames.length > 0) {
                  for (_k7 = 0; _k7 < subjectAltNames.length; _k7++) {
                    if (subjectAltNames[_k7].type === 6) // uniformResourceIdentifier
                      {
                        valueExists = true;
                        groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[_k7].value, group[_j16].base.value);
                      }
                  }
                }

                return _context9.abrupt("break", 264);

              case 262:
                if (subjectAltNames.length > 0) {
                  for (_k8 = 0; _k8 < subjectAltNames.length; _k8++) {
                    if (subjectAltNames[_k8].type === 7) // iPAddress
                      {
                        valueExists = true;
                        groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[_k8].value, group[_j16].base.value);
                      }
                  }
                }

                return _context9.abrupt("break", 264);

              case 264:
                if (!groupPermitted) {
                  _context9.next = 266;
                  break;
                }

                return _context9.abrupt("break", 269);

              case 266:
                _j16++;
                _context9.next = 249;
                break;

              case 269:
                if (!(groupPermitted === false && group.length > 0 && valueExists)) {
                  _context9.next = 274;
                  break;
                }

                policyResult.result = false;
                policyResult.resultCode = 41;
                policyResult.resultMessage = "Failed to meet \"permitted sub-trees\" name constraint";
                throw policyResult;

              case 274:
                p++;
                _context9.next = 244;
                break;

              case 277:
                //endregion
                //endregion
                //region Checking for "excluded sub-trees"
                excluded = false;
                _j17 = 0;

              case 279:
                if (!(_j17 < excludedSubtrees.length)) {
                  _context9.next = 298;
                  break;
                }

                _context9.t3 = excludedSubtrees[_j17].base.type;
                _context9.next = _context9.t3 === 1 ? 283 : _context9.t3 === 2 ? 285 : _context9.t3 === 4 ? 287 : _context9.t3 === 6 ? 289 : _context9.t3 === 7 ? 291 : 293;
                break;

              case 283:
                if (subjectAltNames.length >= 0) {
                  for (_k9 = 0; _k9 < subjectAltNames.length; _k9++) {
                    if (subjectAltNames[_k9].type === 1) // rfc822Name
                      excluded = excluded || compareRFC822Name(subjectAltNames[_k9].value, excludedSubtrees[_j17].base.value);
                  }
                } else // Try to find out "emailAddress" inside "subject"
                  {
                    for (_k10 = 0; _k10 < _this4.certs[_i52].subject.typesAndValues.length; _k10++) {
                      if (_this4.certs[_i52].subject.typesAndValues[_k10].type === "1.2.840.113549.1.9.1" || // PKCS#9 e-mail address
                      _this4.certs[_i52].subject.typesAndValues[_k10].type === "0.9.2342.19200300.100.1.3") // RFC1274 "rfc822Mailbox" e-mail address
                        excluded = excluded || compareRFC822Name(_this4.certs[_i52].subject.typesAndValues[_k10].value.valueBlock.value, excludedSubtrees[_j17].base.value);
                    }
                  }

                return _context9.abrupt("break", 293);

              case 285:
                if (subjectAltNames.length > 0) {
                  for (_k11 = 0; _k11 < subjectAltNames.length; _k11++) {
                    if (subjectAltNames[_k11].type === 2) // dNSName
                      excluded = excluded || compareDNSName(subjectAltNames[_k11].value, excludedSubtrees[_j17].base.value);
                  }
                }

                return _context9.abrupt("break", 293);

              case 287:
                excluded = excluded || compareDirectoryName(_this4.certs[_i52].subject, excludedSubtrees[_j17].base.value);
                return _context9.abrupt("break", 293);

              case 289:
                if (subjectAltNames.length > 0) {
                  for (_k12 = 0; _k12 < subjectAltNames.length; _k12++) {
                    if (subjectAltNames[_k12].type === 6) // uniformResourceIdentifier
                      excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[_k12].value, excludedSubtrees[_j17].base.value);
                  }
                }

                return _context9.abrupt("break", 293);

              case 291:
                if (subjectAltNames.length > 0) {
                  for (_k13 = 0; _k13 < subjectAltNames.length; _k13++) {
                    if (subjectAltNames[_k13].type === 7) // iPAddress
                      excluded = excluded || compareIPAddress(subjectAltNames[_k13].value, excludedSubtrees[_j17].base.value);
                  }
                }

                return _context9.abrupt("break", 293);

              case 293:
                if (!excluded) {
                  _context9.next = 295;
                  break;
                }

                return _context9.abrupt("break", 298);

              case 295:
                _j17++;
                _context9.next = 279;
                break;

              case 298:
                if (!(excluded === true)) {
                  _context9.next = 303;
                  break;
                }

                policyResult.result = false;
                policyResult.resultCode = 42;
                policyResult.resultMessage = "Failed to meet \"excluded sub-trees\" name constraint";
                throw policyResult;

              case 303:
                //endregion
                //region Append "cert_..._subtrees" to "..._subtrees"
                permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
                excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees); //endregion

              case 305:
                _i52--, pathDepth++;
                _context9.next = 186;
                break;

              case 308:
                return _context9.abrupt("return", policyResult);

              case 311:
                _context9.prev = 311;
                _context9.t4 = _context9["catch"](6);

                if (!(_context9.t4 instanceof Object)) {
                  _context9.next = 318;
                  break;
                }

                if (!("resultMessage" in _context9.t4)) {
                  _context9.next = 316;
                  break;
                }

                return _context9.abrupt("return", _context9.t4);

              case 316:
                if (!("message" in _context9.t4)) {
                  _context9.next = 318;
                  break;
                }

                return _context9.abrupt("return", {
                  result: false,
                  resultCode: -1,
                  resultMessage: _context9.t4.message
                });

              case 318:
                return _context9.abrupt("return", {
                  result: false,
                  resultCode: -1,
                  resultMessage: _context9.t4
                });

              case 319:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, null, [[6, 311]]);
      }))();
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC6960
   */


  class CertID {
    //**********************************************************************************

    /**
     * Constructor for CertID class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {AlgorithmIdentifier}
       * @desc hashAlgorithm
       */
      this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", CertID.defaultValues("hashAlgorithm"));
      /**
       * @type {OctetString}
       * @desc issuerNameHash
       */

      this.issuerNameHash = getParametersValue(parameters, "issuerNameHash", CertID.defaultValues("issuerNameHash"));
      /**
       * @type {OctetString}
       * @desc issuerKeyHash
       */

      this.issuerKeyHash = getParametersValue(parameters, "issuerKeyHash", CertID.defaultValues("issuerKeyHash"));
      /**
       * @type {Integer}
       * @desc serialNumber
       */

      this.serialNumber = getParametersValue(parameters, "serialNumber", CertID.defaultValues("serialNumber")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "hashAlgorithm":
          return new AlgorithmIdentifier();

        case "issuerNameHash":
        case "issuerKeyHash":
          return new OctetString();

        case "serialNumber":
          return new Integer();

        default:
          throw new Error("Invalid member name for CertID class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "hashAlgorithm":
          return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;

        case "issuerNameHash":
        case "issuerKeyHash":
        case "serialNumber":
          return memberValue.isEqual(CertID.defaultValues(memberName));

        default:
          throw new Error("Invalid member name for CertID class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * CertID          ::=     SEQUENCE {
     *    hashAlgorithm       AlgorithmIdentifier,
     *    issuerNameHash      OCTET STRING, -- Hash of issuer's DN
     *    issuerKeyHash       OCTET STRING, -- Hash of issuer's public key
     *    serialNumber        CertificateSerialNumber }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [hashAlgorithm]
       * @property {string} [hashAlgorithmObject]
       * @property {string} [issuerNameHash]
       * @property {string} [issuerKeyHash]
       * @property {string} [serialNumber]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [AlgorithmIdentifier.schema(names.hashAlgorithmObject || {
          names: {
            blockName: names.hashAlgorithm || ""
          }
        }), new OctetString({
          name: names.issuerNameHash || ""
        }), new OctetString({
          name: names.issuerKeyHash || ""
        }), new Integer({
          name: names.serialNumber || ""
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["hashAlgorithm", "issuerNameHash", "issuerKeyHash", "serialNumber"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, CertID.schema({
        names: {
          hashAlgorithm: "hashAlgorithm",
          issuerNameHash: "issuerNameHash",
          issuerKeyHash: "issuerKeyHash",
          serialNumber: "serialNumber"
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertID"); //endregion
      //region Get internal properties from parsed schema

      this.hashAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result.hashAlgorithm
      });
      this.issuerNameHash = asn1.result.issuerNameHash;
      this.issuerKeyHash = asn1.result.issuerKeyHash;
      this.serialNumber = asn1.result.serialNumber; //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Construct and return new ASN.1 schema for this object
      return new Sequence({
        value: [this.hashAlgorithm.toSchema(), this.issuerNameHash, this.issuerKeyHash, this.serialNumber]
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      return {
        hashAlgorithm: this.hashAlgorithm.toJSON(),
        issuerNameHash: this.issuerNameHash.toJSON(),
        issuerKeyHash: this.issuerKeyHash.toJSON(),
        serialNumber: this.serialNumber.toJSON()
      };
    } //**********************************************************************************

    /**
     * Check that two "CertIDs" are equal
     * @param {CertID} certificateID Identifier of the certificate to be checked
     * @returns {boolean}
     */


    isEqual(certificateID) {
      //region Check "hashAlgorithm"
      if (!this.hashAlgorithm.algorithmId === certificateID.hashAlgorithm.algorithmId) return false; //endregion
      //region Check "issuerNameHash"

      if (isEqualBuffer(this.issuerNameHash.valueBlock.valueHex, certificateID.issuerNameHash.valueBlock.valueHex) === false) return false; //endregion
      //region Check "issuerKeyHash"

      if (isEqualBuffer(this.issuerKeyHash.valueBlock.valueHex, certificateID.issuerKeyHash.valueBlock.valueHex) === false) return false; //endregion
      //region Check "serialNumber"

      if (!this.serialNumber.isEqual(certificateID.serialNumber)) return false; //endregion

      return true;
    } //**********************************************************************************

    /**
     * Making OCSP certificate identifier for specific certificate
     * @param {Certificate} certificate Certificate making OCSP Request for
     * @param {Object} parameters Additional parameters
     * @returns {Promise}
     */


    createForCertificate(certificate, parameters) {
      //region Initial variables
      var sequence = Promise.resolve();
      var issuerCertificate; //endregion
      //region Get a "crypto" extension

      var crypto = getCrypto();
      if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object"); //endregion
      //region Check input parameters

      if ("hashAlgorithm" in parameters === false) return Promise.reject("Parameter \"hashAlgorithm\" is mandatory for \"OCSP_REQUEST.createForCertificate\"");
      var hashOID = getOIDByAlgorithm({
        name: parameters.hashAlgorithm
      });
      if (hashOID === "") return Promise.reject("Incorrect \"hashAlgorithm\": ".concat(this.hashAlgorithm));
      this.hashAlgorithm = new AlgorithmIdentifier({
        algorithmId: hashOID,
        algorithmParams: new Null()
      });
      if ("issuerCertificate" in parameters) issuerCertificate = parameters.issuerCertificate;else return Promise.reject("Parameter \"issuerCertificate\" is mandatory for \"OCSP_REQUEST.createForCertificate\""); //endregion
      //region Initialize "serialNumber" field

      this.serialNumber = certificate.serialNumber; //endregion
      //region Create "issuerNameHash"

      sequence = sequence.then(() => crypto.digest({
        name: parameters.hashAlgorithm
      }, issuerCertificate.subject.toSchema().toBER(false)), error => Promise.reject(error)); //endregion
      //region Create "issuerKeyHash"

      sequence = sequence.then(result => {
        this.issuerNameHash = new OctetString({
          valueHex: result
        });
        var issuerKeyBuffer = issuerCertificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex;
        return crypto.digest({
          name: parameters.hashAlgorithm
        }, issuerKeyBuffer);
      }, error => Promise.reject(error)).then(result => {
        this.issuerKeyHash = new OctetString({
          valueHex: result
        });
      }, error => Promise.reject(error)); //endregion

      return sequence;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC6960
   */


  class SingleResponse {
    //**********************************************************************************

    /**
     * Constructor for SingleResponse class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {CertID}
       * @desc certID
       */
      this.certID = getParametersValue(parameters, "certID", SingleResponse.defaultValues("certID"));
      /**
       * @type {Object}
       * @desc certStatus
       */

      this.certStatus = getParametersValue(parameters, "certStatus", SingleResponse.defaultValues("certStatus"));
      /**
       * @type {Date}
       * @desc thisUpdate
       */

      this.thisUpdate = getParametersValue(parameters, "thisUpdate", SingleResponse.defaultValues("thisUpdate"));
      if ("nextUpdate" in parameters)
        /**
         * @type {Date}
         * @desc nextUpdate
         */
        this.nextUpdate = getParametersValue(parameters, "nextUpdate", SingleResponse.defaultValues("nextUpdate"));
      if ("singleExtensions" in parameters)
        /**
         * @type {Array.<Extension>}
         * @desc singleExtensions
         */
        this.singleExtensions = getParametersValue(parameters, "singleExtensions", SingleResponse.defaultValues("singleExtensions")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "certID":
          return new CertID();

        case "certStatus":
          return {};

        case "thisUpdate":
        case "nextUpdate":
          return new Date(0, 0, 0);

        case "singleExtensions":
          return [];

        default:
          throw new Error("Invalid member name for SingleResponse class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "certID":
          // noinspection OverlyComplexBooleanExpressionJS
          return CertID.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && CertID.compareWithDefault("issuerNameHash", memberValue.issuerNameHash) && CertID.compareWithDefault("issuerKeyHash", memberValue.issuerKeyHash) && CertID.compareWithDefault("serialNumber", memberValue.serialNumber);

        case "certStatus":
          return Object.keys(memberValue).length === 0;

        case "thisUpdate":
        case "nextUpdate":
          return memberValue === SingleResponse.defaultValues(memberName);

        default:
          throw new Error("Invalid member name for SingleResponse class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * SingleResponse ::= SEQUENCE {
     *    certID                       CertID,
     *    certStatus                   CertStatus,
     *    thisUpdate                   GeneralizedTime,
     *    nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
     *    singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
     *
     * CertStatus ::= CHOICE {
     *    good        [0]     IMPLICIT NULL,
     *    revoked     [1]     IMPLICIT RevokedInfo,
     *    unknown     [2]     IMPLICIT UnknownInfo }
     *
     * RevokedInfo ::= SEQUENCE {
     *    revocationTime              GeneralizedTime,
     *    revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
     *
     * UnknownInfo ::= NULL
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [certID]
       * @property {string} [certStatus]
       * @property {string} [thisUpdate]
       * @property {string} [nextUpdate]
       * @property {string} [singleExtensions]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "",
        value: [CertID.schema(names.certID || {}), new Choice({
          value: [new Primitive({
            name: names.certStatus || "",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 0 // [0]

            },
            lenBlockLength: 1 // The length contains one byte 0x00

          }), // IMPLICIT NULL (no "valueBlock")
          new Constructed({
            name: names.certStatus || "",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 1 // [1]

            },
            value: [new GeneralizedTime(), new Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 0 // [0]

              },
              value: [new Enumerated()]
            })]
          }), new Primitive({
            name: names.certStatus || "",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 2 // [2]

            },
            lenBlock: {
              length: 1
            }
          }) // IMPLICIT NULL (no "valueBlock")
          ]
        }), new GeneralizedTime({
          name: names.thisUpdate || ""
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new GeneralizedTime({
            name: names.nextUpdate || ""
          })]
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [Extensions.schema(names.singleExtensions || {})]
        }) // EXPLICIT SEQUENCE value
        ]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["certID", "certStatus", "thisUpdate", "nextUpdate", "singleExtensions"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, SingleResponse.schema({
        names: {
          certID: {
            names: {
              blockName: "certID"
            }
          },
          certStatus: "certStatus",
          thisUpdate: "thisUpdate",
          nextUpdate: "nextUpdate",
          singleExtensions: {
            names: {
              blockName: "singleExtensions"
            }
          }
        }
      }));
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SingleResponse"); //endregion
      //region Get internal properties from parsed schema

      this.certID = new CertID({
        schema: asn1.result.certID
      });
      this.certStatus = asn1.result.certStatus;
      this.thisUpdate = asn1.result.thisUpdate.toDate();
      if ("nextUpdate" in asn1.result) this.nextUpdate = asn1.result.nextUpdate.toDate();
      if ("singleExtensions" in asn1.result) this.singleExtensions = Array.from(asn1.result.singleExtensions.valueBlock.value, element => new Extension({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create value array for output sequence
      var outputArray = [];
      outputArray.push(this.certID.toSchema());
      outputArray.push(this.certStatus);
      outputArray.push(new GeneralizedTime({
        valueDate: this.thisUpdate
      }));

      if ("nextUpdate" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new GeneralizedTime({
            valueDate: this.nextUpdate
          })]
        }));
      }

      if ("singleExtensions" in this) {
        outputArray.push(new Sequence({
          value: Array.from(this.singleExtensions, element => element.toSchema())
        }));
      } //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        certID: this.certID.toJSON(),
        certStatus: this.certStatus.toJSON(),
        thisUpdate: this.thisUpdate
      };
      if ("nextUpdate" in this) _object.nextUpdate = this.nextUpdate;
      if ("singleExtensions" in this) _object.singleExtensions = Array.from(this.singleExtensions, element => element.toJSON());
      return _object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC6960
   */


  class ResponseData {
    //**********************************************************************************

    /**
     * Constructor for ResponseData class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {ArrayBuffer}
       * @desc tbs
       */
      this.tbs = getParametersValue(parameters, "tbs", ResponseData.defaultValues("tbs"));
      /**
       * @type {Object}
       * @desc responderID
       */

      this.responderID = getParametersValue(parameters, "responderID", ResponseData.defaultValues("responderID"));
      /**
       * @type {Date}
       * @desc producedAt
       */

      this.producedAt = getParametersValue(parameters, "producedAt", ResponseData.defaultValues("producedAt"));
      /**
       * @type {Array.<SingleResponse>}
       * @desc responses
       */

      this.responses = getParametersValue(parameters, "responses", ResponseData.defaultValues("responses"));
      if ("responseExtensions" in parameters)
        /**
         * @type {Array.<Extension>}
         * @desc responseExtensions
         */
        this.responseExtensions = getParametersValue(parameters, "responseExtensions", ResponseData.defaultValues("responseExtensions")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "tbs":
          return new ArrayBuffer(0);

        case "responderID":
          return {};

        case "producedAt":
          return new Date(0, 0, 0);

        case "responses":
        case "responseExtensions":
          return [];

        default:
          throw new Error("Invalid member name for ResponseData class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "tbs":
          return memberValue.byteLength === 0;

        case "responderID":
          return Object.keys(memberValue).length === 0;

        case "producedAt":
          return memberValue === ResponseData.defaultValues(memberName);

        case "responses":
        case "responseExtensions":
          return memberValue.length === 0;

        default:
          throw new Error("Invalid member name for ResponseData class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * ResponseData ::= SEQUENCE {
     *    version              [0] EXPLICIT Version DEFAULT v1,
     *    responderID              ResponderID,
     *    producedAt               GeneralizedTime,
     *    responses                SEQUENCE OF SingleResponse,
     *    responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [version]
       * @property {string} [ResponseDataByName]
       * @property {string} [ResponseDataByKey]
       * @property {string} [producedAt]
       * @property {string} [response]
       * @property {string} [extensions]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "ResponseData",
        value: [new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Integer({
            name: names.version || "ResponseData.version"
          })]
        }), new Choice({
          value: [new Constructed({
            name: names.responderID || "ResponseData.responderID",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 1 // [1]

            },
            value: [RelativeDistinguishedNames.schema(names.ResponseDataByName || {
              names: {
                blockName: "ResponseData.byName"
              }
            })]
          }), new Constructed({
            name: names.responderID || "ResponseData.responderID",
            idBlock: {
              tagClass: 3,
              // CONTEXT-SPECIFIC
              tagNumber: 2 // [2]

            },
            value: [new OctetString({
              name: names.ResponseDataByKey || "ResponseData.byKey"
            })]
          })]
        }), new GeneralizedTime({
          name: names.producedAt || "ResponseData.producedAt"
        }), new Sequence({
          value: [new Repeated({
            name: "ResponseData.responses",
            value: SingleResponse.schema(names.response || {})
          })]
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: [Extensions.schema(names.extensions || {
            names: {
              blockName: "ResponseData.responseExtensions"
            }
          })]
        }) // EXPLICIT SEQUENCE value
        ]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["ResponseData", "ResponseData.version", "ResponseData.responderID", "ResponseData.producedAt", "ResponseData.responses", "ResponseData.responseExtensions"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, ResponseData.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ResponseData"); //endregion
      //region Get internal properties from parsed schema

      this.tbs = asn1.result.ResponseData.valueBeforeDecode;
      if ("ResponseData.version" in asn1.result) this.version = asn1.result["ResponseData.version"].valueBlock.valueDec;
      if (asn1.result["ResponseData.responderID"].idBlock.tagNumber === 1) this.responderID = new RelativeDistinguishedNames({
        schema: asn1.result["ResponseData.responderID"].valueBlock.value[0]
      });else this.responderID = asn1.result["ResponseData.responderID"].valueBlock.value[0]; // OCTETSTRING

      this.producedAt = asn1.result["ResponseData.producedAt"].toDate();
      this.responses = Array.from(asn1.result["ResponseData.responses"], element => new SingleResponse({
        schema: element
      }));
      if ("ResponseData.responseExtensions" in asn1.result) this.responseExtensions = Array.from(asn1.result["ResponseData.responseExtensions"].valueBlock.value, element => new Extension({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @param {boolean} encodeFlag If param equal to false then create TBS schema via decoding stored value. In othe case create TBS schema via assembling from TBS parts.
     * @returns {Object} asn1js object
     */


    toSchema() {
      var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //region Decode stored TBS value 
      var tbsSchema;

      if (encodeFlag === false) {
        if (this.tbs.length === 0) // No stored certificate TBS part
          return ResponseData.schema();
        tbsSchema = fromBER(this.tbs).result;
      } //endregion 
      //region Create TBS schema via assembling from TBS parts
      else {
          var outputArray = [];

          if ("version" in this) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 0 // [0]

              },
              value: [new Integer({
                value: this.version
              })]
            }));
          }

          if (this.responderID instanceof RelativeDistinguishedNames) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 1 // [1]

              },
              value: [this.responderID.toSchema()]
            }));
          } else {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 2 // [2]

              },
              value: [this.responderID]
            }));
          }

          outputArray.push(new GeneralizedTime({
            valueDate: this.producedAt
          }));
          outputArray.push(new Sequence({
            value: Array.from(this.responses, element => element.toSchema())
          }));

          if ("responseExtensions" in this) {
            outputArray.push(new Constructed({
              idBlock: {
                tagClass: 3,
                // CONTEXT-SPECIFIC
                tagNumber: 1 // [1]

              },
              value: [new Sequence({
                value: Array.from(this.responseExtensions, element => element.toSchema())
              })]
            }));
          }

          tbsSchema = new Sequence({
            value: outputArray
          });
        } //endregion 
      //region Construct and return new ASN.1 schema for this object 


      return tbsSchema; //endregion 
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {};
      if ("version" in this) _object.version = this.version;
      if ("responderID" in this) _object.responderID = this.responderID;
      if ("producedAt" in this) _object.producedAt = this.producedAt;
      if ("responses" in this) _object.responses = Array.from(this.responses, element => element.toJSON());
      if ("responseExtensions" in this) _object.responseExtensions = Array.from(this.responseExtensions, element => element.toJSON());
      return _object;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC6960
   */


  class BasicOCSPResponse {
    //**********************************************************************************

    /**
     * Constructor for BasicOCSPResponse class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {ResponseData}
       * @desc tbsResponseData
       */
      this.tbsResponseData = getParametersValue(parameters, "tbsResponseData", BasicOCSPResponse.defaultValues("tbsResponseData"));
      /**
       * @type {AlgorithmIdentifier}
       * @desc signatureAlgorithm
       */

      this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", BasicOCSPResponse.defaultValues("signatureAlgorithm"));
      /**
       * @type {BitString}
       * @desc signature
       */

      this.signature = getParametersValue(parameters, "signature", BasicOCSPResponse.defaultValues("signature"));
      if ("certs" in parameters)
        /**
         * @type {Array.<Certificate>}
         * @desc certs
         */
        this.certs = getParametersValue(parameters, "certs", BasicOCSPResponse.defaultValues("certs")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "tbsResponseData":
          return new ResponseData();

        case "signatureAlgorithm":
          return new AlgorithmIdentifier();

        case "signature":
          return new BitString();

        case "certs":
          return [];

        default:
          throw new Error("Invalid member name for BasicOCSPResponse class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "type":
          {
            // noinspection OverlyComplexBooleanExpressionJS
            var comparisonResult = ResponseData.compareWithDefault("tbs", memberValue.tbs) && ResponseData.compareWithDefault("responderID", memberValue.responderID) && ResponseData.compareWithDefault("producedAt", memberValue.producedAt) && ResponseData.compareWithDefault("responses", memberValue.responses);
            if ("responseExtensions" in memberValue) comparisonResult = comparisonResult && ResponseData.compareWithDefault("responseExtensions", memberValue.responseExtensions);
            return comparisonResult;
          }

        case "signatureAlgorithm":
          return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;

        case "signature":
          return memberValue.isEqual(BasicOCSPResponse.defaultValues(memberName));

        case "certs":
          return memberValue.length === 0;

        default:
          throw new Error("Invalid member name for BasicOCSPResponse class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * BasicOCSPResponse       ::= SEQUENCE {
     *    tbsResponseData      ResponseData,
     *    signatureAlgorithm   AlgorithmIdentifier,
     *    signature            BIT STRING,
     *    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [tbsResponseData]
       * @property {string} [signatureAlgorithm]
       * @property {string} [signature]
       * @property {string} [certs]
       */
      var names = getParametersValue(parameters, "names", {});
      return new Sequence({
        name: names.blockName || "BasicOCSPResponse",
        value: [ResponseData.schema(names.tbsResponseData || {
          names: {
            blockName: "BasicOCSPResponse.tbsResponseData"
          }
        }), AlgorithmIdentifier.schema(names.signatureAlgorithm || {
          names: {
            blockName: "BasicOCSPResponse.signatureAlgorithm"
          }
        }), new BitString({
          name: names.signature || "BasicOCSPResponse.signature"
        }), new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Sequence({
            value: [new Repeated({
              name: "BasicOCSPResponse.certs",
              value: Certificate.schema(names.certs || {})
            })]
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["BasicOCSPResponse.tbsResponseData", "BasicOCSPResponse.signatureAlgorithm", "BasicOCSPResponse.signature", "BasicOCSPResponse.certs"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, BasicOCSPResponse.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for BasicOCSPResponse"); //endregion
      //region Get internal properties from parsed schema

      this.tbsResponseData = new ResponseData({
        schema: asn1.result["BasicOCSPResponse.tbsResponseData"]
      });
      this.signatureAlgorithm = new AlgorithmIdentifier({
        schema: asn1.result["BasicOCSPResponse.signatureAlgorithm"]
      });
      this.signature = asn1.result["BasicOCSPResponse.signature"];
      if ("BasicOCSPResponse.certs" in asn1.result) this.certs = Array.from(asn1.result["BasicOCSPResponse.certs"], element => new Certificate({
        schema: element
      })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(this.tbsResponseData.toSchema());
      outputArray.push(this.signatureAlgorithm.toSchema());
      outputArray.push(this.signature); //region Create array of certificates

      if ("certs" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: [new Sequence({
            value: Array.from(this.certs, element => element.toSchema())
          })]
        }));
      } //endregion
      //endregion
      //region Construct and return new ASN.1 schema for this object


      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        tbsResponseData: this.tbsResponseData.toJSON(),
        signatureAlgorithm: this.signatureAlgorithm.toJSON(),
        signature: this.signature.toJSON()
      };
      if ("certs" in this) _object.certs = Array.from(this.certs, element => element.toJSON());
      return _object;
    } //**********************************************************************************

    /**
     * Get OCSP response status for specific certificate
     * @param {Certificate} certificate Certificate to be checked
     * @param {Certificate} issuerCertificate Certificate of issuer for certificate to be checked
     * @returns {Promise}
     */


    getCertificateStatus(certificate, issuerCertificate) {
      //region Initial variables
      var sequence = Promise.resolve();
      var result = {
        isForCertificate: false,
        status: 2 // 0 = good, 1 = revoked, 2 = unknown

      };
      var hashesObject = {};
      var certIDs = [];
      var certIDPromises = []; //endregion
      //region Create all "certIDs" for input certificates

      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = this.tbsResponseData.responses[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var response = _step18.value;
          var hashAlgorithm = getAlgorithmByOID(response.certID.hashAlgorithm.algorithmId);
          if ("name" in hashAlgorithm === false) return Promise.reject("Wrong CertID hashing algorithm: ".concat(response.certID.hashAlgorithm.algorithmId));

          if (hashAlgorithm.name in hashesObject === false) {
            hashesObject[hashAlgorithm.name] = 1;
            var certID = new CertID();
            certIDs.push(certID);
            certIDPromises.push(certID.createForCertificate(certificate, {
              hashAlgorithm: hashAlgorithm.name,
              issuerCertificate
            }));
          }
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
            _iterator18.return();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }

      sequence = sequence.then(() => Promise.all(certIDPromises)); //endregion
      //region Compare all response's "certIDs" with identifiers for input certificate

      sequence = sequence.then(() => {
        var _iteratorNormalCompletion19 = true;
        var _didIteratorError19 = false;
        var _iteratorError19 = undefined;

        try {
          for (var _iterator19 = this.tbsResponseData.responses[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
            var response = _step19.value;

            for (var _i53 = 0, _certIDs = certIDs; _i53 < _certIDs.length; _i53++) {
              var id = _certIDs[_i53];

              if (response.certID.isEqual(id)) {
                result.isForCertificate = true;

                try {
                  switch (response.certStatus.idBlock.isConstructed) {
                    case true:
                      if (response.certStatus.idBlock.tagNumber === 1) result.status = 1; // revoked

                      break;

                    case false:
                      switch (response.certStatus.idBlock.tagNumber) {
                        case 0:
                          // good
                          result.status = 0;
                          break;

                        case 2:
                          // unknown
                          result.status = 2;
                          break;

                        default:
                      }

                      break;

                    default:
                  }
                } catch (ex) {}

                return result;
              }
            }
          }
        } catch (err) {
          _didIteratorError19 = true;
          _iteratorError19 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
              _iterator19.return();
            }
          } finally {
            if (_didIteratorError19) {
              throw _iteratorError19;
            }
          }
        }

        return result;
      }); //endregion

      return sequence;
    } //**********************************************************************************

    /**
     * Make signature for current OCSP Basic Response
     * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
     * @param {string} [hashAlgorithm="SHA-1"] Hashing algorithm. Default SHA-1
     * @returns {Promise}
     */


    sign(privateKey) {
      var hashAlgorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "SHA-1";
      //region Initial checking
      //region Get a private key from   parameter
      if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing"); //endregion
      //endregion
      //region Initial variables

      var sequence = Promise.resolve();
      var parameters;
      var engine = getEngine(); //endregion
      //region Get a "default parameters" for current algorithm and set correct signature algorithm

      sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
      sequence = sequence.then(result => {
        parameters = result.parameters;
        this.signatureAlgorithm = result.signatureAlgorithm;
      }); //endregion
      //region Create TBS data for signing

      sequence = sequence.then(() => {
        this.tbsResponseData.tbs = this.tbsResponseData.toSchema(true).toBER(false);
      }); //endregion
      //region Signing TBS data on provided private key

      sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbsResponseData.tbs, privateKey, parameters));
      sequence = sequence.then(result => {
        this.signature = new BitString({
          valueHex: result
        });
      }); //endregion

      return sequence;
    } //**********************************************************************************

    /**
     * Verify existing OCSP Basic Response
     * @param {Object} parameters Additional parameters
     * @returns {Promise}
     */


    verify() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Initial variables
      var signerCert = null;
      var certIndex = -1;
      var sequence = Promise.resolve();
      var trustedCerts = [];

      var _this = this;

      var engine = getEngine(); //endregion
      //region Check amount of certificates

      if ("certs" in this === false) return Promise.reject("No certificates attached to the BasicOCSPResponce"); //endregion
      //region Get input values

      if ("trustedCerts" in parameters) trustedCerts = parameters.trustedCerts; //endregion
      //region Aux  s

      /**
       * Check CA flag for the certificate
       * @param {Certificate} cert Certificate to find CA flag for
       * @returns {*}
       */

        checkCA(cert) {
        //region Do not include signer's certificate
        if (cert.issuer.isEqual(signerCert.issuer) === true && cert.serialNumber.isEqual(signerCert.serialNumber) === true) return null; //endregion

        var isCA = false;
        var _iteratorNormalCompletion20 = true;
        var _didIteratorError20 = false;
        var _iteratorError20 = undefined;

        try {
          for (var _iterator20 = cert.extensions[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
            var extension = _step20.value;

            if (extension.extnID === "2.5.29.19") // BasicConstraints
              {
                if ("cA" in extension.parsedValue) {
                  if (extension.parsedValue.cA === true) isCA = true;
                }
              }
          }
        } catch (err) {
          _didIteratorError20 = true;
          _iteratorError20 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
              _iterator20.return();
            }
          } finally {
            if (_didIteratorError20) {
              throw _iteratorError20;
            }
          }
        }

        if (isCA) return cert;
        return null;
      } //endregion
      //region Get a "crypto" extension


      var crypto = getCrypto();
      if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object"); //endregion
      //region Find correct value for "responderID"

      switch (true) {
        case this.tbsResponseData.responderID instanceof RelativeDistinguishedNames:
          // [1] Name
          sequence = sequence.then(() => {
            var _iteratorNormalCompletion21 = true;
            var _didIteratorError21 = false;
            var _iteratorError21 = undefined;

            try {
              for (var _iterator21 = _this.certs.entries()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                var _step21$value = _slicedToArray(_step21.value, 2),
                    index = _step21$value[0],
                    certificate = _step21$value[1];

                if (certificate.subject.isEqual(_this.tbsResponseData.responderID)) {
                  certIndex = index;
                  break;
                }
              }
            } catch (err) {
              _didIteratorError21 = true;
              _iteratorError21 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion21 && _iterator21.return != null) {
                  _iterator21.return();
                }
              } finally {
                if (_didIteratorError21) {
                  throw _iteratorError21;
                }
              }
            }
          });
          break;

        case this.tbsResponseData.responderID instanceof OctetString:
          // [2] KeyHash
          sequence = sequence.then(() => Promise.all(Array.from(_this.certs, element => crypto.digest({
            name: "sha-1"
          }, new Uint8Array(element.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(results => {
            var _iteratorNormalCompletion22 = true;
            var _didIteratorError22 = false;
            var _iteratorError22 = undefined;

            try {
              for (var _iterator22 = _this.certs.entries()[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var _step22$value = _slicedToArray(_step22.value, 1),
                    index = _step22$value[0];

                if (isEqualBuffer(results[index], _this.tbsResponseData.responderID.valueBlock.valueHex)) {
                  certIndex = index;
                  break;
                }
              }
            } catch (err) {
              _didIteratorError22 = true;
              _iteratorError22 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
                  _iterator22.return();
                }
              } finally {
                if (_didIteratorError22) {
                  throw _iteratorError22;
                }
              }
            }
          }));
          break;

        default:
          return Promise.reject("Wrong value for responderID");
      } //endregion
      //region Make additional verification for signer's certificate


      sequence = sequence.then(() => {
        if (certIndex === -1) return Promise.reject("Correct certificate was not found in OCSP response");
        signerCert = this.certs[certIndex];
        return Promise.all(Array.from(_this.certs, element => checkCA(element))).then(promiseResults => {
          var additionalCerts = [];
          additionalCerts.push(signerCert);
          var _iteratorNormalCompletion23 = true;
          var _didIteratorError23 = false;
          var _iteratorError23 = undefined;

          try {
            for (var _iterator23 = promiseResults[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
              var promiseResult = _step23.value;
              if (promiseResult !== null) additionalCerts.push(promiseResult);
            }
          } catch (err) {
            _didIteratorError23 = true;
            _iteratorError23 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion23 && _iterator23.return != null) {
                _iterator23.return();
              }
            } finally {
              if (_didIteratorError23) {
                throw _iteratorError23;
              }
            }
          }

          var certChain = new CertificateChainValidationEngine({
            certs: additionalCerts,
            trustedCerts
          });
          return certChain.verify().then(verificationResult => {
            if (verificationResult.result === true) return Promise.resolve();
            return Promise.reject("Validation of signer's certificate failed");
          }, error => Promise.reject("Validation of signer's certificate failed with error: ".concat(error instanceof Object ? error.resultMessage : error)));
        }, promiseError => Promise.reject("Error during checking certificates for CA flag: ".concat(promiseError)));
      }); //endregion

      sequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbsResponseData.tbs, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm));
      return sequence;
    } //**********************************************************************************


  } //**************************************************************************************
  //**************************************************************************************

  /**
   * Class from RFC5652
   */


  class SignedData {
    //**********************************************************************************

    /**
     * Constructor for SignedData class
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
     */
    constructor() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //region Internal properties of the object

      /**
       * @type {number}
       * @desc version
       */
      this.version = getParametersValue(parameters, "version", SignedData.defaultValues("version"));
      /**
       * @type {Array.<AlgorithmIdentifier>}
       * @desc digestAlgorithms
       */

      this.digestAlgorithms = getParametersValue(parameters, "digestAlgorithms", SignedData.defaultValues("digestAlgorithms"));
      /**
       * @type {EncapsulatedContentInfo}
       * @desc encapContentInfo
       */

      this.encapContentInfo = getParametersValue(parameters, "encapContentInfo", SignedData.defaultValues("encapContentInfo"));
      if ("certificates" in parameters)
        /**
         * @type {Array.<Certificate|OtherCertificateFormat>}
         * @desc certificates
         */
        this.certificates = getParametersValue(parameters, "certificates", SignedData.defaultValues("certificates"));
      if ("crls" in parameters)
        /**
         * @type {Array.<CertificateRevocationList|OtherRevocationInfoFormat>}
         * @desc crls
         */
        this.crls = getParametersValue(parameters, "crls", SignedData.defaultValues("crls"));
      if ("ocsps" in parameters)
        /**
         * @type {Array.<BasicOCSPResponse>}
         * @desc crls
         */
        this.ocsps = getParametersValue(parameters, "ocsps", SignedData.defaultValues("ocsps"));
      /**
       * @type {Array.<SignerInfo>}
       * @desc signerInfos
       */

      this.signerInfos = getParametersValue(parameters, "signerInfos", SignedData.defaultValues("signerInfos")); //endregion
      //region If input argument array contains "schema" for this object

      if ("schema" in parameters) this.fromSchema(parameters.schema); //endregion
    } //**********************************************************************************

    /**
     * Return default values for all class members
     * @param {string} memberName String name for a class member
     */


    static defaultValues(memberName) {
      switch (memberName) {
        case "version":
          return 0;

        case "digestAlgorithms":
          return [];

        case "encapContentInfo":
          return new EncapsulatedContentInfo();

        case "certificates":
          return [];

        case "crls":
          return [];

        case "ocsps":
          return [];

        case "signerInfos":
          return [];

        default:
          throw new Error("Invalid member name for SignedData class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Compare values with default values for all class members
     * @param {string} memberName String name for a class member
     * @param {*} memberValue Value to compare with default value
     */


    static compareWithDefault(memberName, memberValue) {
      switch (memberName) {
        case "version":
          return memberValue === SignedData.defaultValues("version");

        case "encapContentInfo":
          return new EncapsulatedContentInfo();

        case "digestAlgorithms":
        case "certificates":
        case "crls":
        case "ocsps":
        case "signerInfos":
          return memberValue.length === 0;

        default:
          throw new Error("Invalid member name for SignedData class: ".concat(memberName));
      }
    } //**********************************************************************************

    /**
     * Return value of pre-defined ASN.1 schema for current class
     *
     * ASN.1 schema:
     * ```asn1
     * SignedData ::= SEQUENCE {
     *    version CMSVersion,
     *    digestAlgorithms DigestAlgorithmIdentifiers,
     *    encapContentInfo EncapsulatedContentInfo,
     *    certificates [0] IMPLICIT CertificateSet OPTIONAL,
     *    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
     *    signerInfos SignerInfos }
     * ```
     *
     * @param {Object} parameters Input parameters for the schema
     * @returns {Object} asn1js schema object
     */


    static schema() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * @type {Object}
       * @property {string} [blockName]
       * @property {string} [optional]
       * @property {string} [digestAlgorithms]
       * @property {string} [encapContentInfo]
       * @property {string} [certificates]
       * @property {string} [crls]
       * @property {string} [signerInfos]
       */
      var names = getParametersValue(parameters, "names", {});
      if ("optional" in names === false) names.optional = false;
      return new Sequence({
        name: names.blockName || "SignedData",
        optional: names.optional,
        value: [new Integer({
          name: names.version || "SignedData.version"
        }), new Set({
          value: [new Repeated({
            name: names.digestAlgorithms || "SignedData.digestAlgorithms",
            value: AlgorithmIdentifier.schema()
          })]
        }), EncapsulatedContentInfo.schema(names.encapContentInfo || {
          names: {
            blockName: "SignedData.encapContentInfo"
          }
        }), new Constructed({
          name: names.certificates || "SignedData.certificates",
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 0 // [0]

          },
          value: CertificateSet.schema().valueBlock.value
        }), // IMPLICIT CertificateSet
        new Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: RevocationInfoChoices.schema(names.crls || {
            names: {
              crls: "SignedData.crls"
            }
          }).valueBlock.value
        }), // IMPLICIT RevocationInfoChoices
        new Set({
          value: [new Repeated({
            name: names.signerInfos || "SignedData.signerInfos",
            value: SignerInfo.schema()
          })]
        })]
      });
    } //**********************************************************************************

    /**
     * Convert parsed asn1js object into current class
     * @param {!Object} schema
     */


    fromSchema(schema) {
      //region Clear input data first
      clearProps(schema, ["SignedData.version", "SignedData.digestAlgorithms", "SignedData.encapContentInfo", "SignedData.certificates", "SignedData.crls", "SignedData.signerInfos"]); //endregion
      //region Check the schema is valid

      var asn1 = compareSchema(schema, schema, SignedData.schema());
      if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SignedData"); //endregion
      //region Get internal properties from parsed schema

      this.version = asn1.result["SignedData.version"].valueBlock.valueDec;
      if ("SignedData.digestAlgorithms" in asn1.result) // Could be empty SET of digest algorithms
        this.digestAlgorithms = Array.from(asn1.result["SignedData.digestAlgorithms"], algorithm => new AlgorithmIdentifier({
          schema: algorithm
        }));
      this.encapContentInfo = new EncapsulatedContentInfo({
        schema: asn1.result["SignedData.encapContentInfo"]
      });

      if ("SignedData.certificates" in asn1.result) {
        var certificateSet = new CertificateSet({
          schema: new Set({
            value: asn1.result["SignedData.certificates"].valueBlock.value
          })
        });
        this.certificates = certificateSet.certificates.slice(0); // Copy all just for making comfortable access
      }

      if ("SignedData.crls" in asn1.result) {
        this.crls = Array.from(asn1.result["SignedData.crls"], crl => {
          if (crl.idBlock.tagClass === 1) return new CertificateRevocationList({
            schema: crl
          }); //region Create SEQUENCE from [1]

          crl.idBlock.tagClass = 1; // UNIVERSAL

          crl.idBlock.tagNumber = 16; // SEQUENCE
          //endregion

          return new OtherRevocationInfoFormat({
            schema: crl
          });
        });
      }

      if ("SignedData.signerInfos" in asn1.result) // Could be empty SET SignerInfos
        this.signerInfos = Array.from(asn1.result["SignedData.signerInfos"], signerInfoSchema => new SignerInfo({
          schema: signerInfoSchema
        })); //endregion
    } //**********************************************************************************

    /**
     * Convert current object to asn1js object and set correct values
     * @returns {Object} asn1js object
     */


    toSchema() {
      var encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //region Create array for output sequence
      var outputArray = [];
      outputArray.push(new Integer({
        value: this.version
      })); //region Create array of digest algorithms

      outputArray.push(new Set({
        value: Array.from(this.digestAlgorithms, algorithm => algorithm.toSchema(encodeFlag))
      })); //endregion

      outputArray.push(this.encapContentInfo.toSchema());

      if ("certificates" in this) {
        var certificateSet = new CertificateSet({
          certificates: this.certificates
        });
        var certificateSetSchema = certificateSet.toSchema();
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: certificateSetSchema.valueBlock.value
        }));
      }

      if ("crls" in this) {
        outputArray.push(new Constructed({
          idBlock: {
            tagClass: 3,
            // CONTEXT-SPECIFIC
            tagNumber: 1 // [1]

          },
          value: Array.from(this.crls, crl => {
            if (crl instanceof OtherRevocationInfoFormat) {
              var crlSchema = crl.toSchema(encodeFlag);
              crlSchema.idBlock.tagClass = 3;
              crlSchema.idBlock.tagNumber = 1;
              return crlSchema;
            }

            return crl.toSchema(encodeFlag);
          })
        }));
      } //region Create array of signer infos


      outputArray.push(new Set({
        value: Array.from(this.signerInfos, signerInfo => signerInfo.toSchema(encodeFlag))
      })); //endregion
      //endregion
      //region Construct and return new ASN.1 schema for this object

      return new Sequence({
        value: outputArray
      }); //endregion
    } //**********************************************************************************

    /**
     * Convertion for the class to JSON object
     * @returns {Object}
     */


    toJSON() {
      var _object = {
        version: this.version,
        digestAlgorithms: Array.from(this.digestAlgorithms, algorithm => algorithm.toJSON()),
        encapContentInfo: this.encapContentInfo.toJSON()
      };
      if ("certificates" in this) _object.certificates = Array.from(this.certificates, certificate => certificate.toJSON());
      if ("crls" in this) _object.crls = Array.from(this.crls, crl => crl.toJSON());
      _object.signerInfos = Array.from(this.signerInfos, signerInfo => signerInfo.toJSON());
      return _object;
    } //**********************************************************************************

    /**
     * Verify current SignedData value
     * @param {Object} [param={}]
     * @param {Number} [param.signer = -1] Index of the signer which information we need to verify
     * @param {ArrayBuffer} [param.data=new ArrayBuffer(0)]
     * @param {Array.<Certificate>} [param.trustedCerts=[]]
     * @param {Date} [param.checkDate=new Date()]
     * @param {Boolean} [param.checkChain=false]
     * @param {Boolean} [param.extendedMode=false]
     * @param {? } [findOrigin=null]
     * @param {? } [findIssuer=null]
     */


    verify() {
      var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref18$signer = _ref18.signer,
          signer = _ref18$signer === void 0 ? -1 : _ref18$signer,
          _ref18$data = _ref18.data,
          data = _ref18$data === void 0 ? new ArrayBuffer(0) : _ref18$data,
          _ref18$trustedCerts = _ref18.trustedCerts,
          trustedCerts = _ref18$trustedCerts === void 0 ? [] : _ref18$trustedCerts,
          _ref18$checkDate = _ref18.checkDate,
          checkDate = _ref18$checkDate === void 0 ? new Date() : _ref18$checkDate,
          _ref18$checkChain = _ref18.checkChain,
          checkChain = _ref18$checkChain === void 0 ? false : _ref18$checkChain,
          _ref18$extendedMode = _ref18.extendedMode,
          extendedMode = _ref18$extendedMode === void 0 ? false : _ref18$extendedMode,
          _ref18$passedWhenNotR = _ref18.passedWhenNotRevValues,
          passedWhenNotRevValues = _ref18$passedWhenNotR === void 0 ? false : _ref18$passedWhenNotR,
          _ref18$findOrigin = _ref18.findOrigin,
          findOrigin = _ref18$findOrigin === void 0 ? null : _ref18$findOrigin,
          _ref18$findIssuer = _ref18.findIssuer,
          findIssuer = _ref18$findIssuer === void 0 ? null : _ref18$findIssuer;

      //region Global variables
      var sequence = Promise.resolve();
      var messageDigestValue = new ArrayBuffer(0);
      var shaAlgorithm = "";
      var signerCertificate = {};
      var timestampSerial = null;
      var certificatePath = [];
      var engine = getEngine(); //endregion
      //region Get a "crypto" extension

      var crypto = getCrypto();
      if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object"); //endregion
      //region Get a signer number

      if (signer === -1) {
        if (extendedMode) {
          return Promise.reject({
            date: checkDate,
            code: 1,
            message: "Unable to get signer index from input parameters",
            signatureVerified: null,
            signerCertificate: null,
            signerCertificateVerified: null
          });
        }

        return Promise.reject("Unable to get signer index from input parameters");
      } //endregion
      //region Check that certificates field was included in signed data


      if ("certificates" in this === false) {
        if (extendedMode) {
          return Promise.reject({
            date: checkDate,
            code: 2,
            message: "No certificates attached to this signed data",
            signatureVerified: null,
            signerCertificate: null,
            signerCertificateVerified: null
          });
        }

        return Promise.reject("No certificates attached to this signed data");
      } //endregion
      //region Find a certificate for specified signer


      if (this.signerInfos[signer].sid instanceof IssuerAndSerialNumber) {
        sequence = sequence.then(() => {
          var _iteratorNormalCompletion24 = true;
          var _didIteratorError24 = false;
          var _iteratorError24 = undefined;

          try {
            for (var _iterator24 = this.certificates[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
              var certificate = _step24.value;
              if (certificate instanceof Certificate === false) continue;

              if (certificate.issuer.isEqual(this.signerInfos[signer].sid.issuer) && certificate.serialNumber.isEqual(this.signerInfos[signer].sid.serialNumber)) {
                signerCertificate = certificate;
                return Promise.resolve();
              }
            }
          } catch (err) {
            _didIteratorError24 = true;
            _iteratorError24 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion24 && _iterator24.return != null) {
                _iterator24.return();
              }
            } finally {
              if (_didIteratorError24) {
                throw _iteratorError24;
              }
            }
          }

          if (extendedMode) {
            return Promise.reject({
              date: checkDate,
              code: 3,
              message: "Unable to find signer certificate",
              signatureVerified: null,
              signerCertificate: null,
              signerCertificateVerified: null
            });
          }

          return Promise.reject("Unable to find signer certificate");
        });
      } else // Find by SubjectKeyIdentifier
        {
          sequence = sequence.then(() => Promise.all(Array.from(this.certificates.filter(certificate => certificate instanceof Certificate), certificate => crypto.digest({
            name: "sha-1"
          }, new Uint8Array(certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(results => {
            var _iteratorNormalCompletion25 = true;
            var _didIteratorError25 = false;
            var _iteratorError25 = undefined;

            try {
              for (var _iterator25 = this.certificates.entries()[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                var _step25$value = _slicedToArray(_step25.value, 2),
                    index = _step25$value[0],
                    certificate = _step25$value[1];

                if (certificate instanceof Certificate === false) continue;

                if (isEqualBuffer(results[index], this.signerInfos[signer].sid.valueBlock.valueHex)) {
                  signerCertificate = certificate;
                  return Promise.resolve();
                }
              }
            } catch (err) {
              _didIteratorError25 = true;
              _iteratorError25 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion25 && _iterator25.return != null) {
                  _iterator25.return();
                }
              } finally {
                if (_didIteratorError25) {
                  throw _iteratorError25;
                }
              }
            }

            if (extendedMode) {
              return Promise.reject({
                date: checkDate,
                code: 3,
                message: "Unable to find signer certificate",
                signatureVerified: null,
                signerCertificate: null,
                signerCertificateVerified: null
              });
            }

            return Promise.reject("Unable to find signer certificate");
          }, () => {
            if (extendedMode) {
              return Promise.reject({
                date: checkDate,
                code: 3,
                message: "Unable to find signer certificate",
                signatureVerified: null,
                signerCertificate: null,
                signerCertificateVerified: null
              });
            }

            return Promise.reject("Unable to find signer certificate");
          }));
        } //endregion
      //region Verify internal digest in case of "tSTInfo" content type


      sequence = sequence.then(() => {
        if (this.encapContentInfo.eContentType === "1.2.840.113549.1.9.16.1.4") {
          //region Check "eContent" precense
          if ("eContent" in this.encapContentInfo === false) return false; //endregion
          //region Initialize TST_INFO value

          var asn1 = fromBER(this.encapContentInfo.eContent.valueBlock.valueHex);
          var tstInfo;

          try {
            tstInfo = new TSTInfo({
              schema: asn1.result
            });
          } catch (ex) {
            return false;
          } //endregion
          //region Change "checkDate" and append "timestampSerial"


          checkDate = tstInfo.genTime;
          timestampSerial = tstInfo.serialNumber.valueBlock.valueHex; //endregion
          //region Check that we do have detached data content

          if (data.byteLength === 0) {
            if (extendedMode) {
              return Promise.reject({
                date: checkDate,
                code: 4,
                message: "Missed detached data input array",
                signatureVerified: null,
                signerCertificate,
                signerCertificateVerified: null
              });
            }

            return Promise.reject("Missed detached data input array");
          } //endregion


          return tstInfo.verify({
            data
          });
        }

        return true;
      }); //endregion
      //region Make additional verification for signer's certificate

        checkCA(cert) {
        /// <param name="cert" type="in_window.org.pkijs.simpl.CERT">Certificate to find CA flag for</param>
        //region Do not include signer's certificate
        if (cert.issuer.isEqual(signerCertificate.issuer) === true && cert.serialNumber.isEqual(signerCertificate.serialNumber) === true) return null; //endregion

        var isCA = false;

        if ("extensions" in cert) {
          var _iteratorNormalCompletion26 = true;
          var _didIteratorError26 = false;
          var _iteratorError26 = undefined;

          try {
            for (var _iterator26 = cert.extensions[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
              var extension = _step26.value;

              if (extension.extnID === "2.5.29.19") // BasicConstraints
                {
                  if ("cA" in extension.parsedValue) {
                    if (extension.parsedValue.cA === true) isCA = true;
                  }
                }
            }
          } catch (err) {
            _didIteratorError26 = true;
            _iteratorError26 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion26 && _iterator26.return != null) {
                _iterator26.return();
              }
            } finally {
              if (_didIteratorError26) {
                throw _iteratorError26;
              }
            }
          }
        }

        if (isCA) return cert;
        return null;
      }

      if (checkChain) {
        sequence = sequence.then(result => {
          //region Verify result of previous operation
          if (result === false) return false; //endregion

          var promiseResults = Array.from(this.certificates.filter(certificate => certificate instanceof Certificate), certificate => checkCA(certificate));
          var certificateChainValidationEngineParameters = {
            checkDate,
            certs: Array.from(promiseResults.filter(_result => _result !== null)),
            trustedCerts
          };
          if (findIssuer !== null) certificateChainValidationEngineParameters.findIssuer = findIssuer;
          if (findOrigin !== null) certificateChainValidationEngineParameters.findOrigin = findOrigin;
          var certificateChainEngine = new CertificateChainValidationEngine(certificateChainValidationEngineParameters);
          certificateChainEngine.certs.push(signerCertificate);

          if ("crls" in this) {
            var _iteratorNormalCompletion27 = true;
            var _didIteratorError27 = false;
            var _iteratorError27 = undefined;

            try {
              for (var _iterator27 = this.crls[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                var crl = _step27.value;
                if ("thisUpdate" in crl) certificateChainEngine.crls.push(crl);else // Assumed "revocation value" has "OtherRevocationInfoFormat"
                  {
                    if (crl.otherRevInfoFormat === "1.3.6.1.5.5.7.48.1.1") // Basic OCSP response
                      certificateChainEngine.ocsps.push(new BasicOCSPResponse({
                        schema: crl.otherRevInfo
                      }));
                  }
              }
            } catch (err) {
              _didIteratorError27 = true;
              _iteratorError27 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion27 && _iterator27.return != null) {
                  _iterator27.return();
                }
              } finally {
                if (_didIteratorError27) {
                  throw _iteratorError27;
                }
              }
            }
          }

          if ("ocsps" in this) certificateChainEngine.ocsps.push(...this.ocsps);
          return certificateChainEngine.verify({
            passedWhenNotRevValues
          }).then(verificationResult => {
            if ("certificatePath" in verificationResult) certificatePath = verificationResult.certificatePath;
            if (verificationResult.result === true) return Promise.resolve(true);

            if (extendedMode) {
              return Promise.reject({
                date: checkDate,
                code: 5,
                message: "Validation of signer's certificate failed: ".concat(verificationResult.resultMessage),
                signatureVerified: null,
                signerCertificate,
                signerCertificateVerified: false
              });
            }

            return Promise.reject("Validation of signer's certificate failed");
          }, error => {
            if (extendedMode) {
              return Promise.reject({
                date: checkDate,
                code: 5,
                message: "Validation of signer's certificate failed with error: ".concat(error instanceof Object ? error.resultMessage : error),
                signatureVerified: null,
                signerCertificate,
                signerCertificateVerified: false
              });
            }

            return Promise.reject("Validation of signer's certificate failed with error: ".concat(error instanceof Object ? error.resultMessage : error));
          });
        });
      } //endregion
      //region Find signer's hashing algorithm


      sequence = sequence.then(result => {
        //region Verify result of previous operation
        if (result === false) return false; //endregion

        var signerInfoHashAlgorithm = getAlgorithmByOID(this.signerInfos[signer].digestAlgorithm.algorithmId);

        if ("name" in signerInfoHashAlgorithm === false) {
          if (extendedMode) {
            return Promise.reject({
              date: checkDate,
              code: 7,
              message: "Unsupported signature algorithm: ".concat(this.signerInfos[signer].digestAlgorithm.algorithmId),
              signatureVerified: null,
              signerCertificate,
              signerCertificateVerified: true
            });
          }

          return Promise.reject("Unsupported signature algorithm: ".concat(this.signerInfos[signer].digestAlgorithm.algorithmId));
        }

        shaAlgorithm = signerInfoHashAlgorithm.name;
        return true;
      }); //endregion
      //region Create correct data block for verification

      sequence = sequence.then(result => {
        //region Verify result of previous operation
        if (result === false) return false; //endregion

        if ("eContent" in this.encapContentInfo) // Attached data
          {
            if (this.encapContentInfo.eContent.idBlock.tagClass === 1 && this.encapContentInfo.eContent.idBlock.tagNumber === 4) {
              if (this.encapContentInfo.eContent.idBlock.isConstructed === false) data = this.encapContentInfo.eContent.valueBlock.valueHex;else {
                var _iteratorNormalCompletion28 = true;
                var _didIteratorError28 = false;
                var _iteratorError28 = undefined;

                try {
                  for (var _iterator28 = this.encapContentInfo.eContent.valueBlock.value[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                    var contentValue = _step28.value;
                    data = utilConcatBuf(data, contentValue.valueBlock.valueHex);
                  }
                } catch (err) {
                  _didIteratorError28 = true;
                  _iteratorError28 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion28 && _iterator28.return != null) {
                      _iterator28.return();
                    }
                  } finally {
                    if (_didIteratorError28) {
                      throw _iteratorError28;
                    }
                  }
                }
              }
            } else data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
          } else // Detached data
          {
            if (data.byteLength === 0) // Check that "data" already provided by   parameter
              {
                if (extendedMode) {
                  return Promise.reject({
                    date: checkDate,
                    code: 8,
                    message: "Missed detached data input array",
                    signatureVerified: null,
                    signerCertificate,
                    signerCertificateVerified: true
                  });
                }

                return Promise.reject("Missed detached data input array");
              }
          }

        if ("signedAttrs" in this.signerInfos[signer]) {
          //region Check mandatory attributes
          var foundContentType = false;
          var foundMessageDigest = false;
          var _iteratorNormalCompletion29 = true;
          var _didIteratorError29 = false;
          var _iteratorError29 = undefined;

          try {
            for (var _iterator29 = this.signerInfos[signer].signedAttrs.attributes[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
              var attribute = _step29.value;
              //region Check that "content-type" attribute exists
              if (attribute.type === "1.2.840.113549.1.9.3") foundContentType = true; //endregion
              //region Check that "message-digest" attribute exists

              if (attribute.type === "1.2.840.113549.1.9.4") {
                foundMessageDigest = true;
                messageDigestValue = attribute.values[0].valueBlock.valueHex;
              } //endregion
              //region Speed-up searching


              if (foundContentType && foundMessageDigest) break; //endregion
            }
          } catch (err) {
            _didIteratorError29 = true;
            _iteratorError29 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion29 && _iterator29.return != null) {
                _iterator29.return();
              }
            } finally {
              if (_didIteratorError29) {
                throw _iteratorError29;
              }
            }
          }

          if (foundContentType === false) {
            if (extendedMode) {
              return Promise.reject({
                date: checkDate,
                code: 9,
                message: "Attribute \"content-type\" is a mandatory attribute for \"signed attributes\"",
                signatureVerified: null,
                signerCertificate,
                signerCertificateVerified: true
              });
            }

            return Promise.reject("Attribute \"content-type\" is a mandatory attribute for \"signed attributes\"");
          }

          if (foundMessageDigest === false) {
            if (extendedMode) {
              return Promise.reject({
                date: checkDate,
                code: 10,
                message: "Attribute \"message-digest\" is a mandatory attribute for \"signed attributes\"",
                signatureVerified: null,
                signerCertificate,
                signerCertificateVerified: true
              });
            }

            return Promise.reject("Attribute \"message-digest\" is a mandatory attribute for \"signed attributes\"");
          } //endregion

        }

        return true;
      }); //endregion
      //region Verify "message-digest" attribute in case of "signedAttrs"

      sequence = sequence.then(result => {
        //region Verify result of previous operation
        if (result === false) return false; //endregion

        if ("signedAttrs" in this.signerInfos[signer]) return crypto.digest(shaAlgorithm, new Uint8Array(data));
        return true;
      }).then(
      /**
       * @param {ArrayBuffer} result
       */
      result => {
        //region Verify result of previous operation
        if (result === false) return false; //endregion

        if ("signedAttrs" in this.signerInfos[signer]) {
          if (isEqualBuffer(result, messageDigestValue)) {
            data = this.signerInfos[signer].signedAttrs.encodedValue;
            return true;
          }

          return false;
        }

        return true;
      }); //endregion

      sequence = sequence.then(result => {
        //region Verify result of previous operation
        if (result === false) return false; //endregion

        return engine.subtle.verifyWithPublicKey(data, this.signerInfos[signer].signature, signerCertificate.subjectPublicKeyInfo, signerCertificate.signatureAlgorithm, shaAlgorithm);
      }); //region Make a final result

      sequence = sequence.then(result => {
        if (extendedMode) {
          return {
            date: checkDate,
            code: 14,
            message: "",
            signatureVerified: result,
            signerCertificate,
            timestampSerial,
            signerCertificateVerified: true,
            certificatePath
          };
        }

        return result;
      }, error => {
        if (extendedMode) {
          if ("code" in error) return Promise.reject(error);
          return Promise.reject({
            date: checkDate,
            code: 15,
            message: "Error during verification: ".concat(error.message),
            signatureVerified: null,
            signerCertificate,
            timestampSerial,
            signerCertificateVerified: true
          });
        }

        return Promise.reject(error);
      }); //endregion

      return sequence;
    } //**********************************************************************************

    /**
     * Signing current SignedData
     * @param {key} privateKey Private key for "subjectPublicKeyInfo" structure
     * @param {number} signerIndex Index number (starting from 0) of signer index to make signature for
     * @param {string} [hashAlgorithm="SHA-1"] Hashing algorithm. Default SHA-1
     * @param {ArrayBuffer} [data] Detached data
     * @returns {*}
     */


    sign(privateKey, signerIndex) {
      var hashAlgorithm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "SHA-1";
      var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new ArrayBuffer(0);
      //region Initial checking
      if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing"); //endregion
      //region Initial variables

      var sequence = Promise.resolve();
      var parameters;
      var engine = getEngine(); //endregion
      //region Simple check for supported algorithm

      var hashAlgorithmOID = getOIDByAlgorithm({
        name: hashAlgorithm
      });
      if (hashAlgorithmOID === "") return Promise.reject("Unsupported hash algorithm: ".concat(hashAlgorithm)); //endregion
      //region Append information about hash algorithm

      if (this.digestAlgorithms.filter(algorithm => algorithm.algorithmId === hashAlgorithmOID).length === 0) {
        this.digestAlgorithms.push(new AlgorithmIdentifier({
          algorithmId: hashAlgorithmOID,
          algorithmParams: new Null()
        }));
      }

      this.signerInfos[signerIndex].digestAlgorithm = new AlgorithmIdentifier({
        algorithmId: hashAlgorithmOID,
        algorithmParams: new Null()
      }); //endregion
      //region Get a "default parameters" for current algorithm and set correct signature algorithm

      sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
      sequence = sequence.then(result => {
        parameters = result.parameters;
        this.signerInfos[signerIndex].signatureAlgorithm = result.signatureAlgorithm;
      }); //endregion
      //region Create TBS data for signing

      sequence = sequence.then(() => {
        if ("signedAttrs" in this.signerInfos[signerIndex]) {
          if (this.signerInfos[signerIndex].signedAttrs.encodedValue.byteLength !== 0) data = this.signerInfos[signerIndex].signedAttrs.encodedValue;else {
            data = this.signerInfos[signerIndex].signedAttrs.toSchema(true).toBER(false); //region Change type from "[0]" to "SET" acordingly to standard

            var view = new Uint8Array(data);
            view[0] = 0x31; //endregion
          }
        } else {
          if ("eContent" in this.encapContentInfo) // Attached data
            {
              if (this.encapContentInfo.eContent.idBlock.tagClass === 1 && this.encapContentInfo.eContent.idBlock.tagNumber === 4) {
                if (this.encapContentInfo.eContent.idBlock.isConstructed === false) data = this.encapContentInfo.eContent.valueBlock.valueHex;else {
                  var _iteratorNormalCompletion30 = true;
                  var _didIteratorError30 = false;
                  var _iteratorError30 = undefined;

                  try {
                    for (var _iterator30 = this.encapContentInfo.eContent.valueBlock.value[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                      var content = _step30.value;
                      data = utilConcatBuf(data, content.valueBlock.valueHex);
                    }
                  } catch (err) {
                    _didIteratorError30 = true;
                    _iteratorError30 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion30 && _iterator30.return != null) {
                        _iterator30.return();
                      }
                    } finally {
                      if (_didIteratorError30) {
                        throw _iteratorError30;
                      }
                    }
                  }
                }
              } else data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
            } else // Detached data
            {
              if (data.byteLength === 0) // Check that "data" already provided by   parameter
                return Promise.reject("Missed detached data input array");
            }
        }

        return Promise.resolve();
      }); //endregion
      //region Signing TBS data on provided private key

      sequence = sequence.then(() => engine.subtle.signWithPrivateKey(data, privateKey, parameters));
      sequence = sequence.then(result => {
        this.signerInfos[signerIndex].signature = new OctetString({
          valueHex: result
        });
        return result;
      }); //endregion

      return sequence;
    } //**********************************************************************************


  } //**************************************************************************************

  /* eslint-disable no-console,no-undef,no-unreachable */
  //*********************************************************************************


  var trustedCertificates = []; // Array of Certificates
  //*********************************************************************************
  // noinspection  WithInconsistentReturnsJS

    verifyPDFSignature(buffer) {
    try {
      var view = new Uint8Array(buffer);
      var pdf = new PDFDocument(null, view, null);
      pdf.parseStartXRef();
      pdf.parse();
      var acroForm = pdf.xref.root.get("AcroForm");
      if (typeof acroForm === "undefined") throw new Error("The PDF has no signature!");
      var fields = acroForm.get("Fields");
      if (window.isRef(fields[0]) === false) throw new Error("Wrong structure of PDF!");
      var sigField = pdf.xref.fetch(fields[0]);
      var sigFieldType = sigField.get("FT");
      if (typeof sigFieldType === "undefined" || sigFieldType.name !== "Sig") throw new Error("Wrong structure of PDF!");
      var v = sigField.get("V");
      var byteRange = v.get("ByteRange");
      var contents = v.get("Contents");
      var contentLength = contents.length;
      var contentBuffer = new ArrayBuffer(contentLength);
      var contentView = new Uint8Array(contentBuffer);

      for (var i = 0; i < contentLength; i++) {
        contentView[i] = contents.charCodeAt(i);
      }

      var sequence = Promise.resolve();
      var asn1 = fromBER(contentBuffer);
      var cmsContentSimp = new ContentInfo({
        schema: asn1.result
      });
      var cmsSignedSimp = new SignedData({
        schema: cmsContentSimp.content
      });
      var signedDataBuffer = new ArrayBuffer(byteRange[1] + byteRange[3]);
      var signedDataView = new Uint8Array(signedDataBuffer);
      var count = 0;

      for (var _i54 = byteRange[0]; _i54 < byteRange[0] + byteRange[1]; _i54++, count++) {
        signedDataView[count] = view[_i54];
      }

      for (var j = byteRange[2]; j < byteRange[2] + byteRange[3]; j++, count++) {
        signedDataView[count] = view[j];
      }

      sequence = sequence.then(() => cmsSignedSimp.verify({
        signer: 0,
        data: signedDataBuffer,
        trustedCerts: trustedCertificates
      }));

      if ("signedAttrs" in cmsSignedSimp.signerInfos[0]) {
        var crypto = getCrypto();
        if (typeof crypto === "undefined") throw new Error("WebCrypto extension is not installed");
        var shaAlgorithm = "";

        switch (cmsSignedSimp.signerInfos[0].digestAlgorithm.algorithmId) {
          case "1.3.14.3.2.26":
            shaAlgorithm = "sha-1";
            break;

          case "2.16.840.1.101.3.4.2.1":
            shaAlgorithm = "sha-256";
            break;

          case "2.16.840.1.101.3.4.2.2":
            shaAlgorithm = "sha-384";
            break;

          case "2.16.840.1.101.3.4.2.3":
            shaAlgorithm = "sha-512";
            break;

          default:
            throw new Error("Unknown hashing algorithm");
        }

        sequence = sequence.then(result => {
          if (result === false) return Promise.reject(new Error("Signature verification failed"));
          return crypto.digest({
            name: shaAlgorithm
          }, new Uint8Array(signedDataBuffer));
        });
        sequence = sequence.then(result => {
          var messageDigest = new ArrayBuffer(0);

          for (var _j18 = 0; _j18 < cmsSignedSimp.signerInfos[0].signedAttrs.attributes.length; _j18++) {
            if (cmsSignedSimp.signerInfos[0].signedAttrs.attributes[_j18].type === "1.2.840.113549.1.9.4") {
              messageDigest = cmsSignedSimp.signerInfos[0].signedAttrs.attributes[_j18].values[0].valueBlock.valueHex;
              break;
            }
          }

          if (messageDigest.byteLength === 0) return Promise.reject(new Error("No signed attribute 'MessageDigest'"));
          var view1 = new Uint8Array(messageDigest); // noinspection JSCheck Signatures

          var view2 = new Uint8Array(result);
          if (view1.length !== view2.length) return Promise.reject(new Error("Hash is not correct"));

          for (var _i55 = 0; _i55 < view1.length; _i55++) {
            if (view1[_i55] !== view2[_i55]) return Promise.reject(new Error("Hash is not correct"));
          }

          return Promise.resolve();
        });
      }

      sequence = sequence.then(result => {
        if (typeof result !== "undefined") {
          if (result === false) {
            alert("PDF verification failed!");
            return;
          }
        }

        alert("PDF successfully verified!");
      });
      return sequence.catch(e => {
        throw e;
      });
    } catch (e) {
      console.error(e.stack);
    }
  } //*********************************************************************************


    parseCAbundle(buffer) {
    //region Initial variables
    var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var startChars = "-----BEGIN CERTIFICATE-----";
    var endChars = "-----END CERTIFICATE-----";
    var endLineChars = "\r\n";
    var view = new Uint8Array(buffer);
    var waitForStart = false;
    var middleStage = true;
    var waitForEnd = false;
    var waitForEndLine = false;
    var started = false;
    var certBodyEncoded = ""; //endregion

    for (var i = 0; i < view.length; i++) {
      if (started === true) {
        if (base64Chars.indexOf(String.fromCharCode(view[i])) !== -1) certBodyEncoded += String.fromCharCode(view[i]);else {
          if (String.fromCharCode(view[i]) === "-") {
            //region Decoded trustedCertificates
            var asn1 = fromBER(stringToArrayBuffer(window.atob(certBodyEncoded)));

            try {
              trustedCertificates.push(new Certificate({
                schema: asn1.result
              }));
            } catch (ex) {
              alert("Wrong certificate format");
              return;
            } //endregion
            //region Set all "flag variables"


            certBodyEncoded = "";
            started = false;
            waitForEnd = true; //endregion
          }
        }
      } else {
        if (waitForEndLine === true) {
          if (endLineChars.indexOf(String.fromCharCode(view[i])) === -1) {
            waitForEndLine = false;

            if (waitForEnd === true) {
              waitForEnd = false;
              middleStage = true;
            } else {
              if (waitForStart === true) {
                waitForStart = false;
                started = true;
                certBodyEncoded += String.fromCharCode(view[i]);
              } else middleStage = true;
            }
          }
        } else {
          if (middleStage === true) {
            if (String.fromCharCode(view[i]) === "-") {
              if (i === 0 || String.fromCharCode(view[i - 1]) === "\r" || String.fromCharCode(view[i - 1]) === "\n") {
                middleStage = false;
                waitForStart = true;
              }
            }
          } else {
            if (waitForStart === true) {
              if (startChars.indexOf(String.fromCharCode(view[i])) === -1) waitForEndLine = true;
            } else {
              if (waitForEnd === true) {
                if (endChars.indexOf(String.fromCharCode(view[i])) === -1) waitForEndLine = true;
              }
            }
          }
        }
      }
    }
  } //*********************************************************************************


    handleFileBrowse(evt) {
    var tempReader = new FileReader();
    var currentFiles = evt.target.files; // noinspection Anonymous JS, JSUnresolvedVariable

    tempReader.onload = event => verifyPDFSignature(event.target.result);

    tempReader.readAsArrayBuffer(currentFiles[0]);
  } //*********************************************************************************


    handleCABundle(evt) {
    var tempReader = new FileReader();
    var currentFiles = evt.target.files; // noinspection Anonymous JS, JSUnresolvedVariable

    tempReader.onload = event => parseCAbundle(event.target.result);

    tempReader.readAsArrayBuffer(currentFiles[0]);
  }
}
export {PKI}; 
